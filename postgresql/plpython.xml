<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="plpython">
 <title>PL/Python - Langage de procédures Python</title>

 <indexterm zone="plpython"><primary>PL/Python</primary></indexterm>
 <indexterm zone="plpython"><primary>Python</primary></indexterm>

 <para>
  Le langage de procédures <application>PL/Python</application> permet
  l'écriture de fonctions <productname>PostgreSQL</productname> avec le
  <ulink url="http://www.python.org">langage Python</ulink> (mais voir aussi
  <xref linkend="plpython-python23"/>).
 </para>

 <para>
  Pour installer PL/Python dans une base de données particulières, utilisez
  <literal>createlang plpythonu <replaceable>nom_base</replaceable></literal>.
 </para>

  <tip>
   <para>
    Si un langage est installé dans <literal>template1</literal>, toutes les bases
    nouvellement créées se verront installées ce langage automatiquement.
   </para>
  </tip>

 <para>
  Depuis <productname>PostgreSQL</productname> 7.4, PL/Python est seulement
  disponible en tant que langage <quote>sans confiance</quote> (ceci signifiant
  qu'il n'offre aucun moyen de restreindre ce que les utilisateurs en font). Il
  a donc été renommé en <literal>plpythonu</literal>. La variante de confiance
  <literal>plpython</literal> pourrait être de nouveau disponible dans le futur, si un
  nouveau mécanisme sécurisé d'exécution est développé dans Python. Le codeur
  d'une fonction dans PL/Python sans confiance doit faire attention à ce que
  cette fonction ne puisse pas être utilisée pour réaliser quelque chose qui
  n'est pas prévue car il sera possible de faire tout ce que peut faire un
  utilisateur connecté en tant qu'administrateur de la base de données. Seuls
  les superutilisateurs peuvent créer des fonctions dans des langages sans
  confiance comme <literal>plpythonu</literal>.
 </para>

 <note>
  <para>
   Les utilisateurs des paquets sources doivent activer spécifiquement la
   construction de PL/Python lors des étapes d'installation (référez-vous aux
   instructions d'installation pour plus d'informations). Les utilisateurs de
   paquets binaires pourront trouver PL/Python dans un paquet séparé.
  </para>
 </note>

 <sect1 id="plpython-python23">
  <title>Python 2 et Python 3</title>

  <para>
   PL/Python accepte à la fois les versions 2 et 3 de Python. (Les instructions
   d'installation de PostgreSQL peuvent contenir des informations plus précises
   sur les versions mineures précisément supportées de Python.) Comme les
   variantes Python 2 et Python 3 sont incompatibles pour certaines parties
   très importantes, le schéma de nommage et de transition suivant est utilisé
   par PL/Python pour éviter de les mixer&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Le langage PostgreSQL nommé <literal>plpython2u</literal> implémente
      PL/Python sur la variante Python 2 du langage.
     </para>
    </listitem>

    <listitem>
     <para>
      Le langage PostgreSQL nommé <literal>plpython3u</literal> implémente
      PL/Python sur la variante Python 3 du langage.
     </para>
    </listitem>

    <listitem>
     <para>
      Le langage nommé <literal>plpythonu</literal> implémente PL/Python
      suivant la variante par défaut du langage Python, qui est actuellement
      Python 2. (Cette valeur par défaut est indépendante de ce que toute
      installations locales de Python pourrait considérer comme la valeur
      par <quote>défaut</quote>, par exemplece que pourrait être
      <filename>/usr/bin/python</filename>.) La valeur par défaut sera
      probablement changée avec Python 3 dans une prochaine version de
      PostgreSQL, suivant les progrès de la migration à Python 3 dans la
      communauté Python.
     </para>
    </listitem>
   </itemizedlist>

   Cela dépend de la configuration lors de la compilation ou des paquets
   installés si PL/Python pour Python 2 ou Python 3 ou les deux sont
   disponibles.
  </para>

  <para>
   Ceci a pour résultat la stratégie suivante d'utilisation et de
   migration&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Les utilisateurs existants et ceux qui ne sont pas actuellement
      intéressés par Python 3 utilisent le nom <literal>plpythonu</literal>
      et n'ont rien à changer pour l'instant. Il est recommandé de
      <quote>s'assurer</quote> graduellement de migrer le code vers
      Python 2.6/2.7 pour simplifier une migration éventuelle vers Python 3.
     </para>

     <para>
      En pratique, beaucoup de fonctions PL/Python seront migrées à Python 3
      avec peu, voire par du tout, de modifications.
     </para>
    </listitem>

    <listitem>
     <para>
      Les utilisateurs sachant d'avance qu'ils ont du code reposant massivement
      sur Python 2 et ne planifient pas de changer peuvent utiliser le nom
      <literal>plpython2u</literal>. Cela continuera de fonctionner, y compris
      dans un futur lointain, jusqu'à ce que le support de Python 2 soit
      complètement supprimée de PostgreSQL.
     </para>
    </listitem>

    <listitem>
     <para>
      Les utilisateurs qui veulent utiliser Python 3 peuvent utiliser le nom
      <literal>plpython3u</literal>, qui continuera à fonctionner en permanence
      avec les standards actuels. Dans le futur, quand Python 3 deviendra la
      version par défaut du langage, ils pourront supprimer le chiffre
      <quote>3</quote>, principalement pour des raisons esthétiques.
     </para>
    </listitem>

    <listitem>
     <para>
      Les intrépides qui veulent construire un système d'exploitation utilisant
      seulement Python-3, peuvent modifier les scripts de compilation pour
      rendre <literal>plpythonu</literal> équivalent à
      <literal>plpython3u</literal>, en gardant en tête que cela rend leur
      installation incompatible avec la majorité de ce qui existe dans ce
      monde.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Voir aussi le document <ulink
   url="http://docs.python.org/dev/3.0/whatsnew/3.0.html">What's New In Python
   3.0</ulink> pour plus d'informations sur le portage vers Python 3.
  </para>

  <para>
   Il n'est pas permis d'utiliser PL/Python basé sur Python 2 et PL/Python
   basé sur Python 3 dans la même session car les symbôles dans les modules
   dynamiques entreraient en conflit, ce qui pourrait résulter en des arrêts
   brutaux du processus serveur PostgreSQL. Une vérification est ajoutée pour
   empêcher ce mélange de versions majeures Python dans une même sessio. Cette
   vérification aura pour effet d'annuler la session si une différence est
   détectée. Néanmoins, il est possible d'utiliser les deux variantes de
   PL/Python dans une même base de données à condition que ce soit dans des
   sessions séparées.
  </para>
 </sect1>

 <sect1 id="plpython-funcs">
  <title>Fonctions PL/Python</title>

  <para>
   Les fonctions PL/Python sont déclarées via la syntaxe standard <xref
   linkend="sql-createfunction"/>&nbsp;:
<programlisting>CREATE FUNCTION <replaceable>nom_fonction</replaceable> (<replaceable>liste-arguments</replaceable>)
  RETURNS <replaceable>return-type</replaceable>
AS $$
  # corps de la fonction PL/Python
$$ LANGUAGE plpythonu;
</programlisting>
  </para>

  <para>
   Le corps d'une fonction est tout simplement un script Python. Quand la
   fonction est appelée, ses arguments sont passés au script Python comme des
   éléments de la liste <varname>args</varname>&nbsp;; les arguments nommés
   sont en plus passés comme des variables ordinaires. L'utilisation des
   arguments nommés est beaucoup plus lisible.  Le résultat est renvoyé
   par le code Python de la façon habituelle, avec <literal>return</literal> ou
   <literal>yield</literal> (dans le cas d'une instruction avec un ensemble
   de résultats). Si vous ne fournissez pas une valeur de retour, Python
   renvoie la valeur par défaut <symbol>None</symbol>.
   <application>PL/Python</application> traduit la valeur <symbol>None</symbol>
   de Python comme une valeur NULL SQL.
  </para>

  <para>
   Par exemple, une fonction renvoyant le plus grand de deux entiers peut
   être définie ainsi&nbsp;:

<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

   Le code Python donné comme corps de la définition de fonction est transformé
   en fonction Python. Par exemple, le code ci-dessus devient&nbsp;:

<programlisting>def __plpython_procedure_pymax_23456():
  if a &gt; b:
    return a
  return b</programlisting>

   en supposant que 23456 est l'OID affecté à la fonction par
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   The arguments are set as global variables.  Because of the scoping
   rules of Python, this has the subtle consequence that an argument
   variable cannot be reassigned inside the function to the value of
   an expression that involves the variable name itself, unless the
   variable is redeclared as global in the block.  For example, the
   following won't work:
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  x = x.strip()  # error
  return x
$$ LANGUAGE plpythonu;
</programlisting>
   because assigning to <varname>x</varname>
   makes <varname>x</varname> a local variable for the entire block,
   and so the <varname>x</varname> on the right-hand side of the
   assignment refers to a not-yet-assigned local
   variable <varname>x</varname>, not the PL/Python function
   parameter.  Using the <literal>global</literal> statement, this can
   be made to work:
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  global x
  x = x.strip()  # ok now
  return x
$$ LANGUAGE plpythonu;
</programlisting>
   But it is advisable not to rely on this implementation detail of
   PL/Python.  It is better to treat the function parameters as
   read-only.
  </para>
 </sect1>

 <sect1 id="plpython-data">
  <title>Data Values</title>
  <para>
   Generally speaking, the aim of PL/Python is to provide
   a <quote>natural</quote> mapping between the PostgreSQL and the
   Python worlds.  This informs the data mapping rules described
   below.
  </para>

  <sect2>
   <title>Data Type Mapping</title>
   <para>
    Function arguments are converted from their PostgreSQL type to a
    corresponding Python type:
    <itemizedlist>
     <listitem>
      <para>
       PostgreSQL <type>boolean</type> is converted to Python <type>bool</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>smallint</type> and <type>int</type> are
       converted to Python <type>int</type>.
       PostgreSQL <type>bigint</type> is converted
       to <type>long</type> in Python 2 and to <type>int</type> in
       Python 3.
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>real</type>, <type>double</type>,
       and <type>numeric</type> are converted to
       Python <type>float</type>.  Note that for
       the <type>numeric</type> this loses information and can lead to
       incorrect results.  This might be fixed in a future
       release.
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>bytea</type> is converted to
       Python <type>str</type> in Python 2 and to <type>bytes</type>
       in Python 3.  In Python 2, the string should be treated as a
       byte sequence without any character encoding.
      </para>
     </listitem>

     <listitem>
      <para>
       All other data types, including the PostgreSQL character string
       types, are converted to a Python <type>str</type>.  In Python
       2, this string will be in the PostgreSQL server encoding; in
       Python 3, it will be a Unicode string like all strings.
      </para>
     </listitem>

     <listitem>
      <para>
       For nonscalar data types, see below.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Function return values are converted to the declared PostgreSQL
    return data type as follows:
    <itemizedlist>
     <listitem>
      <para>
       When the PostgreSQL return type is <type>boolean</type>, the
       return value will be evaluated for truth according to the
       <emphasis>Python</emphasis> rules.  That is, 0 and empty string
       are false, but notably <literal>'f'</literal> is true.
      </para>
     </listitem>

     <listitem>
      <para>
       When the PostgreSQL return type is <type>bytea</type>, the
       return value will be converted to a string (Python 2) or bytes
       (Python 3) using the respective Python builtins, with the
       result being converted <type>bytea</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       For all other PostgreSQL return types, the returned Python
       value is converted to a string using the Python
       builtin <literal>str</literal>, and the result is passed to the
       input function of the PostgreSQL data type.
      </para>

      <para>
       Strings in Python 2 are required to be in the PostgreSQL server
       encoding when they are passed to PostgreSQL.  Strings that are
       not valid in the current server encoding will raise an error,
       but not all encoding mismatches can be detected, so garbage
       data can still result when this is not done correctly.  Unicode
       strings are converted to the correct encoding automatically, so
       it can be safer and more convenient to use those.  In Python 3,
       all strings are Unicode strings.
      </para>
     </listitem>

     <listitem>
      <para>
       For nonscalar data types, see below.
      </para>
     </listitem>
    </itemizedlist>

    Note that logical mismatches between the declared PostgreSQL
    return type and the Python data type of the actual return object
    are not flagged; the value will be converted in any case.
   </para>

   <tip>
    <para>
     <application>PL/Python</application> functions cannot return
     either type <type>RECORD</type> or <type>SETOF RECORD</type>.  A
     workaround is to write a <application>PL/pgSQL</application>
     function that creates a temporary table, have it call the
     <application>PL/Python</application> function to fill the table,
     and then have the <application>PL/pgSQL</application> function
     return the generic <type>RECORD</type> from the temporary table.
    </para>
   </tip>
  </sect2>

  <sect2>
   <title>Null, None</title>

  <para>
   Si une valeur SQL NULL<indexterm><primary>valeur NULL</primary><secondary
   sortas="PL/Python">PL/Python</secondary></indexterm> est passée à une fonction,
   la valeur de l'argument apparaîtra comme <symbol>None</symbol> au niveau de
   Python. La définition de la fonction ci-dessus renverra la mauvaise réponse
   pour des entrées NULL. Nous pouvons jouer <literal>STRICT</literal> à la
   définition de la fonction pour faire en sorte que
   <productname>PostgreSQL</productname> fasse quelque-chose de plus
   raisonnable&nbsp;: si une valeur NULL est passée, la fonction ne sera pas
   appelée du tout mais renverra juste un résultat NULL automatiquement.
   Sinon, vous pouver vérifier les entrées NULL dans le corps de la
   fonction&nbsp;:

<programlisting>CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if (a is None) or (b is None):
    return None
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

   Comme montré ci-dessus, pour renvoyer une valeur SQL NULL à partir d'une
   fonction PL/Python, renvoyez la valeur <symbol>None</symbol>. Ceci peut
   se faire que la fonction soit stricte ou non.
  </para>

  </sect2>

  <sect2 id="plpython-arrays">
   <title>Tableaux, Listes</title>
  <para>
   Les valeurs de type tableaux SQL sont passées via PL/Python comme des listes
   Python. Pour renvoyer une valeur de type tableau SQL par une fonction
   PL/Python, renvoyez une séquence Python, par exemple une liste ou un
   tuple&nbsp;:

<programlisting>
CREATE FUNCTION return_arr()
  RETURNS int[]
AS $$
return (1, 2, 3, 4, 5)
$$ LANGUAGE plpythonu;

SELECT return_arr();
 return_arr  
-------------
 {1,2,3,4,5}
(1 row)
</programlisting>

   Notez que, avec Python, les chaînes sont des séquences, ce qui peut avoir
   des effets indésirables qui peuvent être familiers aux codeurs Python&nbsp;:

<programlisting>
CREATE FUNCTION return_str_arr()
  RETURNS varchar[]
AS $$
return "hello"
$$ LANGUAGE plpythonu;

SELECT return_str_arr();
 return_str_arr
----------------
 {h,e,l,l,o}
(1 row)
</programlisting>
  </para>
  </sect2>

  <sect2>
   <title>Types composites</title>
  <para>
   Les arguments de type composite sont passés à la fonction via une
   correspondance Python. Les noms d'élément de la correspondance sont les noms
   d'attribut du type composite. Si un attribut a une valeur NULL dans la ligne
   traitée; il a la valeur NULL dans sa correspondance. Voici un exemple&nbsp;:

<programlisting>CREATE TABLE employe (
  nom text,
  salaire integer,
  age integer
);

CREATE FUNCTION trop_paye (e employe)
  RETURNS boolean
AS $$
  if e["salaire"] &gt; 200000:
    return True
  if (e["age"] &lt; 30) and (e["salaire"] &gt; 100000):
    return True
  return False
$$ LANGUAGE plpythonu;
</programlisting>
  </para>

  <para>
   Il existe plusieurs façon de renvoyer une ligne ou des types composites à
   partir d'une fonction Python. Les exemples suivants supposent que nous
   avons&nbsp;:

<programlisting>CREATE TABLE valeur_nommee (
  nom   text,
  valeur  integer
);
</programlisting>
   ou
<programlisting>CREATE TYPE valeur_nommee AS (
  nom   text,
  valeur  integer
);
</programlisting>

   Une valeur composite peut être renvoyé comme&nbsp;:
   <variablelist>
    <varlistentry>
     <term>Un type séquence (ligne ou liste), mais pas
       un ensemble parce que ce n'est pas indexable</term>
     <listitem>
      <para>
       Les objets séquences renvoyés doivent avoir le même nombre d'éléments que
       le type composite a de champs. L'élément d'index 0 est affecté au
       premier champ du type composite, 1 au second et ainsi de suite. Par
       exemple&nbsp;:

<programlisting>CREATE FUNCTION cree_paire (nom text, valeur integer)
  RETURNS valeur_nommee
AS $$
  return [ nom, valeur ]
  # ou autrement, en tant que ligne : return ( nom, valeur )
$$ LANGUAGE plpythonu;
</programlisting>

       Pour renvoyer NULL dans une colonne, insérez <symbol>None</symbol> à la
       position correspondante.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Correspondance (dictionnaire)</term>
     <listitem>
      <para>
       La valeur de chaque colonne du type résultat est récupérée à partir de la
       correspondance avec le nom de colonne comme clé. Exemple&nbsp;:

<programlisting>CREATE FUNCTION cree_paire (nom text, valeur integer)
  RETURNS valeur_nommee
AS $$
  return { "nom": nom, "valeur": valeur }
$$ LANGUAGE plpythonu;
</programlisting>

       Des paires clés/valeurs supplémentaires du dictionnaire sont ignorées.
       Les clés manquantes sont traitées comme des erreurs.
       Pour renvoyer NULL comme une colonne, insérez <symbol>None</symbol>
       avec le nom de la colonne correspondante comme clé.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Objet (tout objet fournissant la méthode <literal>__getattr__</literal>)</term>
     <listitem>
      <para>
       Ceci fonctionne de la même façon qu'une correspondance.
       Exemple&nbsp;:

<programlisting>CREATE FUNCTION cree_paire (nom text, valeur integer)
  RETURNS valeur_nommee
AS $$
  class valeur_nommee:
    def __init__ (self, n, v):
      self.nom = n
      self.valeur = v
  return valeur_nommee(nom, valeur)

  # ou simplement
  class nv: pass
  nv.nom = nom
  nv.valeur = valeur
  return nv
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  </sect2>

  <sect2>
   <title>Set-Returning Functions</title>

  <para>
   Une fonction <application>PL/Python</application> peut aussi renvoyer des
   ensembles scalaires ou des types composites. Il existe plusieurs façon de
   faire ceci parce que l'objet renvoyé est transformé en interne en itérateur.
   Les exemples suivants supposent que nous avons le type composite&nbsp;:

<programlisting>CREATE TYPE greeting AS (
  how text,
  who text
);
</programlisting>
   
   Un résultat ensemble peut être renvoyé à partir de&nbsp;:
   <variablelist>
    <varlistentry>
     <term>Un type séquence (ligne, liste, ensemble)</term>
     <listitem>
      <para>
<programlisting>CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  # renvoie la ligne contenant les listes en tant que types composites
  # toutes les autres combinaisons fonctionnent aussi
  return ( [ how, "World" ], [ how, "PostgreSQL" ], [ how, "PL/Python" ] )
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>L'itérateur (tout objet fournissant les méthodes <symbol>__iter__</symbol>
      et <symbol>next</symbol>)</term>
     <listitem>
      <para>
<programlisting>CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  class producer:
    def __init__ (self, how, who):
      self.how = how
      self.who = who
      self.ndx = -1

    def __iter__ (self):
      return self

    def next (self):
      self.ndx += 1
      if self.ndx == len(self.who):
        raise StopIteration
      return ( self.how, self.who[self.ndx] )

  return producer(how, [ "World", "PostgreSQL", "PL/Python" ])
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Le générateur (<literal>yield</literal>)</term>
     <listitem>
      <para>
<programlisting>CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  for who in [ "World", "PostgreSQL", "PL/Python" ]:
    yield ( how, who )
$$ LANGUAGE plpythonu;
</programlisting>

       <warning>
        <para>
         À cause du
         <ulink url="http://bugs.python.org/issue1483133">bogue #1483133</ulink> de Python,
         certaines versions de débogage de Python 2.4
         (configuré et compilé avec l'option <literal>--with-pydebug</literal>)
         sont connues pour arrêter brutalement le serveur
	 <productname>PostgreSQL</productname> lors de l'utilisation d'un
	 itérateur pour renvoyer un résultat ensemble. Les versions non corrigées de
         Fedora 4 contiennent ce bogue. Cela n'arrive pas dans les versions de
         production de Python et sur les versions corrigées de Fedora 4.
        </para>
       </warning>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  </sect2>
 </sect1>

 <sect1 id="plpython-sharing">
  <title>Sharing Data</title>
  
  <para>
   Le dictionnaire global <varname>SD</varname> est disponible pour stocker des
   données entres les appels de fonctions. Cette variable est une donnée
   statique privée. Le dictionnaire global <varname>GD</varname> est une donnée
   publique disponible pour toutes les fonctions Python à l'intérieur d'une
   session. À utiliser avec précaution.<indexterm><primary>données
   globales</primary><secondary>en PL/Python</secondary></indexterm>
  </para>

  <para>
   Chaque fonction obtient son propre environnement d'exécution dans
   l'interpréteur Python, de façon à ce que les données globales et les
   arguments de fonction provenant de <function>ma_fonction</function> ne soient
   pas disponibles depuis <function>ma_fonction2</function>. L'exception
   concerne les données du dictionnaire <varname>GD</varname> comme indiqué
   ci-dessus.
  </para>
 </sect1>

 <sect1 id="plpython-do">
  <title>Blocs de code anonymes</title>

  <para>
   PL/Python accepte aussi les blocs de code anonymes appelés avec
   l'instruction <xref linkend="sql-do"/>&nbsp;:

<programlisting>
DO $$
    # Code PL/Python
$$ LANGUAGE plpythonu;
</programlisting>

   Un bloc de code anonyme ne reçoit aucun argument et, quelque soit la valeur
   renvoyée, elle est ignorée. Sinon, ce bloc se comporte exactement comme
   n'importe quelle fonction.
  </para>
 </sect1>

 <sect1 id="plpython-trigger">
  <title>Fonctions de déclencheurs</title>

  <indexterm zone="plpython-trigger">
   <primary>déclencheur</primary>
   <secondary>en PL/Python</secondary>
  </indexterm>

  <para>
   Quand une fonction est utilisée par un trigger, le dictionnaire
   <literal>TD</literal> contient les valeurs relatives au trigger&nbsp;:
   <variablelist>
    <varlistentry>
     <term><literal>TD["event"]</literal></term>
     <listitem>
      <para>
       contient l'événement sous la forme d'une chaîne&nbsp;:
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>
       ou <literal>UNKNOWN</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["when"]</literal></term>
     <listitem>
      <para>
       contient une chaîne valant soit <literal>BEFORE</literal>, soit
       <literal>AFTER</literal> soit <literal>UNKNOWN</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["level"]</literal></term>
     <listitem>
      <para>
       contient une chaîne valant soit <literal>ROW</literal> soit
       <literal>STATEMENT</literal> soit <literal>UNKNOWN</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["new"]</literal></term>
     <term><literal>TD["old"]</literal></term>
     <listitem>
      <para>
       pour un trigger au niveau ligne, ces champs contiennent les lignes
       du trigger, l'ancienne version et la nouvelle version&nbsp;; les deux
       champs ne sont pas forcément disponibles, ceci dépendant de l'événement
       qui a déclenché le trigger
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["name"]</literal></term>
     <listitem>
      <para>
       contient le nom du trigger.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_name"]</literal></term>
     <listitem>
      <para>
       contient le nom de la table sur laquelle le trigger a été déclenché
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_schema"]</literal></term>
     <listitem>
      <para>
       contient le schéma de la table sur laquelle le trigger a été déclenché
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["relid"]</literal></term>
     <listitem>
      <para>
       contient l'OID de la table sur laquelle le trigger a été déclenché
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["args"]</literal></term>
     <listitem>
      <para>
       si la commande <command>CREATE TRIGGER</command> comprend des arguments,
       ils sont disponibles dans les variables allant de
       <literal>TD["args"][0]</literal> à
       <literal>TD["args"][<replaceable>n</replaceable>-1]</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Si <literal>TD["when"]</literal> vaut <literal>BEFORE</literal> et si
   <literal>TD["level"]</literal> vaut <literal>ROW</literal>, vous pourriez
   renvoyer <literal>None</literal> ou <literal>"OK"</literal> à partir de la
   fonction Python pour indiquer que la ligne n'est pas modifiée,
   <literal>"SKIP"</literal> pour annuler l'événement ou <literal>"MODIFY"</literal>
   pour indiquer que vous avez modifié la ligne. Sinon la valeur de retour est
   ignorée.
  </para>
 </sect1>

 <sect1 id="plpython-database">
  <title>Accès à la base de données</title>

  <para>
   Le module du langage PL/Python importe automatiquement un module Python
   appelé <literal>plpy</literal>. Les fonctions et constantes de ce module
   vous sont accessibles dans le code Python via
   <literal>plpy.<replaceable>foo</replaceable></literal>. 
  </para>

  <para>
   Le module <literal>plpy</literal> propose deux fonctions appelées
   <function>execute</function> et <function>prepare</function>. Appeler
   <function>plpy.execute</function> avec une requête sous forme de chaîne
   de caractères et un argument optionnel de limite fait que la requête est
   exécutée et le résultat renvoyé dans un objet résultat. Cet objet émule un
   objet liste ou dictionnaire. L'accès aux résultats se fait par numéro de
   ligne et nom de colonne. Deux méthodes supplémentaires sont
   utilisables&nbsp;: <function>nrows</function> qui renvoit le nombre de
   lignes renvoyées par la requête, et <function>status</function> qui
   correspond à la valeur de retour de <function>SPI_execute()</function>.
   L'objet résultat est modifiable.
  </para>

  <para>
   Par exemple&nbsp;:
<programlisting>
rv = plpy.execute("SELECT * FROM ma_table", 5)
</programlisting>
   renvoit jusqu'à cinq lignes de <literal>ma_table</literal>. Si
   <literal>ma_table</literal> a une colonne <literal>ma_colonne</literal>,
   son contenu peut être récupéré ainsi&nbsp;:
<programlisting>
foo = rv[i]["ma_colonne"]
</programlisting>
  </para>

  <para>
   <indexterm><primary>préparer une requête</primary><secondary>en
   PL/Python</secondary></indexterm>
   la seconde fonction, <function>plpy.prepare</function>, prépare le plan
   d'exécution d'une requête. Il utilise comme arguments une chaîne de
   caractères pour la requête et une liste des types de paramètres si des
   références de paramètres sont indiquées dans la requête. Par exemple&nbsp;:
<programlisting>
plan = plpy.prepare("SELECT nom FROM mes_utilisateurs WHERE prenom = $1", [ "text" ])
</programlisting>
   <literal>text</literal> est le type de la variable que vous devrez passer
   pour <literal>$1</literal>. Après avoir préparé une requête, vous devez
   utiliser la fonction <function>plpy.execute</function> pour
   l'exécuter&nbsp;:
<programlisting>
rv = plpy.execute(plan, [ "nom" ], 5)
</programlisting>
   Le troisième argument, optionnel, est la limite.
  </para>

  <para>
   Les paramètres de requêtes et les champs de résultats sont convertis entre
   PostgreSQL et les types de données Python comme indiqué dans <xref
   linkend="plpython-data"/>. L'exception est que les types composites ne sont
   pas actuellement supportés&nbsp;: ils sont rejetés dans le cas des
   paramètres de requête et convertis en chaînes de caractères quand ils
   apparaissent dans le résultat d'une requête. Pour contourner ce deuxième
   cas, la requête peut être quelque fois écrite de façon à ce que le type
   composite apparaisse comme une ligne de résultat plutôt que comme le champ
   d'une ligne du résultat. Autrement, la chaîne résultante peut être analysée
   manuellement mais cette approche n'est pas recommendée car une version
   future pourrait demander de refaire l'analyse de la chaîne en retour.
  </para>

  <para>
   Quand vous préparez un plan en utilisant le module PL/Python, il est
   automatiquement sauvegardé. Lisez la documentation SPI (<xref
   linkend="spi"/>) pour une description complète. Pour en avoir une
   utilisation réelle via des appels de fonctions, vous avez besoin d'utiliser
   un dictionnaire de stockage persistent
   <literal>SD</literal> ou <literal>GD</literal> (voir
   <xref linkend="plpython-sharing"/>). Par exemple&nbsp;:
<programlisting>
CREATE FUNCTION utilise_plan_sauvegarde() RETURNS trigger AS $$
    if SD.has_key("plan"):
        plan = SD["plan"]
    else:
        plan = plpy.prepare("SELECT 1")
        SD["plan"] = plan
    # reste de la fonction
$$ LANGUAGE plpythonu;
</programlisting>
  </para>
 </sect1>

 <sect1 id="plpython-util">
  <title>Fonctions outils</title>
  <para>
   Le module <literal>plpy</literal> fournit aussi les fonctions
   <literal>plpy.debug(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.log(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.info(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.notice(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.warning(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.error(<replaceable>msg</replaceable>)</literal> et
   <literal>plpy.fatal(<replaceable>msg</replaceable>)</literal>.
   <indexterm><primary>elog</primary><secondary>dans PL/Python</secondary></indexterm>
   <function>plpy.error</function> et <literal>plpy.fatal("msg")</literal>
   lèvent une exception Python qui, si non attrapée, se propage à la requête
   appelante causant l'annulation de la transaction ou sous-transaction en
   cours.  <literal>raise plpy.ERROR(<replaceable>msg</replaceable>)</literal> et
   <literal>raise plpy.FATAL(<replaceable>msg</replaceable>)</literal> sont équivalent à
   appeler, respectivement, <function>plpy.error</function> et
   <function>plpy.fatal</function>. Les autres fonctions génèrent uniquement
   des messages de
   niveaux de priorité différents. Que les messages d'une priorité particulière
   soient reportés au client, écrit dans les journaux du serveur ou les deux,
   cette configuration est contrôlée par les variables <xref
   linkend="guc-log-min-messages"/> et <xref linkend="guc-client-min-messages"/>.
   Voir le <xref linkend="runtime-config"/> pour plus d'informations.
  </para>
 </sect1>

</chapter>
