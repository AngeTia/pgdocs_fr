<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="plpython">
 <title>PL/Python - Langage de procédures Python</title>

 <indexterm zone="plpython"><primary>PL/Python</primary></indexterm>
 <indexterm zone="plpython"><primary>Python</primary></indexterm>

 <para>
  Le langage de procédures <application>PL/Python</application> permet l'écriture
  de fonctions <productname>PostgreSQL</productname> avec le
  <ulink url="http://www.python.org">langage Python</ulink> (but
  see also <xref linkend="plpython-python23"/>).
 </para>

 <para>
  Pour installer PL/Python dans une base de données particulières, utilisez
  <literal>createlang plpythonu <replaceable>nom_base</replaceable></literal>.
 </para>

  <tip>
   <para>
    Si un langage est installé dans <literal>template1</literal>, toutes les bases
    nouvellement créées se verront installées ce langage automatiquement.
   </para>
  </tip>

 <para>
  Depuis <productname>PostgreSQL</productname> 7.4, PL/Python est seulement
  disponible en tant que langage <quote>sans confiance</quote> (ceci signifiant
  qu'il n'offre aucun moyen de restreindre ce que les utilisateurs en font). Il
  a donc été renommé en <literal>plpythonu</literal>. La variante de confiance
  <literal>plpython</literal> pourrait être de nouveau disponible dans le futur, si un
  nouveau mécanisme sécurisé d'exécution est développé dans Python. The
  writer of a function in untrusted PL/Python must take care that the
  function cannot be used to do anything unwanted, since it will be
  able to do anything that could be done by a user logged in as the
  database administrator.  Only superusers can create functions in
  untrusted languages such as <literal>plpythonu</literal>.
 </para>

 <note>
  <para>
   Les utilisateurs des paquets sources doivent activer spécifiquement la
   construction de PL/Python lors des étapes d'installation (référez-vous aux
   instructions d'installation pour plus d'informations). Les utilisateurs de
   paquets binaires pourront trouver PL/Python dans un paquet séparé.
  </para>
 </note>

 <sect1 id="plpython-python23">
  <title>Python 2 vs. Python 3</title>

  <para>
   PL/Python supports both the Python 2 and Python 3 language
   variants.  (The PostgreSQL installation instructions might contain
   more precise information about the exact supported minor versions
   of Python.)  Because the Python 2 and Python 3 language variants
   are incompatible in some important aspects, the following naming
   and transitioning scheme is used by PL/Python to avoid mixing them:

   <itemizedlist>
    <listitem>
     <para>
      The PostgreSQL language named <literal>plpython2u</literal>
      implements PL/Python based on the Python 2 language variant.
     </para>
    </listitem>

    <listitem>
     <para>
      The PostgreSQL language named <literal>plpython3u</literal>
      implements PL/Python based on the Python 3 language variant.
     </para>
    </listitem>

    <listitem>
     <para>
      The language named <literal>plpythonu</literal> implements
      PL/Python based on the default Python language variant, which is
      currently Python 2.  (This default is independent of what any
      local Python installations might consider to be
      their <quote>default</quote>, for example,
      what <filename>/usr/bin/python</filename> might be.)  The
      default will probably be changed to Python 3 in a distant future
      release of PostgreSQL, depending on the progress of the
      migration to Python 3 in the Python community.
     </para>
    </listitem>
   </itemizedlist>

   It depends on the build configuration or the installed packages
   whether PL/Python for Python 2 or Python 3 or both are available.
  </para>

  <para>
   This results in the following usage and migration strategy:

   <itemizedlist>
    <listitem>
     <para>
      Existing users and users who are currently not interested in
      Python 3 use the language name <literal>plpythonu</literal> and
      don't have to change anything for the foreseeable future.  It is
      recommended to gradually <quote>future-proof</quote> the code
      via migration to Python 2.6/2.7 to simplify the eventual
      migration to Python 3.
     </para>

     <para>
      In practice, many PL/Python functions will migrate to Python 3
      with few or no changes.
     </para>
    </listitem>

    <listitem>
     <para>
      Users who know that they have heavily Python 2 dependent code
      and don't plan to ever change it can make use of
      the <literal>plpython2u</literal> language name.  This will
      continue to work into the very distant future, until Python 2
      support might be completely dropped by PostgreSQL.
     </para>
    </listitem>

    <listitem>
     <para>
      Users who want to dive into Python 3 can use
      the <literal>plpython3u</literal> language name, which will keep
      working forever by today's standards.  In the distant future,
      when Python 3 might become the default, they might like to
      remove the <quote>3</quote> for aesthetic reasons.
     </para>
    </listitem>

    <listitem>
     <para>
      Daredevils, who want to build a Python-3-only operating system
      environment, can change the build scripts to
      make <literal>plpythonu</literal> be equivalent
      to <literal>plpython3u</literal>, keeping in mind that this
      would make their installation incompatible with most of the rest
      of the world.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   See also the
   document <ulink url="http://docs.python.org/dev/3.0/whatsnew/3.0.html">What's
   New In Python 3.0</ulink> for more information about porting to
   Python 3.
  </para>
 </sect1>

 <sect1 id="plpython-funcs">
  <title>Fonctions PL/Python</title>

  <para>
   Les fonctions PL/Python sont déclarées via la syntaxe standard <xref
   linkend="sql-createfunction"/>&nbsp;:
<programlisting>CREATE FUNCTION <replaceable>nom_fonction</replaceable> (<replaceable>liste-arguments</replaceable>)
  RETURNS <replaceable>return-type</replaceable>
AS $$
  # corps de la fonction PL/Python
$$ LANGUAGE plpythonu;
</programlisting>
  </para>

  <para>
   Le corps d'une fonction est tout simplement un script Python. Quand la
   fonction est appelée, ses arguments sont passés au script Python comme des
   éléments da la liste <varname>args</varname>&nbsp;; les arguments nommés
   sont en plus passés comme des variables ordinaires. Use of named arguments is
   usually more readable.  Le résultat est renvoyé
   par le code Python de la façon habituelle, avec <literal>return</literal> ou
   <literal>yield</literal> (dans le cas d'une instruction avec un ensemble
   de résultats). If
   you do not provide a return value, Python returns the default
   <symbol>None</symbol>. <application>PL/Python</application> translates
   Python's <symbol>None</symbol> into the SQL null value.
  </para>

  <para>
   Par exemple, une fonction renvoyant le plus grand de deux entiers peut
   être définie ainsi&nbsp;:

<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

   Le code Python donné comme corps de la définition de fonction est transformé
   en fonction Python. Par exemple, le code ci-dessus devient&nbsp;:

<programlisting>def __plpython_procedure_pymax_23456():
  if a &gt; b:
    return a
  return b</programlisting>

   en supposant que 23456 est l'OID affecté à la fonction par
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   The arguments are set as global variables.  Because of the scoping
   rules of Python, this has the subtle consequence that an argument
   variable cannot be reassigned inside the function to the value of
   an expression that involves the variable name itself, unless the
   variable is redeclared as global in the block.  For example, the
   following won't work:
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  x = x.strip()  # error
  return x
$$ LANGUAGE plpythonu;
</programlisting>
   because assigning to <varname>x</varname>
   makes <varname>x</varname> a local variable for the entire block,
   and so the <varname>x</varname> on the right-hand side of the
   assignment refers to a not-yet-assigned local
   variable <varname>x</varname>, not the PL/Python function
   parameter.  Using the <literal>global</literal> statement, this can
   be made to work:
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  global x
  x = x.strip()  # ok now
  return x
$$ LANGUAGE plpythonu;
</programlisting>
   But it is advisable not to rely on this implementation detail of
   PL/Python.  It is better to treat the function parameters as
   read-only.
  </para>
 </sect1>

 <sect1 id="plpython-data">
  <title>Data Values</title>
  <para>
   Generally speaking, the aim of PL/Python is to provide
   a <quote>natural</quote> mapping between the PostgreSQL and the
   Python worlds.  This informs the data mapping rules described
   below.
  </para>

  <sect2>
   <title>Data Type Mapping</title>
   <para>
    Function arguments are converted from their PostgreSQL type to a
    corresponding Python type:
    <itemizedlist>
     <listitem>
      <para>
       PostgreSQL <type>boolean</type> is converted to Python <type>bool</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>smallint</type> and <type>int</type> are
       converted to Python <type>int</type>.
       PostgreSQL <type>bigint</type> is converted
       to <type>long</type> in Python 2 and to <type>int</type> in
       Python 3.
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>real</type>, <type>double</type>,
       and <type>numeric</type> are converted to
       Python <type>float</type>.  Note that for
       the <type>numeric</type> this loses information and can lead to
       incorrect results.  This might be fixed in a future
       release.
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>bytea</type> is converted to
       Python <type>str</type> in Python 2 and to <type>bytes</type>
       in Python 3.  In Python 2, the string should be treated as a
       byte sequence without any character encoding.
      </para>
     </listitem>

     <listitem>
      <para>
       All other data types, including the PostgreSQL character string
       types, are converted to a Python <type>str</type>.  In Python
       2, this string will be in the PostgreSQL server encoding; in
       Python 3, it will be a Unicode string like all strings.
      </para>
     </listitem>

     <listitem>
      <para>
       For nonscalar data types, see below.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Function return values are converted to the declared PostgreSQL
    return data type as follows:
    <itemizedlist>
     <listitem>
      <para>
       When the PostgreSQL return type is <type>boolean</type>, the
       return value will be evaluated for truth according to the
       <emphasis>Python</emphasis> rules.  That is, 0 and empty string
       are false, but notably <literal>'f'</literal> is true.
      </para>
     </listitem>

     <listitem>
      <para>
       When the PostgreSQL return type is <type>bytea</type>, the
       return value will be converted to a string (Python 2) or bytes
       (Python 3) using the respective Python builtins, with the
       result being converted <type>bytea</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       For all other PostgreSQL return types, the returned Python
       value is converted to a string using the Python
       builtin <literal>str</literal>, and the result is passed to the
       input function of the PostgreSQL data type.
      </para>

      <para>
       Strings in Python 2 are required to be in the PostgreSQL server
       encoding when they are passed to PostgreSQL.  Strings that are
       not valid in the current server encoding will raise an error,
       but not all encoding mismatches can be detected, so garbage
       data can still result when this is not done correctly.  Unicode
       strings are converted to the correct encoding automatically, so
       it can be safer and more convenient to use those.  In Python 3,
       all strings are Unicode strings.
      </para>
     </listitem>

     <listitem>
      <para>
       For nonscalar data types, see below.
      </para>
     </listitem>
    </itemizedlist>

    Note that logical mismatches between the declared PostgreSQL
    return type and the Python data type of the actual return object
    are not flagged; the value will be converted in any case.
   </para>

   <tip>
    <para>
     <application>PL/Python</application> functions cannot return
     either type <type>RECORD</type> or <type>SETOF RECORD</type>.  A
     workaround is to write a <application>PL/pgSQL</application>
     function that creates a temporary table, have it call the
     <application>PL/Python</application> function to fill the table,
     and then have the <application>PL/pgSQL</application> function
     return the generic <type>RECORD</type> from the temporary table.
    </para>
   </tip>
  </sect2>

  <sect2>
   <title>Null, None</title>

  <para>
   Si une valeur SQL NULL<indexterm><primary>valeur NULL</primary><secondary
   sortas="PL/Python">PL/Python</secondary></indexterm> est passée à une fonction,
   la valeur de l'argument apparaîtra comme <symbol>None</symbol> au niveau de
   Python. La définition de la fonction ci-dessus renverra la mauvaise réponse
   pour des entrées NULL. Nous pouvons jouer <literal>STRICT</literal> à la
   définition de la fonction pour faire en sorte que
   <productname>PostgreSQL</productname> fasse quelque-chose de plus
   raisonnable&nbsp;: si une valeur NULL est passée, la fonction ne sera pas
   appelée du tout mais renverra juste un résultat NULL automatiquement.
   Sinon, vous pouver vérifier les entrées NULL dans le corps de la
   fonction&nbsp;:

<programlisting>CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if (a is None) or (b is None):
    return None
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

   Comme montré ci-dessus, pour renvoyer une valeur SQL NULL à partir d'une
   fonction PL/Python, renvoyez la valeur <symbol>None</symbol>. Ceci peut
   se faire que la fonction soit stricte ou non.
  </para>

  </sect2>

  <sect2 id="plpython-arrays">
   <title>Arrays, Lists</title>
  <para>
   SQL array values are passed into PL/Python as a Python list.  To
   return an SQL array value out of a PL/Python function, return a
   Python sequence, for example a list or tuple:

<programlisting>
CREATE FUNCTION return_arr()
  RETURNS int[]
AS $$
return (1, 2, 3, 4, 5)
$$ LANGUAGE plpythonu;

SELECT return_arr();
 return_arr  
-------------
 {1,2,3,4,5}
(1 row)
</programlisting>

   Note that in Python, strings are sequences, which can have
   undesirable effects that might be familiar to Python programmers:

<programlisting>
CREATE FUNCTION return_str_arr()
  RETURNS varchar[]
AS $$
return "hello"
$$ LANGUAGE plpythonu;

SELECT return_str_arr();
 return_str_arr
----------------
 {h,e,l,l,o}
(1 row)
</programlisting>
  </para>
  </sect2>

  <sect2>
   <title>Composite Types</title>
  <para>
   Les arguments de type composite sont passés à la fonction via une
   correspondance Python. Les noms d'élément de la correspondance sont les noms
   d'attribut du type composite. Si un attribut a une valeur NULL dans la ligne
   traitée; il a la valeur NULL dans sa correspondance. Voici un exemple&nbsp;:

<programlisting>CREATE TABLE employe (
  nom text,
  salaire integer,
  age integer
);

CREATE FUNCTION trop_paye (e employe)
  RETURNS boolean
AS $$
  if e["salaire"] &gt; 200000:
    return True
  if (e["age"] &lt; 30) and (e["salaire"] &gt; 100000):
    return True
  return False
$$ LANGUAGE plpythonu;
</programlisting>
  </para>

  <para>
   Il existe plusieurs façon de renvoyer une ligne ou des types composites à
   partir d'une fonction Python. Les exemples suivants supposent que nous
   avons&nbsp;:

<programlisting>CREATE TABLE valeur_nommee (
  nom   text,
  valeur  integer
);
</programlisting>
   ou
<programlisting>CREATE TYPE valeur_nommee AS (
  nom   text,
  valeur  integer
);
</programlisting>

   Une valeur composite peut être renvoyé comme&nbsp;:
   <variablelist>
    <varlistentry>
     <term>Un type séquence (ligne ou liste), mais pas
       un ensemble parce que ce n'est pas indexable</term>
     <listitem>
      <para>
       Les objets séquences renvoyés doivent avoir le même nombre d'éléments que
       le type composite a de champs. L'élément d'index 0 est affecté au
       premier champ du type composite, 1 au second et ainsi de suite. Par
       exemple&nbsp;:

<programlisting>CREATE FUNCTION cree_paire (nom text, valeur integer)
  RETURNS valeur_nommee
AS $$
  return [ nom, valeur ]
  # ou autrement, en tant que ligne : return ( nom, valeur )
$$ LANGUAGE plpythonu;
</programlisting>

       Pour renvoyer NULL dans une colonne, insérez <symbol>None</symbol> à la
       position correspondante.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Correspondance (dictionnaire)</term>
     <listitem>
      <para>
       La valeur de chaque colonne du type résultat est récupérée à partir de la
       correspondance avec le nom de colonne comme clé. Exemple&nbsp;:

<programlisting>CREATE FUNCTION cree_paire (nom text, valeur integer)
  RETURNS valeur_nommee
AS $$
  return { "nom": nom, "valeur": valeur }
$$ LANGUAGE plpythonu;
</programlisting>

       Des paires clés/valeurs supplémentaires du dictionnaire sont ignorées.
       Les clés manquantes sont traitées comme des erreurs.
       Pour renvoyer NULL comme une colonne, insérez <symbol>None</symbol>
       avec le nom de la colonne correspondante comme clé.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Objet (tout objet fournissant la méthode <literal>__getattr__</literal>)</term>
     <listitem>
      <para>
       Ceci fonctionne de la même façon qu'une correspondance.
       Exemple&nbsp;:

<programlisting>CREATE FUNCTION cree_paire (nom text, valeur integer)
  RETURNS valeur_nommee
AS $$
  class valeur_nommee:
    def __init__ (self, n, v):
      self.nom = n
      self.valeur = v
  return valeur_nommee(nom, valeur)

  # ou simplement
  class nv: pass
  nv.nom = nom
  nv.valeur = valeur
  return nv
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  </sect2>

  <sect2>
   <title>Set-Returning Functions</title>

  <para>
   Une fonction <application>PL/Python</application> peut aussi renvoyer des
   ensembles scalaires ou des types composites. Il existe plusieurs façon de
   faire ceci parce que l'objet renvoyé est transformé en interne en itérateur.
   Les exemples suivants supposent que nous avons le type composite&nbsp;:

<programlisting>CREATE TYPE greeting AS (
  how text,
  who text
);
</programlisting>
   
   Un résultat ensemble peut être renvoyé à partir de&nbsp;:
   <variablelist>
    <varlistentry>
     <term>Un type séquence (ligne, liste, ensemble)</term>
     <listitem>
      <para>
<programlisting>CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  # renvoie la ligne contenant les listes en tant que types composites
  # toutes les autres combinaisons fonctionnent aussi
  return ( [ how, "World" ], [ how, "PostgreSQL" ], [ how, "PL/Python" ] )
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>L'itérateur (tout objet fournissant les méthodes <symbol>__iter__</symbol>
      et <symbol>next</symbol>)</term>
     <listitem>
      <para>
<programlisting>CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  class producer:
    def __init__ (self, how, who):
      self.how = how
      self.who = who
      self.ndx = -1

    def __iter__ (self):
      return self

    def next (self):
      self.ndx += 1
      if self.ndx == len(self.who):
        raise StopIteration
      return ( self.how, self.who[self.ndx] )

  return producer(how, [ "World", "PostgreSQL", "PL/Python" ])
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Le générateur (<literal>yield</literal>)</term>
     <listitem>
      <para>
<programlisting>CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  for who in [ "World", "PostgreSQL", "PL/Python" ]:
    yield ( how, who )
$$ LANGUAGE plpythonu;
</programlisting>

       <warning>
        <para>
         À cause du
         <ulink url="http://bugs.python.org/issue1483133">bogue #1483133</ulink> de Python,
         certaines versions de débogage de Python 2.4
         (configuré et compilé avec l'option <literal>--with-pydebug</literal>)
         sont connues pour arrêter brutalement le serveur
	 <productname>PostgreSQL</productname> lors de l'utilisation d'un
	 itérateur pour renvoyer un résultat ensemble. Les versions non corrigées de
         Fedora 4 contiennent ce bogue. Cela n'arrive pas dans les versions de
         production de Python et sur les versions corrigées de Fedora 4.
        </para>
       </warning>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  </sect2>
 </sect1>

 <sect1 id="plpython-sharing">
  <title>Sharing Data</title>
  
  <para>
   Le dictionnaire global <varname>SD</varname> est disponible pour stocker des
   données entres les appels de fonctions. Cette variable est une donnée
   statique privée. Le dictionnaire global <varname>GD</varname> est une donnée
   publique disponible pour toutes les fonctions Python à l'intérieur d'une
   session. À utiliser avec précaution.<indexterm><primary>données
   globales</primary><secondary>en PL/Python</secondary></indexterm>
  </para>

  <para>
   Chaque fonction obtient son propre environnement d'exécution dans
   l'interpréteur Python, de façon à ce que les données globales et les
   arguments de fonction provenant de <function>ma_fonction</function> ne soient
   pas disponibles depuis <function>ma_fonction2</function>. L'exception
   concerne les données du dictionnaire <varname>GD</varname> comme indiqué
   ci-dessus.
  </para>
 </sect1>

 <sect1 id="plpython-do">
  <title>Anonymous Code Blocks</title>

  <para>
   PL/Python also supports anonymous code blocks called with the
   <xref linkend="sql-do"/> statement:

<programlisting>
DO $$
    # PL/Python code
$$ LANGUAGE plpythonu;
</programlisting>

   An anonymous code block receives no arguments, and whatever value it
   might return is discarded.  Otherwise it behaves just like a function.
  </para>
 </sect1>

 <sect1 id="plpython-trigger">
  <title>Fonctions de déclencheurs</title>

  <indexterm zone="plpython-trigger">
   <primary>déclencheur</primary>
   <secondary>en PL/Python</secondary>
  </indexterm>

  <para>
   When a function is used as a trigger, the dictionary
   <literal>TD</literal> contains trigger-related values:
   <variablelist>
    <varlistentry>
     <term><literal>TD["event"]</literal></term>
     <listitem>
      <para>
       contains the event as a string:
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
       or <literal>UNKNOWN</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["when"]</literal></term>
     <listitem>
      <para>
       contains one of <literal>BEFORE</literal>, <literal>AFTER</literal>,
       or <literal>UNKNOWN</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["level"]</literal></term>
     <listitem>
      <para>
       contains one of <literal>ROW</literal>,
       <literal>STATEMENT</literal>, or <literal>UNKNOWN</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["new"]</literal></term>
     <term><literal>TD["old"]</literal></term>
     <listitem>
      <para>
       For a row-level trigger, one or both of these fields contain
       the respective trigger rows, depending on the trigger event.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["name"]</literal></term>
     <listitem>
      <para>
       contains the trigger name.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_name"]</literal></term>
     <listitem>
      <para>
       contains the name of the table on which the trigger occurred.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_schema"]</literal></term>
     <listitem>
      <para>
       contains the schema of the table on which the trigger occurred.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["relid"]</literal></term>
     <listitem>
      <para>
       contains the OID of the table on which the trigger occurred.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["args"]</literal></term>
     <listitem>
      <para>
       If the <command>CREATE TRIGGER</command> command
       included arguments, they are available in <literal>TD["args"][0]</literal> to
       <literal>TD["args"][<replaceable>n</replaceable>-1]</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Si <literal>TD["when"]</literal> vaut <literal>BEFORE</literal> et si
   <literal>TD["level"]</literal> vaut <literal>ROW</literal>, vous pourriez
   renvoyer <literal>None</literal> ou <literal>"OK"</literal> à partir de la
   fonction Python pour indiquer que la ligne n'est pas modifiée,
   <literal>"SKIP"</literal> pour annuler l'événement ou <literal>"MODIFY"</literal>
   pour indiquer que vous avez modifié la ligne. Sinon la valeur de retour est
   ignorée.
  </para>
 </sect1>

 <sect1 id="plpython-database">
  <title>Accès à la base de données</title>

  <para>
   Le module du langage PL/Python importe automatiquement un module Python
   appelé <literal>plpy</literal>. Les fonctions et constantes de ce module
   vous sont accessibles dans le code Python via
   <literal>plpy.<replaceable>foo</replaceable></literal>. 
  </para>

  <para>
   The <literal>plpy</literal> module provides two
   functions called <function>execute</function> and
   <function>prepare</function>.  Calling
   <function>plpy.execute</function> with a query string and an
   optional limit argument causes that query to be run and the result
   to be returned in a result object.  The result object emulates a
   list or dictionary object.  The result object can be accessed by
   row number and column name.  It has these additional methods:
   <function>nrows</function> which returns the number of rows
   returned by the query, and <function>status</function> which is the
   <function>SPI_execute()</function> return value.  The result object
   can be modified.
  </para>

  <para>
   For example:
<programlisting>
rv = plpy.execute("SELECT * FROM my_table", 5)
</programlisting>
   returns up to 5 rows from <literal>my_table</literal>.  If
   <literal>my_table</literal> has a column
   <literal>my_column</literal>, it would be accessed as:
<programlisting>
foo = rv[i]["my_column"]
</programlisting>
  </para>

  <para>
   <indexterm><primary>preparing a query</primary><secondary>in PL/Python</secondary></indexterm>
   The second function, <function>plpy.prepare</function>, prepares
   the execution plan for a query.  It is called with a query string
   and a list of parameter types, if you have parameter references in
   the query.  For example:
<programlisting>
plan = plpy.prepare("SELECT last_name FROM my_users WHERE first_name = $1", [ "text" ])
</programlisting>
   <literal>text</literal> is the type of the variable you will be
   passing for <literal>$1</literal>.  After preparing a statement, you
   use the function <function>plpy.execute</function> to run it:
<programlisting>
rv = plpy.execute(plan, [ "name" ], 5)
</programlisting>
   The third argument is the limit and is optional.
  </para>

  <para>
   Query parameters and result row fields are converted between
   PostgreSQL and Python data types as described
   in <xref linkend="plpython-data"/>.  The exception is that composite
   types are currently not supported: They will be rejected as query
   parameters and are converted to strings when appearing in a query
   result.  As a workaround for the latter problem, the query can
   sometimes be rewritten so that the composite type result appears as
   a result row rather than as a field of the result row.
   Alternatively, the resulting string could be parsed apart by hand,
   but this approach is not recommended because it is not
   future-proof.
  </para>

  <para>
   When you prepare a plan using the PL/Python module it is
   automatically saved.  Read the SPI documentation (<xref
   linkend="spi"/>) for a description of what this means.
   In order to make effective use of this across function calls
   one needs to use one of the persistent storage dictionaries
   <literal>SD</literal> or <literal>GD</literal> (see
   <xref linkend="plpython-sharing"/>). For example:
<programlisting>
CREATE FUNCTION usesavedplan() RETURNS trigger AS $$
    if SD.has_key("plan"):
        plan = SD["plan"]
    else:
        plan = plpy.prepare("SELECT 1")
        SD["plan"] = plan
    # rest of function
$$ LANGUAGE plpythonu;
</programlisting>
  </para>
 </sect1>

 <sect1 id="plpython-util">
  <title>Utility Functions</title>
  <para>
   The <literal>plpy</literal> module also provides  les fonctions
   <literal>plpy.debug(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.log(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.info(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.notice(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.warning(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.error(<replaceable>msg</replaceable>)</literal> et
   <literal>plpy.fatal(<replaceable>msg</replaceable>)</literal>.
   <indexterm><primary>elog</primary><secondary>dans PL/Python</secondary></indexterm>
   <function>plpy.error</function> et <literal>plpy.fatal("msg")</literal>
   lèvent une exception Python qui, si non attrapée, se propage à la requête
   appelante causant l'annulation de la transaction ou sous-transaction en
   cours.  <literal>raise plpy.ERROR(<replaceable>msg</replaceable>)</literal> et
   <literal>raise plpy.FATAL(<replaceable>msg</replaceable>)</literal> sont équivalent à
   appeler, respectivement, <function>plpy.error</function> et
   <function>plpy.fatal</function>. Les autres fonctions génèrent uniquement
   des messages de
   niveaux de priorité différents. Que les messages d'une priorité particulière
   soient reportés au client, écrit dans les journaux du serveur ou les deux,
   cette configuration est contrôlée par les variables <xref
   linkend="guc-log-min-messages"/> et <xref linkend="guc-client-min-messages"/>.
   Voir le <xref linkend="runtime-config"/> pour plus d'informations.
  </para>
 </sect1>

</chapter>
