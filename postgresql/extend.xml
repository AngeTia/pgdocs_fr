<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

 <chapter id="extend">
  <title>Étendre <acronym>SQL</acronym></title>

   <indexterm zone="extend">
    <primary>Extension de SQL</primary>
   </indexterm>

  <para>
   Les sections qui suivent présentent les possibilités d'étendre le langage
   SQL de requêtage de <productname>PostgreSQL</productname> par l'ajout&nbsp;:
  <itemizedlist spacing="compact" mark="bullet">
    <listitem>
     <para>
      de fonctions (<xref linkend="xfunc"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
      d'agrégats (<xref linkend="xaggr"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
      de types de données (<xref linkend="xtypes"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
      d'opérateurs (<xref linkend="xoper"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
     de classes d'opérateurs pour les index (<xref linkend="xindex"/>).
     </para>
    </listitem>
    <listitem>
     <para>
      packages of related objects (starting in <xref linkend="extend-extensions"/>)
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <sect1 id="extend-how">
   <title>L'extensibilité</title>

   <para>
    <productname>PostgreSQL</productname> est extensible parce qu'il opère
    grâce à un système de catalogues. Quiconque est familier des systèmes de
    bases de données relationnelles standard sait que les informations
    concernant les bases, les tables, les colonnes, etc. y sont stockées dans ce
    qu'on nomme communément des catalogues systèmes (certains systèmes appellent
    cela le dictionnaire de données). Pour l'utilisateur, les catalogues
    ressemblent à des tables ordinaires, mais le <acronym>SGBD</acronym>
    y enregistre ses registres <!-- bookkeeping --> internes. À la différence
    des autres systèmes, <productname>PostgreSQL</productname> enregistre
    beaucoup d'informations dans ses catalogues&nbsp;: non seulement
    l'information concernant les tables et les colonnes, mais aussi
    l'information concernant les types de données, les fonctions, les méthodes
    d'accès, etc.
   </para>
   <para>
    Ces tables peuvent être modifiées par l'utilisateur. Qui plus est, 
    puisque <productname>PostgreSQL</productname> fonde ses opérations sur ces
    tables, il peut être étendu par les utilisateurs. En comparaison, les systèmes de bases de 
    données conventionnels ne peuvent être étendus qu'en modifiant les
    procédures dans le code source ou en installant des modules spécifiquement
    écrits par le vendeur de <acronym>SGBD</acronym>.
  </para>
  
  <para>
   De plus, le serveur <productname>PostgreSQL</productname> peut
   incorporer du code utilisateur par chargement dynamique. C'est-à-dire
   que l'utilisateur peut indiquer un fichier de code objet (par exemple une
   bibliothèque partagée) qui code un nouveau type ou une nouvelle fonction
   et <productname>PostgreSQL</productname> le charge au besoin.
   Il est encore plus facile d'ajouter au serveur du code écrit en
   <acronym>SQL</acronym>. La possibilité de modifier son fonctionnement
   <quote>à la volée</quote> fait de <productname>PostgreSQL</productname>
   un outil unique pour le prototypage rapide de nouvelles applications et
   de structures de stockage.
  </para>
  
 </sect1>
   
   <sect1 id="extend-type-system"> 
     <title>Le système des types de <productname>PostgreSQL</productname></title>

   <indexterm zone="extend-type-system">
    <primary>type de base</primary>
   </indexterm>

   <indexterm zone="extend-type-system">
    <primary>type de données</primary>
    <secondary>base</secondary>
   </indexterm>

   <indexterm zone="extend-type-system">
    <primary>type composé</primary>
   </indexterm>

   <indexterm zone="extend-type-system">
    <primary>type de données</primary>
    <secondary>composé</secondary>
   </indexterm>

   <para>
    Les types de données de <productname>PostgreSQL</productname> sont répartis en types de base, 
    types composites, domaines et pseudo-types.
   </para>

  <sect2>
   <title>Les types de base</title>

   <para>
    Les types de base sont ceux qui, comme <type>int4</type>, sont implantés
    sous le niveau du langage <acronym>SQL</acronym> (typiquement dans un
    langage de bas niveau comme le C). Ils correspondent généralement à ce que
    l'on appelle les types de données abstraits.  
    <productname>PostgreSQL</productname> ne peut opérer sur de tels types
    qu'au moyen de fonctions utilisateur et n'en comprend le fonctionnement que
    dans la limite de la description qu'en a fait l'utilisateur. Les types
    de base sont divisés en types scalaires et types tableaux. Pour chaque type
    scalaire, un type tableau  est automatiquement créé destiné à
    contenir des tableaux de taille variable de ce type scalaire.
   </para>
   </sect2>

  <sect2>
   <title>Les types composites</title>

   <para>
    Les types composites, ou types lignes, sont créés chaque fois qu'un
    utilisateur crée une table. Il est égalment possible de définir un type
    composite autonome sans table associée. Un type composite n'est
    qu'une simple liste de types de base avec des noms de champs associés. Une
    valeur de type composite est une ligne ou un enregistrement de valeurs de
    champ. L'utilisateur peut accéder à ces champs à partir de requêtes
    <acronym>SQL</acronym>.  La <xref linkend="rowtypes"/>
    fournit de plus amples informations sur ces types.
   </para>
  </sect2>

  <sect2>
   <title>Les domaines</title>

   <para>
    Un domaine est fondé sur un type de base particulier. Il est, dans de
    nombreux cas, interchangeable avec ce type. Mais un domaine peut également
    posséder des contraintes qui restreignent ses valeurs à un sous-ensemble des
    valeurs autorisées pour le type de base.
   </para>

    <para>
     Les domaines peuvent être créés à l'aide de la commande
     <acronym>SQL</acronym> <xref linkend="sql-createdomain"/>.
     Leurs création et utilisation n'est pas l'objet de ce chapitre.
    </para>
   </sect2>

   <sect2>
    <title>Pseudo-types</title>

   <para>   
    Il existe quelques <quote>pseudo-types</quote> pour des besoins
    particuliers. Les pseudo-types ne peuvent pas apparaître comme champs de
    table ou comme attributs de types composites, mais ils peuvent être
    utilisés pour déclarer les types des arguments et des résultats de
    fonctions. Dans le système de typage, ils fournissent un mécanisme
    d'identification des classes spéciales de fonctions. La
    <xref linkend="datatype-pseudotypes-table"/> donne la liste des
    pseudo-types qui existent.   
   </para>

   </sect2>

   <sect2 id="extend-types-polymorphic">
    <title>Types et fonctions polymorphes</title>

   <indexterm zone="extend-types-polymorphic">
    <primary>type polymorphe</primary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>fonction polymorphe</primary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>type</primary>
    <secondary>polymorphe</secondary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>fonction</primary>
    <secondary>polymorphe</secondary>
   </indexterm>

   <para>
    Quatre pseudo-types sont particulièrement intéressants&nbsp;:
    <type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type> et
    <type>anyenum</type>, collectivement appelés <firstterm>types
    polymorphes</firstterm>.
    Toute fonction déclarée utiliser ces types est dite <firstterm>fonction
    polymorphe</firstterm>. Une fonction polymorphe peut opérer sur de nombreux
    types de données différents, les types de données spécifiques étant
    déterminés par les types des données réellement passés lors d'un appel
    particulier de la fonction.
   </para>

   <para>
    Les arguments et résultats polymorphes sont liés entre eux et
    sont résolus dans un type de données spécifique quand une requête faisant
    appel à une fonction polymorphe est analysée. Chaque occurrence (argument
    ou valeur de retour) déclarée comme <type>anyelement</type>
    peut prendre n'importe quel type réel de données mais, lors d'un
    appel de fonction donné, elles doivent toutes avoir le
    <emphasis>même</emphasis> type réel. Chaque occurrence déclarée comme
    <type>anyarray</type> peut prendre n'importe quel type de données tableau
    mais, de la même façon, elles doivent toutes être du
    <emphasis>même</emphasis> type. Si des occurrences sont déclarées comme
    <type>anyarray</type> et d'autres comme <type>anyelement</type>, le type
    réel de tableau des occurrences <type>anyarray</type> doit être un tableau
    dont les éléments sont du même type que ceux apparaissant dans les
    occurrences de type <type>anyelement</type>.
    <type>anynonarray</type> est traité de la même façon que
    <type>anyelement</type> mais ajoute une contrainte supplémentaire. Le type
    réel ne doit pas être un tableau. <type>anyenum</type> est traité de la même
    façon que <type>anyelement</type> mais ajoute une contrainte supplémentaire.
    Le type doit être un type enuméré.
   </para>

   <para>
    Ainsi, quand plusieurs occurrences d'argument sont déclarées avec un type
    polymorphe, seules certaines combinaisons de
    types réels d'argument sont autorisées. Par exemple, une fonction déclarée
    comme <literal>foo(anyelement, anyelement)</literal> peut prendre comme
    arguments n'importe quelles valeurs à condition qu'elles soient du même
    type de données.
   </para>

   <para>
    Quand la valeur renvoyée par une fonction est déclarée de type polymorphe,
    il doit exister au moins une occurrence d'argument également polymorphe, et
    le type réel de donnée passé comme argument détermine le type réel de
    résultat renvoyé lors de cet appel à la fonction. Par exemple, s'il
    n'existe pas déjà un mécanisme d'indexation d'éléments de
    tableau, on peut définir une fonction qui code ce mécanisme&nbsp;:
    <literal>indice(anyarray, integer) returns anyelement</literal>. La
    déclaration de fonction contraint le premier argument réel à être de type
    tableau et permet à l'analyseur d'inférer le type correct de résultat à
    partir du type réel du premier argument. Une fonction déclarée de cette
    façon <literal>f(anyarray) returns anyenum</literal> n'accepte que des
    tableaux contenant des valeurs de type enum.
    </para>

    <para>
     <type>anynonarray</type> et <type>anyenum</type> ne représentent
     pas des variables de type séparé&nbsp;; elles sont du même type que
     <type>anyelement</type>, mais avec une contrainte supplémentaire. Par
     exemple, déclarer une fonction <literal>f(anyelement, anyenum)</literal>
     est équivalent à la déclarer <literal>f(anyenum, anyenum)</literal>&nbsp;:
     les deux arguments réels doivent être du même type enum.
    </para>

    <para>
     Une fonction variadic (c'est-à-dire une fonction acceptant un nombre
     variable d'arguments, comme dans <xref
     linkend="xfunc-sql-variadic-functions"/>) peut être polymorphique&nbsp;:
     cela se fait en déclarant son dernier paramètre <literal>VARIADIC</literal>
     <type>anyarray</type>. Pour s'assurer de la correspondance des arguments
     et déterminer le type de la valeur en retour, ce type de fonction se
     comporte de la même façon que si vous aviez écrit le nombre approprié de
     paramètres <type>anynonarray</type>.
    </para>
  </sect2>
 </sect1>

  &xfunc;
  &xaggr;
  &xtypes;
  &xoper;
  &xindex;

  <sect1 id="extend-extensions">
   <title>Packaging Related Objects into an Extension</title>

   <indexterm zone="extend-extensions">
    <primary>extension</primary>
    </indexterm>
 
    <para>
    A useful extension to <productname>PostgreSQL</productname> typically includes
    multiple SQL objects; for example, a new datatype will require new
    functions, new operators, and probably new index operator classes.
    It is helpful to collect all these objects into a single package
    to simplify database management.  <productname>PostgreSQL</productname> calls
    such a package an <firstterm>extension</firstterm>.  To define an extension,
    you need at least a <firstterm>script file</firstterm> that contains the
    <acronym>SQL</acronym> commands to create the extension's objects, and a
    <firstterm>control file</firstterm> that specifies a few basic properties
    of the extension itself.  If the extension includes C code, there
    will typically also be a shared library file into which the C code
    has been built.  Once you have these files, a simple
    <xref linkend="sql-createextension"/> command loads the objects into
    your database.
   </para>

   <para>
    The main advantage of using an extension, rather than just running the
    <acronym>SQL</acronym> script to load a bunch of <quote>loose</quote> objects
    into your database, is that <productname>PostgreSQL</productname> will then
    understand that the objects of the extension go together.  You can
    drop all the objects with a single <xref linkend="sql-dropextension"/>
    command (no need to maintain a separate <quote>uninstall</quote> script).
    Even more useful, <application>pg_dump</application> knows that it should not
    dump the individual member objects of the extension &mdash; it will
    just include a <command>CREATE EXTENSION</command> command in dumps, instead.
    This vastly simplifies migration to a new version of the extension
    that might contain more or different objects than the old version.
    Note however that you must have the extension's control, script, and
    other files available when loading such a dump into a new database.
   </para>

   <para>
    <productname>PostgreSQL</productname> will not let you drop an individual object
    contained in an extension, except by dropping the whole extension.
    Also, while you can change the definition of an extension member object
    (for example, via <command>CREATE OR REPLACE FUNCTION</command> for a
    function), bear in mind that the modified definition will not be dumped
    by <application>pg_dump</application>.  Such a change is usually only sensible if
    you concurrently make the same change in the extension's script file.
    (But there are special provisions for tables containing configuration
    data; see below.)
   </para>

   <para>
    The extension mechanism also has provisions for packaging modification
    scripts that adjust the definitions of the SQL objects contained in an
    extension.  For example, if version 1.1 of an extension adds one function
    and changes the body of another function compared to 1.0, the extension
    author can provide an <firstterm>update script</firstterm> that makes just those
    two changes.  The <command>ALTER EXTENSION UPDATE</command> command can then
    be used to apply these changes and track which version of the extension
    is actually installed in a given database.
   </para>

   <para>
    The kinds of SQL objects that can be members of an extension are shown in
    the description of <xref linkend="sql-alterextension"/>.  Notably, objects
    that are database-cluster-wide, such as databases, roles, and tablespaces,
    cannot be extension members since an extension is only known within one
    database.  (Although an extension script is not prohibited from creating
    such objects, if it does so they will not be tracked as part of the
    extension.)  Also notice that while a table can be a member of an
    extension, its subsidiary objects such as indexes are not directly
    considered members of the extension.
   </para>

   <sect2 id="extension">
    <title>Extension Files</title>

   <indexterm>
    <primary>control file</primary>
   </indexterm>

    <para>
     The <xref linkend="sql-createextension"/> command relies on a control
     file for each extension, which must be named the same as the extension
     with a suffix of <literal>.control</literal>, and must be placed in the
     installation's <literal>SHAREDIR/extension</literal> directory.  There
     must also be at least one <acronym>SQL</acronym> script file, which follows the
     naming pattern
     <literal><replaceable>extension</replaceable>--<replaceable>version</replaceable>.sql</literal>
     (for example, <literal>foo--1.0.sql</literal> for version <literal>1.0</literal> of
     extension <literal>foo</literal>).  By default, the script file(s) are also
     placed in the <literal>SHAREDIR/extension</literal> directory; but the
     control file can specify a different directory for the script file(s).
    </para>

    <para>
     The file format for an extension control file is the same as for the
     <filename>postgresql.conf</filename> file, namely a list of
     <replaceable>parameter_name</replaceable> <literal>=</literal> <replaceable>value</replaceable>
     assignments, one per line.  Blank lines and comments introduced by
     <literal>#</literal> are allowed.  Be sure to quote any value that is not
     a single word or number.
    </para>

    <para>
     A control file can set the following parameters:
    </para>

    <variablelist>
     <varlistentry>
      <term><varname>directory</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        The directory containing the extension's <acronym>SQL</acronym> script
        file(s).  Unless an absolute path is given, the name is relative to
        the installation's <literal>SHAREDIR</literal> directory.  The
        default behavior is equivalent to specifying
        <literal>directory = 'extension'</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>default_version</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        The default version of the extension (the one that will be installed
        if no version is specified in <command>CREATE EXTENSION</command>).  Although
        this can be omitted, that will result in <command>CREATE EXTENSION</command>
        failing if no <literal>VERSION</literal> option appears, so you generally
        don't want to do that.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>comment</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        A comment (any string) about the extension.  Alternatively,
        the comment can be set by means of the <xref linkend="sql-comment"/>
        command in the script file.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>encoding</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        The character set encoding used by the script file(s).  This should
        be specified if the script files contain any non-ASCII characters.
        Otherwise the files will be assumed to be in the database encoding.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>module_pathname</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        The value of this parameter will be substituted for each occurrence
        of <literal>MODULE_PATHNAME</literal> in the script file(s).  If it is not
        set, no substitution is made.  Typically, this is set to
        <literal>$libdir/<replaceable>shared_library_name</replaceable></literal> and
        then <literal>MODULE_PATHNAME</literal> is used in <command>CREATE
        FUNCTION</command> commands for C-language functions, so that the script
        files do not need to hard-wire the name of the shared library.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>requires</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        A list of names of extensions that this extension depends on,
        for example <literal>requires = 'foo, bar'</literal>.  Those
        extensions must be installed before this one can be installed.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>superuser</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        If this parameter is <literal>true</literal> (which is the default),
        only superusers can create the extension or update it to a new
        version.  If it is set to <literal>false</literal>, just the privileges
        required to execute the commands in the installation or update script
        are required.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>relocatable</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        An extension is <firstterm>relocatable</firstterm> if it is possible to move
        its contained objects into a different schema after initial creation
        of the extension.  The default is <literal>false</literal>, i.e. the
        extension is not relocatable.
        See below for more information.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>schema</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        This parameter can only be set for non-relocatable extensions.
        It forces the extension to be loaded into exactly the named schema
        and not any other.  See below for more information.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    <para>
     In addition to the primary control file
     <literal><replaceable>extension</replaceable>.control</literal>,
     an extension can have secondary control files named in the style
     <literal><replaceable>extension</replaceable>--<replaceable>version</replaceable>.control</literal>.
     If supplied, these must be located in the script file directory.
     Secondary control files follow the same format as the primary control
     file.  Any parameters set in a secondary control file override the
     primary control file when installing or updating to that version of
     the extension.  However, the parameters <varname>directory</varname> and
     <varname>default_version</varname> cannot be set in a secondary control file.
    </para>

    <para>
     An extension's <acronym>SQL</acronym> script files can contain any SQL commands,
     except for transaction control commands (<command>BEGIN</command>,
     <command>COMMIT</command>, etc) and commands that cannot be executed inside a
     transaction block (such as <command>VACUUM</command>).  This is because the
     script files are implicitly executed within a transaction block.
    </para>

    <para>
     While the script files can contain any characters allowed by the specified
     encoding, control files should contain only plain ASCII, because there
     is no way for <productname>PostgreSQL</productname> to know what encoding a
     control file is in.  In practice this is only an issue if you want to
     use non-ASCII characters in the extension's comment.  Recommended
     practice in that case is to not use the control file <varname>comment</varname>
     parameter, but instead use <command>COMMENT ON EXTENSION</command>
     within a script file to set the comment.
    </para>

   </sect2>

   <sect2>
    <title>Extension Relocatability</title>

    <para>
     Users often wish to load the objects contained in an extension into a
     different schema than the extension's author had in mind.  There are
     three supported levels of relocatability:
    </para>
 
     <itemizedlist>
      <listitem>
       <para>
       A fully relocatable extension can be moved into another schema
       at any time, even after it's been loaded into a database.
       This is done with the <command>ALTER EXTENSION SET SCHEMA</command>
       command, which automatically renames all the member objects into
       the new schema.  Normally, this is only possible if the extension
       contains no internal assumptions about what schema any of its
       objects are in.  Also, the extension's objects must all be in one
       schema to begin with (ignoring objects that do not belong to any
       schema, such as procedural languages).  Mark a fully relocatable
       extension by setting <literal>relocatable = true</literal> in its control
       file.
       </para>
      </listitem>

      <listitem>
       <para>
       An extension might be relocatable during installation but not
       afterwards.  This is typically the case if the extension's script
       file needs to reference the target schema explicitly, for example
       in setting <literal>search_path</literal> properties for SQL functions.
       For such an extension, set <literal>relocatable = false</literal> in its
       control file, and use <literal>@extschema@</literal> to refer to the target
       schema in the script file.  All occurrences of this string will be
       replaced by the actual target schema's name before the script is
       executed.  The user can set the target schema using the
       <literal>SCHEMA</literal> option of <command>CREATE EXTENSION</command>.
       </para>
      </listitem>

      <listitem>
       <para>
       If the extension does not support relocation at all, set
       <literal>relocatable = false</literal> in its control file, and also set
       <literal>schema</literal> to the name of the intended target schema.  This
       will prevent use of the <literal>SCHEMA</literal> option of <command>CREATE
       EXTENSION</command>, unless it specifies the same schema named in the control
       file.  This choice is typically necessary if the extension contains
       internal assumptions about schema names that can't be replaced by
       uses of <literal>@extschema@</literal>.  The <literal>@extschema@</literal>
       substitution mechanism is available in this case too, although it is
       of limited use since the schema name is determined by the control file.
       </para>
      </listitem>
     </itemizedlist>

    <para>
     In all cases, the script file will be executed with
     <xref linkend="guc-search-path"/> initially set to point to the target
     schema; that is, <command>CREATE EXTENSION</command> does the equivalent of
     this:
<programlisting>
SET LOCAL search_path TO @extschema@;
</programlisting>
     This allows the objects created by the script file to go into the target
     schema.  The script file can change <varname>search_path</varname> if it wishes,
     but that is generally undesirable.  <varname>search_path</varname> is restored
     to its previous setting upon completion of <command>CREATE EXTENSION</command>.
    </para>

    <para>
     The target schema is determined by the <varname>schema</varname> parameter in
     the control file if that is given, otherwise by the <literal>SCHEMA</literal>
     option of <command>CREATE EXTENSION</command> if that is given, otherwise the
     current default object creation schema (the first one in the caller's
     <varname>search_path</varname>).  When the control file <varname>schema</varname>
     parameter is used, the target schema will be created if it doesn't
     already exist, but in the other two cases it must already exist.
    </para>

    <para>
     If any prerequisite extensions are listed in <varname>requires</varname>
     in the control file, their target schemas are appended to the initial
     setting of <varname>search_path</varname>.  This allows their objects to be
     visible to the new extension's script file.
    </para>

    <para>
     Although a non-relocatable extension can contain objects spread across
     multiple schemas, it is usually desirable to place all the objects meant
     for external use into a single schema, which is considered the extension's
     target schema.  Such an arrangement works conveniently with the default
     setting of <varname>search_path</varname> during creation of dependent
     extensions.
    </para>
   </sect2>

   <sect2>
    <title>Extension Configuration Tables</title>

    <para>
     Some extensions include configuration tables, which contain data that
     might be added or changed by the user after installation of the
     extension.  Ordinarily, if a table is part of an extension, neither
     the table's definition nor its content will be dumped by
     <application>pg_dump</application>.  But that behavior is undesirable for a
     configuration table; any data changes made by the user need to be
     included in dumps, or the extension will behave differently after a dump
     and reload.
    </para>

    <para>
     To solve this problem, an extension's script file can mark a table
     it has created as a configuration table, which will cause
     <application>pg_dump</application> to include the table's contents (not its
     definition) in dumps.  To do that, call the function
     <function>pg_extension_config_dump(regclass, text)</function> after creating the
     table, for example
<programlisting>
CREATE TABLE my_config (key text, value text);

SELECT pg_catalog.pg_extension_config_dump('my_config', '');
</programlisting>
     Any number of tables can be marked this way.
    </para>

    <para>
     When the second argument of <function>pg_extension_config_dump</function> is
     an empty string, the entire contents of the table are dumped by
     <application>pg_dump</application>.  This is usually only correct if the table
     is initially empty as created by the extension script.  If there is
     a mixture of initial data and user-provided data in the table,
     the second argument of <function>pg_extension_config_dump</function> provides
     a <literal>WHERE</literal> condition that selects the data to be dumped.
     For example, you might do
<programlisting>
CREATE TABLE my_config (key text, value text, standard_entry boolean);

SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');
</programlisting>
     and then make sure that <structfield>standard_entry</structfield> is true only
     in the rows created by the extension's script.
    </para>

    <para>
     More complicated situations, such as initially-provided rows that might
     be modified by users, can be handled by creating triggers on the
     configuration table to ensure that modified rows are marked correctly.
    </para>
   </sect2>

   <sect2>
    <title>Extension Updates</title>

    <para>
     One advantage of the extension mechanism is that it provides convenient
     ways to manage updates to the SQL commands that define an extension's
     objects.  This is done by associating a version name or number with
     each released version of the extension's installation script.
     In addition, if you want users to be able to update their databases
     dynamically from one version to the next, you should provide
     <firstterm>update scripts</firstterm> that make the necessary changes to go from
     one version to the next.  Update scripts have names following the pattern
     <literal><replaceable>extension</replaceable>--<replaceable>oldversion</replaceable>--<replaceable>newversion</replaceable>.sql</literal>
     (for example, <literal>foo--1.0--1.1.sql</literal> contains the commands to modify
     version <literal>1.0</literal> of extension <literal>foo</literal> into version
     <literal>1.1</literal>).
    </para>

    <para>
     Given that a suitable update script is available, the command
     <command>ALTER EXTENSION UPDATE</command> will update an installed extension
     to the specified new version.  The update script is run in the same
     environment that <command>CREATE EXTENSION</command> provides for installation
     scripts: in particular, <varname>search_path</varname> is set up in the same
     way, and any new objects created by the script are automatically added
     to the extension.
    </para>

    <para>
     If an extension has secondary control files, the control parameters
     that are used for an update script are those associated with the script's
     target (new) version.
    </para>

    <para>
     The update mechanism can be used to solve an important special case:
     converting a <quote>loose</quote> collection of objects into an extension.
     Before the extension mechanism was added to
     <productname>PostgreSQL</productname> (in 9.1), many people wrote
     extension modules that simply created assorted unpackaged objects.
     Given an existing database containing such objects, how can we convert
     the objects into a properly packaged extension?  Dropping them and then
     doing a plain <command>CREATE EXTENSION</command> is one way, but it's not
     desirable if the objects have dependencies (for example, if there are
     table columns of a data type created by the extension).  The way to fix
     this situation is to create an empty extension, then use <command>ALTER
     EXTENSION ADD</command> to attach each pre-existing object to the extension,
     then finally create any new objects that are in the current extension
     version but were not in the unpackaged release.  <command>CREATE
     EXTENSION</command> supports this case with its <literal>FROM</literal> <replaceable
     class="parameter">old_version</replaceable> option, which causes it to not run the
     normal installation script for the target version, but instead the update
     script named
     <literal><replaceable>extension</replaceable>--<replaceable>old_version</replaceable>--<replaceable>target_version</replaceable>.sql</literal>.
     The choice of the dummy version name to use as <replaceable
     class="parameter">old_version</replaceable> is up to the extension author, though
     <literal>unpackaged</literal> is a common convention.  If you have multiple
     prior versions you need to be able to update into extension style, use
     multiple dummy version names to identify them.
    </para>

    <para>
     <command>ALTER EXTENSION</command> is able to execute sequences of update
     script files to achieve a requested update.  For example, if only
     <literal>foo--1.0--1.1.sql</literal> and <literal>foo--1.1--2.0.sql</literal> are
     available, <command>ALTER EXTENSION</command> will apply them in sequence if an
     update to version <literal>2.0</literal> is requested when <literal>1.0</literal> is
     currently installed.
    </para>

    <para>
     <productname>PostgreSQL</productname> doesn't assume anything about the properties
     of version names: for example, it does not know whether <literal>1.1</literal>
     follows <literal>1.0</literal>.  It just matches up the available version names
     and follows the path that requires applying the fewest update scripts.
     (A version name can actually be any string that doesn't contain
     <literal>--</literal> or leading or trailing <literal>-</literal>.)
    </para>

    <para>
     Sometimes it is useful to provide <quote>downgrade</quote> scripts, for
     example <literal>foo--1.1--1.0.sql</literal> to allow reverting the changes
     associated with version <literal>1.1</literal>.  If you do that, be careful
     of the possibility that a downgrade script might unexpectedly
     get applied because it yields a shorter path.  The risky case is where
     there is a <quote>fast path</quote> update script that jumps ahead several
     versions as well as a downgrade script to the fast path's start point.
     It might take fewer steps to apply the downgrade and then the fast
     path than to move ahead one version at a time.  If the downgrade script
     drops any irreplaceable objects, this will yield undesirable results.
    </para>

    <para>
     To check for unexpected update paths, use this command:
<programlisting>
SELECT * FROM pg_extension_update_paths('<replaceable>extension_name</replaceable>');
</programlisting>
     This shows each pair of distinct known version names for the specified
     extension, together with the update path sequence that would be taken to
     get from the source version to the target version, or <literal>NULL</literal> if
     there is no available update path.  The path is shown in textual form
     with <literal>--</literal> separators.  You can use
     <literal>regexp_split_to_array(path,'--')</literal> if you prefer an array
     format.
    </para>
   </sect2>

   <sect2>
    <title>Extension Example</title>

    <para>
     Here is a complete example of an <acronym>SQL</acronym>-only
     extension, a two-element composite type that can store any type of value
     in its slots, which are named <quote>k</quote> and <quote>v</quote>.  Non-text
     values are automatically coerced to text for storage.
    </para>

    <para>
     The script file <filename>pair--1.0.sql</filename> looks like this:

<programlisting><![CDATA[
CREATE TYPE pair AS ( k text, v text );

CREATE OR REPLACE FUNCTION pair(anyelement, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(text, anyelement)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(anyelement, anyelement)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(text, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair;';

CREATE OPERATOR ~> (LEFTARG = text, RIGHTARG = anyelement, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = anyelement, RIGHTARG = text, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = anyelement, RIGHTARG = anyelement, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = text, RIGHTARG = text, PROCEDURE = pair);
]]>
</programlisting>
    </para>

    <para>
     The control file <filename>pair.control</filename> looks like this:

<programlisting>
# pair extension
comment = 'A key/value pair data type'
default_version = '1.0'
relocatable = true
</programlisting>
    </para>

    <para>
     While you hardly need a makefile to install these two files into the
     correct directory, you could use a <filename>Makefile</filename> containing this:

<programlisting>
EXTENSION = pair
DATA = pair--1.0.sql

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
</programlisting>

     This makefile relies on <acronym>PGXS</acronym>, which is described
     in <xref linkend="extend-pgxs"/>.  The command <literal>make install</literal>
     will install the control and script files into the correct
     directory as reported by <application>pg_config</application>.
    </para>

    <para>
     Once the files are installed, use the
     <xref linkend="sql-createextension"/> command to load the objects into
     any particular database.
    </para>
   </sect2>
  </sect1>

  <sect1 id="extend-pgxs">
   <title>Extension Building Infrastructure</title>

   <indexterm zone="extend-pgxs">
    <primary>pgxs</primary>
   </indexterm>

   <para>
    If you are thinking about distributing your
    <productname>PostgreSQL</productname> extension modules, setting up a
    portable build system for them can be fairly difficult.  Therefore
    the <productname>PostgreSQL</productname> installation provides a build
    infrastructure for extensions, called <acronym>PGXS</acronym>, so
    that simple extension modules can be built simply against an
    already installed server.  <acronym>PGXS</acronym> is mainly intended
    for extensions that include C code, although it can be used for
    pure-SQL extensions too.  Note that <acronym>PGXS</acronym> is not
    intended to be a universal build system framework that can be used
    to build any software interfacing to <productname>PostgreSQL</productname>;
    it simply automates common build rules for simple server extension
    modules.  For more complicated packages, you might need to write your
    own build system.
   </para>

   <para>
    To use the <acronym>PGXS</acronym> infrastructure for your extension,
    you must write a simple makefile.
    In the makefile, you need to set some variables
    and finally include the global <acronym>PGXS</acronym> makefile.
    Here is an example that builds an extension module named
    <literal>isbn_issn</literal>, consisting of a shared library containing
    some C code, an extension control file, a SQL script, and a documentation
    text file:
<programlisting>
MODULES = isbn_issn
EXTENSION = isbn_issn
DATA = isbn_issn--1.0.sql
DOCS = README.isbn_issn

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
</programlisting>
    The last three lines should always be the same.  Earlier in the
    file, you assign variables or add custom
    <application>make</application> rules.
   </para>

   <para>
    Set one of these three variables to specify what is built:

    <variablelist>
     <varlistentry>
      <term><varname>MODULES</varname></term>
      <listitem>
       <para>
        list of shared-library objects to be built from source files with same
        stem (do not include library suffixes in this list)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>MODULE_big</varname></term>
      <listitem>
       <para>
        a shared library to build from multiple source files
        (list object files in <varname>OBJS</varname>)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PROGRAM</varname></term>
      <listitem>
       <para>
        an executable program to build
        (list object files in <varname>OBJS</varname>)
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    The following variables can also be set:

    <variablelist>
     <varlistentry>
      <term><varname>EXTENSION</varname></term>
      <listitem>
       <para>
        extension name(s); for each name you must provide an
        <literal><replaceable>extension</replaceable>.control</literal> file,
        which will be installed into
        <literal><replaceable>prefix</replaceable>/share/extension</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>MODULEDIR</varname></term>
      <listitem>
       <para>
        subdirectory of <literal><replaceable>prefix</replaceable>/share</literal>
        into which DATA and DOCS files should be installed
        (if not set, default is <literal>extension</literal> if
        <varname>EXTENSION</varname> is set,
        or <literal>contrib</literal> if not)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA</varname></term>
      <listitem>
       <para>
        random files to install into <literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA_built</varname></term>
      <listitem>
       <para>
        random files to install into
        <literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>,
        which need to be built first
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA_TSEARCH</varname></term>
      <listitem>
       <para>
        random files to install under
        <literal><replaceable>prefix</replaceable>/share/tsearch_data</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DOCS</varname></term>
      <listitem>
       <para>
        random files to install under
        <literal><replaceable>prefix</replaceable>/doc/$MODULEDIR</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SCRIPTS</varname></term>
      <listitem>
       <para>
        script files (not binaries) to install into
        <literal><replaceable>prefix</replaceable>/bin</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SCRIPTS_built</varname></term>
      <listitem>
       <para>
        script files (not binaries) to install into
        <literal><replaceable>prefix</replaceable>/bin</literal>,
        which need to be built first
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>REGRESS</varname></term>
      <listitem>
       <para>
        list of regression test cases (without suffix), see below
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>EXTRA_CLEAN</varname></term>
      <listitem>
       <para>
        extra files to remove in <literal>make clean</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CPPFLAGS</varname></term>
      <listitem>
       <para>
        will be added to <varname>CPPFLAGS</varname>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_LIBS</varname></term>
      <listitem>
       <para>
        will be added to <varname>PROGRAM</varname> link line
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SHLIB_LINK</varname></term>
      <listitem>
       <para>
        will be added to <varname>MODULE_big</varname> link line
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CONFIG</varname></term>
      <listitem>
       <para>
        path to <application>pg_config</application> program for the
        <productname>PostgreSQL</productname> installation to build against
        (typically just <literal>pg_config</literal> to use the first one in your
        <varname>PATH</varname>)
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    </para>
 
    <para>
    Put this makefile as <literal>Makefile</literal> in the directory
    which holds your extension. Then you can do
    <literal>make</literal> to compile, and then <literal>make
    install</literal> to install your module.  By default, the extension is
    compiled and installed for the
    <productname>PostgreSQL</productname> installation that
    corresponds to the first <command>pg_config</command> program
    found in your <varname>PATH</varname>.  You can use a different installation by
    setting <varname>PG_CONFIG</varname> to point to its
    <command>pg_config</command> program, either within the makefile
    or on the <literal>make</literal> command line.
    </para>

   <caution>
    <para>
     Changing <varname>PG_CONFIG</varname> only works when building
     against <productname>PostgreSQL</productname> 8.3 or later.
     With older releases it does not work to set it to anything except
     <literal>pg_config</literal>; you must alter your <varname>PATH</varname>
     to select the installation to build against.
    </para>
   </caution>

   <para>
    The scripts listed in the <varname>REGRESS</varname> variable are used for
    regression testing of your module, which can be invoked by <literal>make
    installcheck</literal> after doing <literal>make install</literal>.  For this to
    work you must have a running <productname>PostgreSQL</productname> server.
    The script files listed in <varname>REGRESS</varname> must appear in a
    subdirectory named <literal>sql/</literal> in your extension's directory.
    These files must have extension <literal>.sql</literal>, which must not be
    included in the <varname>REGRESS</varname> list in the makefile.  For each
    test there should also be a file containing the expected output in a
    subdirectory named <literal>expected/</literal>, with the same stem and
    extension <literal>.out</literal>.  <literal>make installcheck</literal>
    executes each test script with <application>psql</application>, and compares the
    resulting output to the matching expected file.  Any differences will be
    written to the file <literal>regression.diffs</literal> in <command>diff
    -c</command> format.  Note that trying to run a test that is missing its
    expected file will be reported as <quote>trouble</quote>, so make sure you
    have all expected files.
   </para>

   <tip>
    <para>
     The easiest way to create the expected files is to create empty files,
     then do a test run (which will of course report differences).  Inspect
     the actual result files found in the <literal>results/</literal>
     directory, then copy them to <literal>expected/</literal> if they match
     what you expect from the test.
    </para>

   </tip>
   </sect1>

</chapter>
