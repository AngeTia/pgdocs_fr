<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="GIN">
<title>Index GIN</title>

   <indexterm>
    <primary>index</primary>
    <secondary>GIN</secondary>
   </indexterm>

<sect1 id="gin-intro">
 <title>Introduction</title>

<!-- posting list ? 
     liste postée me semble malheureux. Je mets "liste" en attendant mieux -->
 <para>
   <acronym>GIN</acronym> est l'acronyme de <foreignphrase>Generalized Inverted
   Index</foreignphrase> (ou index générique inverse).
  <acronym>GIN</acronym> is designed for handling cases where the items
  to be indexed are composite values, and the queries to be handled by
  the index need to search for element values that appear within
  the composite items.  For example, the items could be documents,
  and the queries could be searches for documents containing specific words.
 </para>

 <para>
  We use the word <firstterm>item</> to refer to a composite value that
  is to be indexed, and the word <firstterm>key</> to refer to an element
  value.  <acronym>GIN</acronym> always stores and searches for keys,
  not item values per se.
 </para>

 <para>
  A <acronym>GIN</acronym> index stores a set of (key, posting list) pairs,
  where a <firstterm>posting list</> is a set of row IDs in which the key
  occurs.  The same row ID can appear in multiple posting lists, since
  an item can contain more than one key.  Each key value is stored only
  once, so a <acronym>GIN</acronym> index is very compact for cases
  where the same key appears many times.
 </para>

 <para>
  <acronym>GIN</acronym> is generalized in the sense that the
  <acronym>GIN</acronym> access method code does not need to know the
  specific operations that it accelerates.
  Instead, it uses custom strategies defined for particular data types.
  The strategy defines how keys are extracted from indexed items and
  query conditions, and how to determine whether a row that contains
  some of the key values in a query actually satisfies the query.
 </para>

 <para>
  Un des avantages de <acronym>GIN</acronym> est la possibilité qu'il offre que
  des types de données personnalisés et les méthodes d'accès appropriées soient
  développés par un expert du domaine du type de données, plutôt que par un
  expert en bases de données. L'utilisation de <acronym>GiST</acronym> offre le
  même avantage.
 </para>

  <para>
   L'implantation de <acronym>GIN</acronym> dans
   <productname>PostgreSQL</productname> est principalement l'oeuvre de
   Teodor Sigaev et Oleg Bartunov. Plus d'informations sur <acronym>GIN</acronym>
   sont disponibles sur leur <ulink
   url="http://www.sai.msu.su/~megera/wiki/Gin">site web</ulink>.
  </para>
</sect1>

<sect1 id="gin-extensibility">
 <title>Extensibilité</title>

 <para>
   L'interface <acronym>GIN</acronym> a un haut niveau d'abstraction. De ce
   fait, la personne qui code la méthode d'accès n'a besoin d'implanter que les
   sémantiques du type de données accédé. La couche 
   <acronym>GIN</acronym> prend en charge la gestion de la concurrence, des traces
   et des recherches dans la structure de l'arbre.
 </para>

 <para>
   Pour obtenir une méthode d'accès <acronym>GIN</acronym>
   fonctionnelle, il suffit d'implanter quatre (ou cinq) méthodes utilisateur. Celles-ci
   définissent le comportement des clés dans l'arbre
   et les relations entre clés, valeurs indexées et requêtes
   indexables. En résumé, <acronym>GIN</acronym> combine extensibilité,
   généralisation, ré-utilisation du code à une interface
   claire.
 </para>

 <para>
   Les quatre méthodes qu'une classe d'opérateur
   <acronym>GIN</acronym> doit fournir sont&nbsp;:
 </para>

 <variablelist>
    <varlistentry>
     <term><function>int compare(Datum a, Datum b)</function></term>
     <listitem>
      <para>
	   Compare deux clés (et non deux valeurs indexées&nbsp;!) et renvoie un entier
	   négatif, zéro ou un entier positif, qui indique si la
	   première clé est inférieure, égale à ou supérieure à la seconde. Null keys are never
       passed to this function.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>Datum *extractValue(Datum inputValue, int32 *nkeys,
        bool **nullFlags)</function></term>
     <listitem>
      <para>
       Returns a palloc'd array of keys given an item to be indexed.  The
        number of returned keys must be stored into <literal>*nkeys</>.
       If any of the keys can be null, also palloc an array of
       <literal>*nkeys</> booleans, store its address at
       <literal>*nullFlags</>, and set these null flags as needed.
       <literal>*nullFlags</> can be left NULL (its initial value)
       if all keys are non-null.
       The return value can be NULL if the item contains no keys.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>Datum *extractQuery(Datum query, int32 *nkeys,
		StrategyNumber n, bool **pmatch, Pointer **extra_data,
        bool **nullFlags, int32 *searchMode)</function></term>
     <listitem>
      <para>
       Renvoie un tableau de clés en fonction de la valeur à requêter&nbsp;; c'est-à-dire
       que <literal>query</literal> est la valeur du côté droit d'un opérateur
       indexable dont le côté gauche est la colonne indexée.
       <literal>n</literal> est le numéro de stratégie de l'opérateur dans la
       classe d'opérateur (voir <xref linkend="xindex-strategies"/>). Souvent,
       <function>extractQuery</function> doit consulter
       <literal>n</literal> pour déterminer le type de données de
       <literal>query</literal> et the method it should use to extract key values.
       Le nombre de clés renvoyées doit être stocké dans
       <literal>*nkeys</literal>.
       If any of the keys can be null, also palloc an array of
       <literal>*nkeys</> booleans, store its address at
       <literal>*nullFlags</>, and set these null flags as needed.
       <literal>*nullFlags</> can be left NULL (its initial value)
       if all keys are non-null.
       The return value can be NULL if the <literal>query</> contains no keys.
      </para>

      <para>
       <literal>searchMode</> is an output argument that allows
       <function>extractQuery</> to specify details about how the search
       will be done.
       If <literal>*searchMode</> is set to
       <literal>GIN_SEARCH_MODE_DEFAULT</> (which is the value it is
       initialized to before call), only items that match at least one of
       the returned keys are considered candidate matches.
       If <literal>*searchMode</> is set to
       <literal>GIN_SEARCH_MODE_INCLUDE_EMPTY</>, then in addition to items
       containing at least one matching key, items that contain no keys at
       all are considered candidate matches.  (This mode is useful for
       implementing is-subset-of operators, for example.)
       If <literal>*searchMode</> is set to <literal>GIN_SEARCH_MODE_ALL</>,
       then all non-null items in the index are considered candidate
       matches, whether they match any of the returned keys or not.  (This
       mode is much slower than the other two choices, since it requires
       scanning essentially the entire index, but it may be necessary to
       implement corner cases correctly.  An operator that needs this mode
       in most cases is probably not a good candidate for a GIN operator
       class.)
       The symbols to use for setting this mode are defined in
       <filename>access/gin.h</>.
      </para>

      <para>
       <literal>pmatch</literal> est un paramètre de sortie à utiliser quand une correspondance
       partielle est permise. Pour l'utiliser, <function>extractQuery</function> doit allouer
       un tableau de booléens <literal>*nkeys</literal> et stocker son adresse dans
       <literal>*pmatch</literal>. Chaque élément du tableau devrait être positionné
       à TRUE si la clé correspondante a besoin d'une correspondance partielle, FALSE sinon.
       Si <literal>*pmatch</literal> est positionné à NULL alors GIN suppose qu'une
       mise en correspondance partielle n'est pas nécessaire. La variable est 
       initialisée à NULL avant l'appel, et peut donc être simplement ignorée
       par les classes d'opérateurs qui ne supportent pas les correspondances
       partielles.
      </para>

      <para>
       <literal>extra_data</literal> est un paramètre de sortie qui autorise
       <function>extractQuery</function> à passer des données supplémentaires aux
       méthodes <function>consistent</function> et <function>comparePartial</function>.
       Pour l'utiliser, <function>extractQuery</function> doit allouer un tableau
       de pointeurs <literal>*nkeys</literal> et stocker son adresse à
       <literal>*extra_data</literal>, puis stocker ce qu'il souhaite dans les
       pointeurs individuels. La variable est initialisée à NULL avant l'appel,
       afin que ce paramètre soit simplement ignoré par une classe d'opérateurs
       qui n'a pas besoin de données supplémentaires. Si <literal>*extra_data</literal>
       est positionné, le tableau dans son ensemble est passé à la méthode
       <function>consistent</function> method, et l'élément approprié à la méthode
       <function>comparePartial</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>bool consistent(bool check[], StrategyNumber n, Datum query,
                           int32 nkeys, Pointer extra_data[], bool *recheck,
        Datum queryKeys[], bool nullFlags[])</function></term>
     <listitem>
      <para>
       Returns TRUE if an indexed item satisfies the query operator with
       strategy number <literal>n</> (or might satisfy it, if the recheck
       indication is returned).  This function does not have direct access
       to the indexed item's value, since <acronym>GIN</acronym> does not
       store items explicitly.  Rather, what is available is knowledge
       about which key values extracted from the query appear in a given
       indexed item.  The <literal>check</> array has length
       <literal>nkeys</>, which is the same as the number of keys previously
       returned by <function>extractQuery</> for this <literal>query</> datum.
       Each element of the
       <literal>check</> array is TRUE if the indexed item contains the
       corresponding query key, ie, if (check[i] == TRUE) the i-th key of the
       <function>extractQuery</> result array is present in the indexed item.
       The original <literal>query</> datum is
       passed in case the <function>consistent</> method needs to consult it,
       and so are the <literal>queryKeys[]</> and <literal>nullFlags[]</>
       arrays previously returned by <function>extractQuery</>.
       <literal>extra_data</> is the extra-data array returned by
       <function>extractQuery</>, or NULL if none.
      </para>

      <para>
       When <function>extractQuery</> returns a null key in
       <literal>queryKeys[]</>, the corresponding <literal>check[]</> element
       is TRUE if the indexed item contains a null key; that is, the
       semantics of <literal>check[]</> are like <literal>IS NOT DISTINCT
       FROM</>.  The <function>consistent</> function can examine the
       corresponding <literal>nullFlags[]</> element if it needs to tell
       the difference between a regular value match and a null match.
      </para>

      <para>
       On success, <literal>*recheck</> should be set to TRUE if the heap
       tuple needs to be rechecked against the query operator, or FALSE if
       the index test is exact.  That is, a FALSE return value guarantees
       that the heap tuple does not match the query; a TRUE return value with
       <literal>*recheck</> set to FALSE guarantees that the heap tuple does
       match the query; and a TRUE return value with
       <literal>*recheck</> set to TRUE means that the heap tuple might match
       the query, so it needs to be fetched and rechecked by evaluating the
       query operator directly against the originally indexed item.
      </para>
     </listitem>
    </varlistentry>

  </variablelist>


 <para>
  En option, une classe d'opérateurs pour <acronym>GIN</acronym> peut fournir une
  cinquième méthode&nbsp;:
 </para>

  <variablelist>

    <varlistentry>
     <term><function>int comparePartial(Datum partial_key, Datum key, StrategyNumber n,
                              Pointer extra_data)</function></term>
     <listitem>
      <para>
       Compare une requête de correspondance partielle à une clé d'index. Renvoie
       un entier dont le signe indique le résultat&nbsp;: inférieur à zéro
       signifie que la clé d'index ne correspond pas à la requête mais que le
       parcours d'index va continuer&nbsp;; zéro signifie que la clé d'index
       ne correspond pas à la requête&nbsp;; supérieur à zéro indique que le
       parcours d'index doit s'arrêter car il n'existe pas d'autres
       correspondances. Le numéro de stratégie <literal>n</literal> de l'opérateur
       qui a généré la requête de correspondance partielle est fourni au cas où
       sa sémantique est nécessaire pour déterminer la fin du parcours. De plus,
       <literal>extra_data</literal> est l'élément correspondant du tableau
       extra-data fait par <function>extractQuery</function>, ou NULL sinon.
       Null keys are never passed to this function.
      </para>
     </listitem>
    </varlistentry>

  </variablelist>

 <para>
  Pour supporter des requêtes à <quote>correspondance partielle</quote>,
  une classe d'opérateur doit fournir la méthode <function>comparePartial</function>,
  et sa méthode <function>extractQuery</function> doit positionner le
  paramètre <literal>pmatch</literal> quand une requête à correspondance
  partielle est rencontrée. Voir <xref linkend="gin-partial-match"/> pour les détails.
 </para>

 <para>
  The actual data types of the various <literal>Datum</> values mentioned
  above vary depending on the operator class.  The item values passed to
  <function>extractValue</> are always of the operator class's input type, and
  all key values must be of the class's <literal>STORAGE</> type.  The type of
  the <literal>query</> argument passed to <function>extractQuery</> and
  <function>consistent</> is whatever is specified as the right-hand input
  type of the class member operator identified by the strategy number.
  This need not be the same as the item type, so long as key values of the
  correct type can be extracted from it.
 </para>

</sect1>

<sect1 id="gin-implementation">
 <title>Implantation</title>

 <para>
  En interne, un index <acronym>GIN</acronym> contient un index B-tree construit
  over keys, where each key is an element of one or more indexed
  items (a member of an array, for example) and where each tuple in a leaf
  page contains either a pointer to a B-tree of heap pointers (a
  <quote>posting tree</>), or a simple list of heap pointers (a <quote>posting
  list</>) when the list is small enough to fit into a single index tuple along
  with the key value.
 </para>

 <para>
  As of <productname>PostgreSQL</productname> 9.1, NULL key values can be
  included in the index.  Also, placeholder NULLs are included in the index
  for indexed items that are NULL or contain no keys according to
  <function>extractValue</>.  This allows searches that should find empty
  items to do so.
 </para>

 <para>
  Multi-column <acronym>GIN</acronym> indexes are implemented by building
  a single B-tree over composite values (column number, key value).  The
  key values for different columns can be of different types.
 </para>

 <sect2 id="gin-fast-update">
  <title>Technique GIN de mise à jour rapide</title>

  <para>
   Mettre à jour un index <acronym>GIN</acronym> a tendance à être lent en raison
   de la nature intrinsèque des index inversés&nbsp;: insérer ou mettre à jour
   un enregistrement de la table peut causer de nombreuses insertions dans l'index
   (une pour chaque clé extraite de l'élément indexé). À partir de 
   <productname>PostgreSQL</productname> 8.4, <acronym>GIN</acronym> est capable
   de reporter à plus tard la plupart de ce travail en insérant les nouveaux
   enregistrements dans une liste temporaire et non triée des entrées en attente.
   Quand un vacuum est déclenché sur la table, ou si la liste en attente devient
   trop grosse (plus grande que <xref linkend="guc-work-mem"/>), les entrées
   sont déplacées vers la structure de données <acronym>GIN</acronym> principale
   en utilisant la même technique d'insertion de masse que durant la création
   de l'index. Ceci améliore grandement la vitesse de mise à jour de l'index
   <acronym>GIN</acronym>, même en prenant en compte le surcoût engendré au
   niveau du vacuum. De plus, ce travail supplémentaire peut être attribué à un processus
   d'arrière-plan plutôt qu'à la requête en avant-plan.
  </para>

  <para>
   Le principal défaut de cette approche est que les recherches doivent
   parcourir la liste d'entrées en attente en plus de l'index habituel, et
   que par conséquent une grande liste d'entrées en attente ralentira les
   recherches de façon significative. Un autre défaut est que, bien que la majorité
   des mises à jour seront rapides, une mise à jour qui rend la liste d'attente
   <quote>trop grande</quote> déclenchera un cycle de nettoyage immédiat et sera
   donc bien plus lente que les autres mises à jour. Une utilisation appropriée
   d'autovacuum peut minimiser ces deux problèmes.
  </para>

  <para>
   Si la cohérence des temps de réponse est plus importante que la vitesse de
   mise à jour, l'utilisation de liste d'entrées en attente peut être désactivée
   en désactivant le paramètre de stockage <literal>FASTUPDATE</literal> pour
   un index GIN. Voir <xref linkend="sql-createindex"/> pour plus de détails.
  </para>
 </sect2>

 <sect2 id="gin-partial-match">
  <title>Algorithme de mise en correspondance partielle</title>

  <para>
   GIN peut supporter des requêtes de <quote>correspondances partielles</quote>,
   dans lesquelles la requête ne détermine pas une correspondance parfaite
   pour une ou plusieurs clés, mais que la correspondance tombe à une distance
   suffisamment faible des valeurs de clé (dans l'ordre de tri des clés déterminé
   par la méthode de support <function>compare</function>).
   La méthode <function>extractQuery</function>, au lieu de retourner une valeur
   de clé à mettre en correspondance de façon exacte, retourne une valeur de clé
   qui est la limite inférieure de la plage à rechercher, et retourne l'indicateur
   <literal>pmatch</literal> positionné à true. La plage de clé est alors parcourue
   en utilisant la méthode <function>comparePartial</function>.
   <function>comparePartial</function> doit retourner 0 pour une clé d'index correspondante,
   une valeur négative pour une non-correspondance qui est toujours dans la plage
   de recherche, et une valeur positive si la clé d'index est sortie de la plage
   qui pourrait correspondre.
  </para>
 </sect2>

</sect1>

<sect1 id="gin-tips">
<title>Conseils et astuces GIN</title>

 <variablelist>
  <varlistentry>
   <term>Création vs insertion</term>
   <listitem>
	<para>
	 L'insertion dans un index <acronym>GIN</acronym> peut être
	 lente du fait de la probabilité d'insertion de nombreuses clés pour
	 chaque élément. C'est pourquoi, pour les chargements massifs dans une table, il
	 est conseillé de supprimer l'index GIN et de le re-créer après
	 le chargement.
	</para>

    <para>
     À partir de <productname>PostgreSQL</productname> 8.4, ce conseil est moins
     important puisqu'une technique de mise à jour retardée est utilisée (voir
     <xref linkend="gin-fast-update"/> pour plus de détails). Mais pour les
     très grosses mises à jour, il peut toujours être plus efficace de détruire
     et recréer l'index.
    </para>
   </listitem>
  </varlistentry>

<!-- to skimp ? -->
  <varlistentry>
   <term><xref linkend="guc-maintenance-work-mem"/></term>
   <listitem>
    <para>
     Le temps de construction d'un index <acronym>GIN</acronym> dépend
     grandement du paramètre <varname>maintenance_work_mem</varname>&nbsp;;
     il est contre-productif de limiter la mémoire de travail lors de la création d'un index.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><xref linkend="guc-work-mem"/></term>
   <listitem>
    <para>
     Durant une série d'insertions dans un index <acronym>GIN</acronym> existant
     qui a <literal>FASTUPDATE</literal> activé, le système nettoiera la liste
     d'entrées en attente dès qu'elle deviendra plus grosse que
     <varname>work_mem</varname>. Afin d'éviter des fluctuations mesurables
     de temps de réponse, il est souhaitable d'avoir un nettoyage de la liste
     d'attente en arrière-plan (c'est-à-dire via autovacuum). Les opérations
     de nettoyage en avant-plan peuvent être évitées en augmentant
     <varname>work_mem</varname> ou en rendant autovacuum plus aggressif.
     Toutefois, augmenter <varname>work_mem</varname> implique que si un nettoyage
     en avant-plan se produit, il prendra encore plus longtemps.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><xref linkend="guc-gin-fuzzy-search-limit"/></term>
   <listitem>
	<para>
	 La raison principale qui a poussé le développement des index
	 <acronym>GIN</acronym> a été la volonté de supporter les recherches
	 plein texte dans <productname>PostgreSQL</productname> et il arrive
	 fréquemment qu'une recherche renvoie un ensemble volumineux de résultats.
	 Cela arrive d'autant plus fréquemment que la requête contient des mots très
	 fréquents, auquel cas l'ensemble de résultats n'est même pas
	 utile. Puisque la lecture des lignes sur disque et leur tri prend beaucoup de temps,
	 cette situation est inacceptable en production. (La
	 recherche dans l'index est, elle, très rapide.)
	</para>
	<para>
	 Pour faciliter l'exécution contrôlée de telles requêtes,
	 <acronym>GIN</acronym> dispose d'une limite supérieure souple
	 configurable du nombre de lignes renvoyées, le paramètre de configuration
	 <varname>gin_fuzzy_search_limit</varname>. Par défaut, il est
	 positionné à 0 (c'est-à-dire sans limite). Si une limite différente de
	 0 est choisie, alors l'ensemble renvoyé est un sous-ensemble du résultat complet, choisi
	 aléatoirement.
	</para>
	<para>
	 <quote>Souple</quote> signifie
	 que le nombre réel de résultats renvoyés peut différer légèrement
	 de la limite indiquée, en fonction de la requête et de la qualité du
	 générateur de nombres aléatoires du système.
	</para>
    <para>
     From experience, values in the thousands (e.g., 5000 &mdash; 20000)
     work well.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>

</sect1>

<sect1 id="gin-limit">
 <title>Limitations</title>

 <para>
  <acronym>GIN</acronym> assumes that indexable operators are strict.  This
  means that <function>extractValue</> will not be called at all on a NULL
  item value (instead, a placeholder index entry is created automatically),
  and <function>extractQuery</function> will not be called on a NULL query
  value either (instead, the query is presumed to be unsatisfiable).  Note
  however that NULL key values contained within a non-null composite item
  or query value are supported.
 </para>
</sect1>

<sect1 id="gin-examples">
 <title>Exemples</title>

 <para>
  Les sources de <productname>PostgreSQL</productname> incluent
  des classes d'opérateur <acronym>GIN</acronym> pour <type>tsvector</type> et
  pour les tableaux unidimensionnels de tous
  les types internes. La recherche de préfixe dans <type>tsvector</type> est
  implémentée en utilisant les correspondances partielles de <acronym>GIN</acronym>.
  Les modules <filename>contrib</filename> suivants
  contiennent aussi des classes d'opérateurs <acronym>GIN</acronym>&nbsp;:
 </para>
 
 <variablelist>
  <varlistentry>
   <term><filename>btree-gin</filename></term>
   <listitem>
    <para>Fonctionnalité équivalente à B-tree pour plusieurs types de données</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>hstore</filename></term>
   <listitem>
    <para>Module pour le stockage des paires (clé, valeur)</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>intarray</term>
   <listitem>
    <para>Support amélioré pour le type <type>int[]</type></para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>pg_trgm</filename></term>
   <listitem>
    <para>Similarité de texte par correspondance de trigramme</para>
   </listitem>
  </varlistentry>
 </variablelist>
</sect1>

</chapter>
