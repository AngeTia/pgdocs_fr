<?xml version="1.0" encoding="UTF-8"?>
<sect1 id="amcheck" xreflabel="amcheck">
 <title>amcheck</title>

 <indexterm zone="amcheck">
  <primary>amcheck</primary>
 </indexterm>

 <para>
  Le module <filename>amcheck</filename> fournit des fonctions vous permettant
  de vérifier la cohérence logique de la structure des relations.
 </para>

 <para>
  Les fonctions spécifiques aux B-Tree vérifient diverses <emphasis>propriétés
  invariantes</emphasis>
  dans la structure de la représentation de certains relations. La justesse
  des fonctions permettant l'accès aux données durant les parcours d'index et
  d'autres opérations importantes reposent sur le fait que ces propriétés
  invariantes sont toujours vraies. Par exemple, certaines fonctions
  vérifient, entre autres choses, que toutes les pages d'index B-Tree ont
  leurs éléments dans un ordre <quote>logique</quote> (par exemple, pour des
  index B-Tree sur un type  <type>text</type>, les lignes de l'index devraient
  être triées dans l'ordre alphabétique défini par la collation). Si, pour une
  raison ou une autre, cette propriété invariante spécifique n'est plus
  vérifiée, il faut s'attendre à ce que des recherches binaires sur la page
  affectée renseignent de manière erronée les parcours d'index, avec pour
  conséquence des résultats de requêtes SQL erronés. Si la structure semble
  valide, aucune erreur n'est levée.
 </para>

 <para>
  La vérification est réalisée en utilisant les même procédures que celles
  utilisées par les parcours d'index eux-mêmes, qui peuvent très bien être du
  code utilisateur pour une classe d'opérateur. Par exemple, la vérification
  d'index B-Tree s'appuie sur les comparaisons faites avec une ou plusieurs
  routines pour la fonction de support 1. Voir <xref
  linkend="xindex-support"/> pour plus de détail sur les fonctions de support
  des classes d'opérateur.
 </para>

 <para>
  Unlike the B-Tree checking functions which report corruption by raising
  errors, the heap checking function <function>verify_heapam</function> checks
  a table and attempts to return a set of rows, one row per corruption
  detected.  Despite this, if facilities that
  <function>verify_heapam</function> relies upon are themselves corrupted, the
  function may be unable to continue and may instead raise an error.
 </para>

 <para>
  Permission to execute <filename>amcheck</filename> functions may be granted
  to non-superusers, but before granting such permissions careful consideration
  should be given to data security and privacy concerns.  Although the
  corruption reports generated by these functions do not focus on the contents
  of the corrupted data so much as on the structure of that data and the nature
  of the corruptions found, an attacker who gains permission to execute these
  functions, particularly if the attacker can also induce corruption, might be
  able to infer something of the data itself from such messages.
 </para>

 <sect2>
  <title>Fonctions</title>

  <variablelist>
   <varlistentry>
    <term>
     <function>bt_index_check(index regclass, heapallindexed boolean) returns void</function>
     <indexterm>
      <primary>bt_index_check</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>bt_index_check</function> vérifie que sa cible, un index
      B-Tree, respecte un éventail de propriétés invariables. Exemple
      d'utilisation&nbsp;:

      <screen><![CDATA[
test=# SELECT bt_index_check(index => c.oid, heapallindexed =&gt; i.indisunique),
               c.relname,
               c.relpages
FROM pg_index i
JOIN pg_opclass op ON i.indclass[0] = op.oid
JOIN pg_am am ON op.opcmethod = am.oid
JOIN pg_class c ON i.indexrelid = c.oid
JOIN pg_namespace n ON c.relnamespace = n.oid
WHERE am.amname = 'btree' AND n.nspname = 'pg_catalog'
-- Ignore les tables temporaires, qui peuvent appartenir à d'autres sessions
AND c.relpersistence != 't'
-- La fonction peut renvoyer une erreur si cela est omis :
AND c.relkind = 'i' AND i.indisready AND i.indisvalid
ORDER BY c.relpages DESC LIMIT 10;

 bt_index_check |             relname             | relpages
----------------+---------------------------------+----------
                | pg_depend_reference_index       |       43
                | pg_depend_depender_index        |       40
                | pg_proc_proname_args_nsp_index  |       31
                | pg_description_o_c_o_index      |       21
                | pg_attribute_relid_attnam_index |       14
                | pg_proc_oid_index               |       10
                | pg_attribute_relid_attnum_index |        9
                | pg_amproc_fam_proc_index        |        5
                | pg_amop_opr_fam_index           |        5
                | pg_amop_fam_strat_index         |        5
(10 rows)
]]></screen>

      Cet exemple montre une session qui vérifie les 10 plus gros index du
      catalogue de la base de données <quote>test</quote>. La vérification de
      la présence des lignes de la table dans l'index est demandée pour le
      sous-ensemble des index uniques. Puisqu'aucune erreur n'est retournée,
      tous les index testés semblent être cohérents au niveau logique. Bien
      évidemment, cette requête pourrait être facilement modifiée pour appeler
      <function>bt_index_check</function> sur chacun des index présents dans
      la base de données pour lesquels la vérification est supportée.
     </para>

     <para>
      <function>bt_index_check</function> acquiert un
      <literal>AccessShareLock</literal> sur l'index cible ainsi que sur la
      relation à laquelle il appartient. Ce niveau de verrouillage est le même
      que celui acquis sur les relations lors d'une simple requête
      <literal>SELECT</literal>. <function>bt_index_check</function> ne
      vérifie pas les propriétés invariantes qui englobent les relations
      enfant/parent, mais vérifiera la présence de toutes les lignes de la
      table et des lignes d'index à l'intérieur de l'index quand
      <parameter>heapallindexed</parameter> vaut <literal>true</literal>.
      Quand il faut lancer un test de recherche de corruption, de routine et
      pas trop lourd, sur un environnement de production, l'utilisation de
      <function>bt_index_check</function> offre généralement le meilleur
      compromis entre vérification minutieuse et impact limité sur les
      performances et la disponibilité de l'application.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>bt_index_parent_check(index regclass, heapallindexed boolean, rootdescend boolean) returns void</function>
     <indexterm>
      <primary>bt_index_parent_check</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>bt_index_parent_check</function> teste que sa cible, un index
      B-Tree, respecte un certain nombre de propriétés invariantes. En option,
      quand l'argument <parameter>heapallindexed</parameter> vaut
      <literal>true</literal>, la fonction vérifie la présence de toutes les
      lignes dans la table. Quand l'argument optionel
      <parameter>rootdescend</parameter> vaut <literal>true</literal>, la
      vérification recherche de nouveau les lignes au niveau des feuilles en
      réalisant une nouvelle recherche à partir de la racine pour chaque
      ligne. Les vérifications réalisables par
      <function>bt_index_parent_check</function> sont un sur-ensemble des
      vérifications réalisées par <function>bt_index_check</function>. On peut
      voir <function>bt_index_parent_check</function> comme une version plus
      minutieuse de <function>bt_index_check</function>&nbsp;: contrairement à
      <function>bt_index_check</function>,
      <function>bt_index_parent_check</function> vérifie également les
      propriétés invariantes qui englobent les relations parent/enfant, et la
      présence de tous les liens dans la structure de l'index.
      <function>bt_index_parent_check</function> respecte la convention
      habituelle qui consiste à retourner une erreur si une incohérence ou
      tout autre problème est détecté.
     </para>

     <para>
      Un verrou de type <literal>ShareLock</literal> est requis sur l'index
      ciblé par <function>bt_index_parent_check</function> (un
      <literal>ShareLock</literal> est également acquis sur la relation
      associée). Ces verrous empêchent des modifications concurrentes par des
      commandes <command>INSERT</command>, <command>UPDATE</command> et
      <command>DELETE</command>. Les verrous empêchent également la relation
      associée d'être traitée de manière concurrente par
      <command>VACUUM</command>, ainsi que toute autre commande
      d'administration. Il est à noter que cette fonction ne conserve les
      verrous uniquement que durant son exécution et non pas durant
      l'intégralité de la transaction.
     </para>

     <para>
      La vérification supplémentaire qu'opère
      <function>bt_index_parent_check</function> est plus apte à détecter
      différents cas pathologiques. Ces cas peuvent impliquer une classe
      d'opérateur B-Tree implémentée de manière incorrecte utilisée pour
      l'index vérifié, ou, hypothétiquement, des bugs non encore découverts
      dans le code de la méthode d'accès associée à cet index B-Tree. Il est à
      noter que <function>bt_index_parent_check</function> ne peut pas être
      utilisé lorsque le mode Hot Standby est activé (c'est-à-dire, sur un
      serveur secondaire disponible en lecture seule), contrairement à
      <function>bt_index_check</function>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <tip>
   <para>
    <function>bt_index_check</function> et
    <function>bt_index_parent_check</function> journalisent toutes les deux
    des messages sur la vérification, au niveau de sévérité
    <literal>DEBUG1</literal> et <literal>DEBUG2</literal>. Ces messages
    fournissent des informations détaillées sur la vérification exploitables
    par les développeurs <productname>PostgreSQL</productname>. Les
    utilisateurs avancés peuvent aussi trouver ces informations utiles, car
    elles fournissent du contexte additionnel si jamais la vérification détecte
    une incohérence. Exécuter
    <programlisting><![CDATA[
SET client_min_messages = DEBUG1;
]]></programlisting>
    dans une session interactive <application>psql</application> avant
    d'exécuter une requête de vérification, va afficher les messages sur sa
    progression avec un niveau de détail raisonnable.
   </para>
  </tip>
 
  <variablelist>
   <varlistentry>
    <term>
     <function>
      verify_heapam(relation regclass,
                    on_error_stop boolean,
                    check_toast boolean,
                    skip text,
                    startblock bigint,
                    endblock bigint,
                    blkno OUT bigint,
                    offnum OUT integer,
                    attnum OUT integer,
                    msg OUT text)
      returns setof record
     </function>
    </term>
    <listitem>
     <para>
      Checks a table for structural corruption, where pages in the relation
      contain data that is invalidly formatted, and for logical corruption,
      where pages are structurally valid but inconsistent with the rest of the
      database cluster.
     </para>
     <para>
      The following optional arguments are recognized:
     </para>
     <variablelist>
      <varlistentry>
       <term><literal>on_error_stop</literal></term>
       <listitem>
        <para>
         If true, corruption checking stops at the end of the first block in
         which any corruptions are found.
        </para>
        <para>
         Defaults to false.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>check_toast</literal></term>
       <listitem>
        <para>
         If true, toasted values are checked against the target relation's
         TOAST table.
        </para>
        <para>
         This option is known to be slow.  Also, if the toast table or its
         index is corrupt, checking it against toast values could conceivably
         crash the server, although in many cases this would just produce an
         error.
        </para>
        <para>
         Defaults to false.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>skip</literal></term>
       <listitem>
        <para>
         If not <literal>none</literal>, corruption checking skips blocks that
         are marked as all-visible or all-frozen, as specified.
         Valid options are <literal>all-visible</literal>,
         <literal>all-frozen</literal> and <literal>none</literal>.
        </para>
        <para>
         Defaults to <literal>none</literal>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>startblock</literal></term>
       <listitem>
        <para>
         If specified, corruption checking begins at the specified block,
         skipping all previous blocks.  It is an error to specify a
         <literal>startblock</literal> outside the range of blocks in the
         target table.
        </para>
        <para>
         By default, checking begins at the first block.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>endblock</literal></term>
       <listitem>
        <para>
         If specified, corruption checking ends at the specified block,
         skipping all remaining blocks.  It is an error to specify an
         <literal>endblock</literal> outside the range of blocks in the target
         table.
        </para>
        <para>
         By default, all blocks are checked.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <para>
      For each corruption detected, <function>verify_heapam</function> returns
      a row with the following columns:
     </para>
     <variablelist>
      <varlistentry>
       <term><literal>blkno</literal></term>
       <listitem>
        <para>
         The number of the block containing the corrupt page.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>offnum</literal></term>
       <listitem>
        <para>
         The OffsetNumber of the corrupt tuple.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>attnum</literal></term>
       <listitem>
        <para>
         The attribute number of the corrupt column in the tuple, if the
         corruption is specific to a column and not the tuple as a whole.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>msg</literal></term>
       <listitem>
        <para>
         A message describing the problem detected.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2>
  <title>Vérification optionnelle <parameter>heapallindexed</parameter></title>

  <para>
   Quand l'argument <parameter>heapallindexed</parameter> des fonctions de
   vérification des B-Tree est à <literal>true</literal>, une phase de vérification
   supplémentaire est opérée sur la table associée à l'index cible. Elle
   consiste en une opération <command>CREATE INDEX</command>
   <quote>bidon</quote> qui vérifie la présence de tous les nouveaux
   enregistrements hypothétiques d'index dans une structure de récapitulation
   temporaire et en mémoire (elle est construite au besoin durant la première
   phase de la vérification). Cette structure de récapitulation prend
   l'<quote>empreinte digitale</quote> de chaque enregistrement rencontré dans
   l'index cible. Le principe directeur derrière la vérification
   <parameter>heapallindexed</parameter> est qu'un nouvel index équivalent à
   l'index cible existant ne doit avoir que des entrées que l'on peut trouver
   dans la structure existante.
  </para>

  <para>
   La phase <parameter>heapallindexed</parameter> supplémentaire a un coût
   significatif&nbsp;: typiquement, la vérification peut être plusieurs fois
   plus longue. Cependant il n'y a pas de changement quant aux verrous acquis
   au niveau de la table quand on opère une vérification
   <parameter>heapallindexed</parameter>.
  </para>

  <para>
   La structure de récapitulation est limitée en taille par
   <varname>maintenance_work_mem</varname>. Pour s'assurer que la probabilité
   de rater une incohérence ne dépasse 2&nbsp;% pour chaque enregistrement qui
   devrait être dans l'index, il faut environ 2 octets de mémoire par
   enregistrement. Quand moins de mémoire est disponible par enregistrement,
   la probabilité de manquer une incohérence augmente lentement. Cette
   approche limite significativement le coût de la vérification, tout en
   réduisant légèrement la probabilité de détecter un problème,
   particulièrement sur les installations où la vérification est traitée comme
   une opération de maintenance de routine. Tout enregistrement absent ou
   déformé a une nouvelle chance d'être détecté avec chaque lancement de la
   vérification.
  </para>
 </sect2>

 <sect2>
  <title>Utiliser <filename>amcheck</filename> efficacement</title>

  <para>
   <filename>amcheck</filename> peut être efficace pour détecter différents
   types de modes d'échec que les <link
   linkend="app-initdb-data-checksums"><application>sommes de contrôle
   </application></link> n'arriveront jamais à détecter. Cela inclut&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Les incohérences dans la structure causées par des implémentations
      incorrectes de classe d"opérateur.
     </para>

     <para>
      Cela inclut également des problèmes causés par le changement des règles
      de comparaison des collations du système d'exploitation. Les
      comparaisons des données d'un type ayant une collation comme
      <type>text</type> doivent être immuables (tout comme toutes les autres
      comparaisons utilisées pour les parcours d'index B-Tree doivent être
      immuables), ce qui implique que les règles de collation du système
      d'exploitation ne doivent jamais changer. Bien que cela soit rare, des
      mises à jour des règles des collations du système d'exploitation peuvent
      causer ces problèmes. Plus généralement, une incohérence dans l'ordre de
      collation entre un serveur primaire et son réplicat est impliqué,
      peut-être parce que la version <emphasis>majeure</emphasis> du système
      d'exploitation utilisée est incohérente. De telles incohérences ne
      surviendront généralement que sur des serveurs secondaires, et ne
      pourront par conséquent être détectées que là.
     </para>

     <para>
      Si un tel problème survient, il se peut que cela n'affecte pas chaque
      index qui utilise le tri d'une collation affectée, tout simplement car
      les valeurs <emphasis>indexées</emphasis> pourraient avoir le même ordre
      de tri absolu indépendamment des incohérences comportementales. Voir
      <xref linkend="locale"/> et <xref linkend="collation"/> pour plus de
      détails sur comment <productname>PostgreSQL</productname> utilise les
      locales et collations du système d'exploitation.
     </para>
    </listitem>

    <listitem>
     <para>
      Les incohérences dans la structure entre les index et les tables
      indexées (lorsque la vérification <parameter>heapallindexed</parameter>
      est réalisée).
     </para>

     <para>
      Il n'y a pas de vérification avec la table initiale en temps normal. Les
      symptômes d'une corruption de la table peuvent être subtils.
     </para>
    </listitem>

    <listitem>
      <para>
      La corruption causée par un hypothétique bug non encore découvert dans
      le code de la méthode d'accès dans PostgreSQL, dans le code effectuant
      le tri ou le code de gestion transactionnelle.
     </para>

     <para>
      La vérification automatique de l'intégrité structurelle des index joue
      un rôle dans les tests généraux des fonctionnalités de
      <productname>PostgreSQL</productname>, nouvelles ou proposées, qui
      pourraient possiblement permettre l'introduction d'incohérences
      logiques. La vérification de la structure de la table et des
      informations de visibilité et de statut des transactions associées joue
      un rôle similaire. Une stratégie de test évidente est d'appeler les
      fonctions d'<filename>amcheck</filename> de manière continue en même
      temps que les tests de régression standard sont lancés. Voir <xref
      linkend="regress-run"/> pour plus de détails sur comment lancer les
      tests.
     </para>
    </listitem>

    <listitem>
     <para>
      Les failles dans le système de fichiers ou dans le sous-système de
      stockage quand les sommes de contrôles ne sont pas activées.
     </para>

     <para>
      Il est à noter que <filename>amcheck</filename> n'examine une page que
      telle qu'elle se présente dans un tampon en mémoire partagée lors de la
      vérification, et qu'en accédant au bloc dans la mémoire partagée. Par
      conséquent, <filename>amcheck</filename> n'examine pas forcément les
      données lues depuis le système de fichiers au moment de la vérification.
      Notez que si les sommes de contrôles sont activées,
      <filename>amcheck</filename> peut lever une erreur de somme de contrôle
      incorrecte quand un bloc corrompu est lu vers un tampon.
     </para>
    </listitem>

    <listitem>
     <para>
      Les corruptions causée par une RAM défaillante, et plus largement le
      sous-système mémoire et le système d'exploitation.
     </para>

     <para>
      <productname>PostgreSQL</productname> ne protège pas contre les erreurs
      mémoire corrigibles, et il est supposé que vous utilisez de la mémoire
      RAM de standard industriel ECC (<foreignphrase>Error Correcting
      Codes</foreignphrase>) ou avec une meilleure protection. Cependant, la
      mémoire ECC n'est typiquement immunisée que contre les erreurs d'un seul
      bit, et il ne faut pas partir du principe que ce type de mémoire fournit
      une protection <emphasis>absolue</emphasis> contre les défaillances
      provoquant une corruption de la mémoire.
     </para>

     <para>
      Quand la vérification <parameter>heapallindexed</parameter> est
      réalisée, il y a une chance fortement accrue de détecter des erreurs
      d'un bit car l'égalité binaire stricte est testée et les attributs
      indexés de la table sont testés.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Structural corruption can happen due to faulty storage hardware, or
   relation files being overwritten or modified by unrelated software.
   This kind of corruption can also be detected with
   <link linkend="checksums"><application>data page
   checksums</application></link>.
  </para>

  <para>
   Relation pages which are correctly formatted, internally consistent, and
   correct relative to their own internal checksums may still contain
   logical corruption.  As such, this kind of corruption cannot be detected
   with <application>checksums</application>.  Examples include toasted
   values in the main table which lack a corresponding entry in the toast
   table, and tuples in the main table with a Transaction ID that is older
   than the oldest valid Transaction ID in the database or cluster.
  </para>

  <para>
   Multiple causes of logical corruption have been observed in production
   systems, including bugs in the <productname>PostgreSQL</productname>
   server software, faulty and ill-conceived backup and restore tools, and
   user error.
  </para>

  <para>
   Corrupt relations are most concerning in live production environments,
   precisely the same environments where high risk activities are least
   welcome.  For this reason, <function>verify_heapam</function> has been
   designed to diagnose corruption without undue risk.  It cannot guard
   against all causes of backend crashes, as even executing the calling
   query could be unsafe on a badly corrupted system.   Access to <link
   linkend="catalogs-overview">catalog tables</link> is performed and could
   be problematic if the catalogs themselves are corrupted.
  </para>

  <para>
   De manière générale, <filename>amcheck</filename> ne peut que prouver la
   présence d'une corruption&nbsp;; il ne peut pas en prouver l'absence.
  </para>
 </sect2>

 <sect2>
  <title>Réparer une corruption</title>

  <para>
   Aucune erreur concernant une corruption remontée par
   <filename>amcheck</filename> ne devrait être un faux positif.
   <filename>amcheck</filename> remonte des erreurs dans le cas où des
   conditions, par définition, ne devraient jamais arriver, et par conséquent
   une analyse minutieuse des erreurs remontées par
   <filename>amcheck</filename> est souvent nécessaire.
  </para>

  <para>
   Il n'y a pas de méthode générale pour réparer les problèmes que
   <filename>amcheck</filename> détecte. Une explication de la cause
   principale menant à ce que la propriété invariante soit violée devrait être
   étudiée. <xref linkend="pageinspect"/> peut jouer un rôle utile dans le
   diagnostic de la corruption qu'<filename>amcheck</filename> détecte. Un
   <command>REINDEX</command> peut échouer à réparer la corruption.
  </para>
 </sect2>
</sect1>
