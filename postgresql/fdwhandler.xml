<?xml version="1.0" encoding="UTF-8"?>
<chapter id="fdwhandler">
 <title>Écrire un wrapper de données distantes</title>

 <indexterm zone="fdwhandler">
  <primary>wrapper de données distantes</primary>
  <secondary>gestionnaire</secondary>
 </indexterm>

 <para>
  Toutes les opérations sur une table distante sont gérées via un
  wrapper de données distantes. Ce dernier est un ensemble de fonctions
  que PostgreSQL appelle. Le wrapper de données
  distantes est responsable de la récupération des données à partir de
  le source de données distante et de leur renvoi à l'exécuteur
  <productname>PostgreSQL</productname>. Si la mise à jour de tables distantes
  doit être supporté, le wrapper doit aussi gérer cela.
  Ce chapitre indique comment
  écrire un nouveau wrapper de données distantes.
 </para>

 <para>
  Les wrappers de données distantes incluent dans la distribution
  standard sont de bons exemples lorsque vous essayez d'écrire les
  votres. Regardez dans le sous-répertoire
  <filename>contrib</filename> du répertoire des sources. La
  page de référence <xref linkend="sql-createforeigndatawrapper"/>
  contient aussi des détails utiles.
 </para>

 <note>
  <para>
   Le standard SQL spécifie une interface pour l'écriture des wrappers
   de données distantes. Néanmoins, PostgreSQL n'implémente pas cette
   API car l'effort nécessaire pour cela serait trop important. De
   toute façon, l'API standard n'est pas encore très adoptée.
  </para>
 </note>

 <sect1 id="fdw-functions">
  <title>Fonctions d'un wrapper de données distantes</title>

  <para>
   Le développeur d'un FDW doit écrire une fonction de gestion (handler)
   et, en option, une fonction de validation. Les deux fonctions doivent
   être écrites dans un langage compilé comme le C en utilisant
   l'interface version-1. Pour les détails sur les conventions d'appel
   et le chargement dynamique en langage C, voir <xref linkend="xfunc-c"/>.
  </para>

  <para>
   La fonction de gestion renvoie simplement une structure de pointeurs
   de fonctions callback qui seront appelées par le planificateur,
   l'exécuteur et différentes commandes de maintenance. La plupart du
   travail dans l'écriture d'une FDW se
   trouve dans l'implémentation de ces fonctions callback. La fonction
   de gestion doit être enregistrée dans
   <productname>PostgreSQL</productname> comme ne prenant aucun argument
   et renvoyant le pseudo-type <type>fdw_handler</type>. Les fonctions
   callback sont des fonctions en C et ne sont pas visibles ou
   appelables avec du SQL. Les fonctions callback sont décrites dans
   <xref linkend="fdw-callbacks"/>.
  </para>

  <para>
   La fonction de validation est responsable de la validation des options
   données dans les commandes <command>CREATE</command> et
   <command>ALTER</command> pour son wrapper de données distantes,
   ainsi que pour les serveurs distants, les correspondances
   d'utilisateurs et les tables distants utilisant le wrapper. La
   fonction de validation doit être enregistrée comme prenant deux
   arguments&nbsp;: un tableau de texte contenant les options à
   valider et un OID représentant le type d'objet avec lequel les
   options sont validées (sous la forme d'un OID du catalogue système
   où sera stocké l'objet, donc
   <literal>ForeignDataWrapperRelationId</literal>,
   <literal>ForeignServerRelationId</literal>,
   <literal>UserMappingRelationId</literal> ou
   <literal>ForeignTableRelationId</literal>).
   Si aucune fonction de validation n'est fournie, les options ne sont
   pas vérifiées au moment de la création ou de la modification de
   l'objet.
  </para>

 </sect1>

 <sect1 id="fdw-callbacks">
  <title>Routines callback des wrappers de données distantes</title>

  <para>
   La fonction de gestion d'une FDW renvoie une structure
   <structname>FdwRoutine</structname> allouée avec palloc. Elle
   contient des pointeurs vers les fonctions de callback décrites
   ci-dessous. Les fonctions relatives aux parcours sont requises,
   le reste est optionnel.
  </para>

  <para>
   Le type de structure <structname>FdwRoutine</structname> est déclaré dans
   <filename>src/include/foreign/fdwapi.h</filename>, où vous trouverez plus de
   détails.
  </para>

  <sect2 id="fdw-callbacks-scan">
   <title>Routines des FDW pour parcourir les tables distantes</title>

   <para>
    <programlisting>
void
GetForeignRelSize (PlannerInfo *root,
                   RelOptInfo *baserel,
                   Oid foreigntableid);
    </programlisting>

    Obtient des estimations de la taille de la relation pour une table distante.
    Elle est appelée au début de la planification d'une requête parcourant une
    table distante. <literal>root</literal> est l'information globale du
    planificateur sur la requête&nbsp;; <literal>baserel</literal> est
    l'information du planificateur sur la table&nbsp;; et
    <literal>foreigntableid</literal> est l'OID provenant de
    <structname>pg_class</structname> pour cette table distante.
    (<literal>foreigntableid</literal> pourrait être obtenu à partir de la
    structure de données du planificateur mais il est directement fourni pour
    ne pas avoir à faire cet effort.)
   </para>

   <para>
    Cette fonction doit mettre à jour <literal>baserel-&gt;rows</literal> pour
    que cela corresponde au nombre de lignes renvoyées par un parcours de table
    après avoir pris en compte le filtre réalisé par les clauses de restriction.
    La valeur initiale de <literal>baserel-&gt;rows</literal> est une estimation
    par défaut, qui doit être remplacée si possible. La fonction pourrait aussi
    choisir de mettre à jour <literal>baserel-&gt;width</literal> si elle
    peut calculer une meilleure estimation de la largeur moyenne d'une ligne du
    résultat.
   </para>

   <para>
    Voir <xref linkend="fdw-planning"/> pour plus d'informations.
   </para>

   <para>
    <programlisting>
void
GetForeignPaths (PlannerInfo *root,
                 RelOptInfo *baserel,
                 Oid foreigntableid);
    </programlisting>

    Crée les chemins d'accès possibles pour un parcours sur une table distante.
    Cette fonction est appelée lors de la planification de la requête. Les
    paramètres sont identiques à ceux de <function>GetForeignRelSize</function>,
    qui a déjà été appelée.
   </para>

   <para>
    Cette fonction doit générer au moins un chemin d'accès (nœud
    <structname>ForeignPath</structname>) pour un parcours sur une table
    distante et doit appeler <function>add_path</function> pour ajouter chaque
    chemin à <literal>baserel-&gt;pathlist</literal>. Il est recommandé
    d'utiliser <function>create_foreignscan_path</function> pour construire les
    nœuds <structname>ForeignPath</structname>. La fonction peut générer plusieurs
    chemins d'accès, c'est-à-dire un chemin qui a un champ
    <literal>pathkeys</literal> valide pour représenter un résultat pré-trié.
    Chaque chemin d'accès doit contenir les estimations de coûts et peut contenir
    toute information privée au FDW qui est nécessaire pour identifier la méthode
    attendue du parcours spécifique.
   </para>

   <para>
    Voir <xref linkend="fdw-planning"/> pour plus d'informations.
   </para>

   <para>
    <programlisting>
ForeignScan *
GetForeignPlan (PlannerInfo *root,
                RelOptInfo *baserel,
                Oid foreigntableid,
                ForeignPath *best_path,
                List *tlist,
                List *scan_clauses,
                Plan *outer_plan);
    </programlisting>

    Crée un nœud de plan <structname>ForeignScan</structname> à partir du chemin
    d'accès distant sélectionné. Cette fonction est appelé à la fin de la
    planification de la requête.
    Les paramètres sont identiques à ceux de la fonction
    <function>GetForeignRelSize</function>, avec en plus le
    <structname>ForeignPath</structname> sélectionné (précédemment produit par
    <function>GetForeignPaths</function> ou
    <function>GetForeignJoinPaths</function>), la liste cible à émettre par le
    nœud du plan, et les clauses de restriction forcées par le nœud du plan.
    (If the path is for a join rather than a base relation,
    <literal>foreigntableid</literal> is <literal>InvalidOid</literal>.)
   </para>

   <para>
    Cette fonction doit créer et renvoyer un nœud <structname>ForeignScan</structname>.
    Il est recommandé d'utiliser <function>make_foreignscan</function> pour
    construire le nœud <structname>ForeignScan</structname>.
   </para>

   <para>
    Voir <xref linkend="fdw-planning"/> pour plus d'informations.
   </para>

   <para>
    <programlisting>
void
BeginForeignScan (ForeignScanState *node,
                  int eflags);
    </programlisting>

    Commence l'exécution d'un parcours distant. L'appel se fait lors du
    démarrage de l'exécuteur. Cette fonction doit réaliser toutes les
    initialisation nécessaires avant le démarrage du parcours, mais ne
    doit pas commencer à exécuter le vrai parcours (cela se fera lors
    du premier appel à <function>IterateForeignScan</function>). Le
    n&oelig;ud <structname>ForeignScanState</structname> est déjà créé
    mais son champ <structfield>fdw_state</structfield> vaut toujours
    NULL. Les informations sur la table à parcourir sont accessibles
    via le n&oelig;ud <structname>ForeignScanState</structname> (en
    particulier à partir du n&oelig;ud sous-jacent
    <structname>ForeignScan</structname> qui contient toute information
    privée au FDW fournie par <function>GetForeignPlan</function>).
    <literal>eflags</literal> contient les bits de drapeaux décrivant le
    mode opératoire de l'exécuteur pour ce n&oelig;ud du plan.
   </para>

   <para>
    Notez que quand <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal>
    est vraie, cette fonction ne doit pas réaliser d'actions visibles
    en externe. Elle doit seulement faire le minimum requis pour que
    l'état du n&oelig;ud soit valide pour
    <function>ExplainForeignScan</function> et
    <function>EndForeignScan</function>.
   </para>

   <para>
    <programlisting>
TupleTableSlot *
IterateForeignScan (ForeignScanState *node);
    </programlisting>

    Récupère une ligne de la source distante, la renvoyant dans un
    emplacement de ligne de table (le champ
    <structfield>ScanTupleSlot</structfield> du n&oelig;ud doit être
    utilisé dans ce but). Renvoie NULL s'il n'y a plus de lignes
    disponibles. L'infrastructure d'emplacement de ligne de table permet
    qu'une ligne physique ou virtuelle soit renvoyée. Dans la plupart
    des cas, la deuxième possibilité (virtuelle), est préférable d'un
    point de vue des performances. Notez que cette fonction est appelée
    dans un contexte mémoire dont la durée de vie est très courte et
    qui sera réinitialisé entre chaque appel. Créez un contexte mémoire
    dans <function>BeginForeignScan</function> si vous avez besoin d'un
    stockage qui tient plus longtemps ou utilisez le champ
    <structfield>es_query_cxt</structfield> de <structname>EState</structname>.
   </para>

   <para>
    The rows returned must match the <structfield>fdw_scan_tlist</structfield>
    target list if one was supplied, otherwise they must match the row type of
    the foreign table being scanned.  If you choose to optimize away fetching
    columns that are not needed, you should insert nulls in those column
    positions, or else generate a <structfield>fdw_scan_tlist</structfield>
    list with those columns omitted.
   </para>

   <para>
    Notez que l'exécuteur de <productname>PostgreSQL</productname> ne
    se préoccupe pas de savoir
    whether the rows returned violate any constraints that were defined on
    the foreign table &mdash; but the planner does care, and may optimize
    queries incorrectly if there are rows visible in the foreign table that
    do not satisfy a declared constraint.  If a constraint is violated when
    the user has declared that the constraint should hold true, it may be
    appropriate to raise an error (just as you would need to do in the case
    of a data type mismatch).
   </para>

   <para>
    <programlisting>
void
ReScanForeignScan (ForeignScanState *node);
    </programlisting>

    Recommence le parcours depuis le début. Notez que les paramètres
    dont dépent le parcours peuvent avoir changés de valeur, donc le
    nouveau parcours ne va pas forcément renvoyer les mêmes lignes.
   </para>

   <para>
    <programlisting>
void
EndForeignScan (ForeignScanState *node);
    </programlisting>

    Termine le parcours et relâche les ressources. Il n'est habituellement
    pas nécessaire de relâcher la mémoire allouée via palloc. Par contre,
    les fichiers ouverts et les connexions aux serveurs distants doivent
    être nettoyés.
   </para>

  </sect2>

   <sect2 id="fdw-callbacks-join-scan">
    <title>FDW Routines For Scanning Foreign Joins</title>

    <para>
     If an FDW supports performing foreign joins remotely (rather than
     by fetching both tables' data and doing the join locally), it should
     provide this callback function:
    </para>

    <para>
<programlisting>
void
GetForeignJoinPaths (PlannerInfo *root,
                     RelOptInfo *joinrel,
                     RelOptInfo *outerrel,
                     RelOptInfo *innerrel,
                     JoinType jointype,
                     JoinPathExtraData *extra);
</programlisting>
     Create possible access paths for a join of two (or more) foreign tables
     that all belong to the same foreign server.  This optional
     function is called during query planning.  As
     with <function>GetForeignPaths</function>, this function should
     generate <structname>ForeignPath</structname> path(s) for the
     supplied <literal>joinrel</literal>, and call <function>add_path</function> to add these
     paths to the set of paths considered for the join.  But unlike
     <function>GetForeignPaths</function>, it is not necessary that this function
     succeed in creating at least one path, since paths involving local
     joining are always possible.
    </para>

    <para>
     Note that this function will be invoked repeatedly for the same join
     relation, with different combinations of inner and outer relations; it is
     the responsibility of the FDW to minimize duplicated work.
    </para>

    <para>
     If a <structname>ForeignPath</structname> path is chosen for the join, it will
     represent the entire join process; paths generated for the component
     tables and subsidiary joins will not be used.  Subsequent processing of
     the join path proceeds much as it does for a path scanning a single
     foreign table.  One difference is that the <structfield>scanrelid</structfield> of
     the resulting <structname>ForeignScan</structname> plan node should be set to zero,
     since there is no single relation that it represents; instead,
     the <structfield>fs_relids</structfield> field of the <structname>ForeignScan</structname>
     node represents the set of relations that were joined.  (The latter field
     is set up automatically by the core planner code, and need not be filled
    by the FDW.)  Another difference is that, because the column list for a
     remote join cannot be found from the system catalogs, the FDW must
    fill <structfield>fdw_scan_tlist</structfield> with an appropriate list
    of <structfield>TargetEntry</structfield> nodes, representing the set of columns
    it will supply at run time in the tuples it returns.
   </para>

   <para>
    See <xref linkend="fdw-planning"/> for additional information.
   </para>

  </sect2>

  <sect2 id="fdw-callbacks-update">
   <title>Routines FDW pour la mise à jour des tables distantes</title>

   <para>
    Si un FDW supporte la modification des tables distantes, il doit fournir
    certaines ou toutes les fonctions callback suivant les besoins et les
    capacités du FDW&nbsp;:
   </para>

   <para>
    <programlisting>
void
AddForeignUpdateTargets (Query *parsetree,
                         RangeTblEntry *target_rte,
                         Relation target_relation);
    </programlisting>

    Les opérations <command>UPDATE</command> et <command>DELETE</command> sont
    réalisées contre des lignes précédemment récupérées par des fonctions de
    parcours de table. Le FDW peut avoir besoin d'informations supplémentaires,
    comme l'identifiant de la ligne ou les valeurs des colonnes formant la clé
    primaire pour s'assurer qu'il peut identifier la ligne exacte à mettre à
    jour ou à supprimer. Pour supporter cela, cette fonction peut ajouter des
    colonnes cibles supplémentaires cachées à la liste des colonnes qui doivent
    être récupérées de la table distante pendant une opération
    <command>UPDATE</command> ou <command>DELETE</command>.
   </para>

   <para>
    Pour faire cela, ajoutez les éléments <structname>TargetEntry</structname> à
    <literal>parsetree-&gt;targetList</literal>, contenant les expressions des
    valeurs supplémentaires à récupérer. Chacun de ces entrées doit être marquée
    <structfield>resjunk</structfield> = <literal>true</literal>, et doit avoir
    un <structfield>resname</structfield> distinct qui l'identifiera à
    l'exécution. Évitez d'utiliser des noms correspondant à
    <literal>ctid<replaceable>N</replaceable></literal>,
    <literal>wholerow</literal> ou
    <literal>wholerow<replaceable>N</replaceable></literal>, car le système peut
    générer des colonnes ayant ces noms.
   </para>

   <para>
    Cette fonction est appelé par le processus de réécriture, et non pas par
    le planificateur. Les informations disponibles sont un peu différentes de
    celles des routines de planification.
    <literal>parsetree</literal> est l'arbre d'analyse pour la commande
    <command>UPDATE</command> ou <command>DELETE</command> alors que
    <literal>target_rte</literal> et <literal>target_relation</literal>
    décrivent la table distante cible.
   </para>

   <para>
    Si le pointeur <function>AddForeignUpdateTargets</function> est initialisée
    à <literal>NULL</literal>, aucune expression cible supplémentaire ne sera
    ajoutée.
    (Ceci rend impossible l'implémentation des opérations
    <command>DELETE</command> bien que l'<command>UPDATE</command> est toujours
    faisable si le FDW se base sur une clé primaire ne changeant pas pour
    identifier les lignes.)
   </para>

   <para>
    <programlisting>
List *
PlanForeignModify (PlannerInfo *root,
                   ModifyTable *plan,
                   Index resultRelation,
                   int subplan_index);
    </programlisting>

    Réalise toute opération supplémentaire de planification nécessaire pour
    une insertion, mise à jour ou suppression sur une table distante. Cette
    fonction génère l'information privée du FDW qui sera attachée au n&oelig;ud
    du plan <structname>ModifyTable</structname> qui réalise la mise à jour.
    Cette information privée doit avoir la forme d'une
    <literal>List</literal>, et sera réalisée par
    <function>BeginForeignModify</function> lors de l'exécution.
   </para>

   <para>
    <literal>root</literal> est l'information globale du planificateur sur la
    requête.
    <literal>plan</literal> est le n&oelig;ud du plan
    <structname>ModifyTable</structname> qui est complet sauf pour le champ
    <structfield>fdwPrivLists</structfield>.
    <literal>resultRelation</literal> identifie la table distante cible par son
    index rangetable. <literal>subplan_index</literal> identifie la cible
    du n&oelig;ud de plan <structname>ModifyTable</structname> en comptant à
    partir de zéro&nbsp;; utilisez ceci si vous voulez indexer dans
    <literal>plan-&gt;plans</literal> ou toute autre sous-structure du n&oelig;ud
    <literal>plan</literal>.
   </para>

   <para>
    Voir <xref linkend="fdw-planning"/> pour plus d'informations.
   </para>

   <para>
    Si le pointeur <function>PlanForeignModify</function> est initialisée à
    <literal>NULL</literal>, aucune action supplémentaire n'est réalisée au
    moment de la planification, et la liste <literal>fdw_private</literal>
    renvoyée par <function>BeginForeignModify</function> vaudra NIL.
   </para>

   <para>
    <programlisting>
void
BeginForeignModify (ModifyTableState *mtstate,
                    ResultRelInfo *rinfo,
                    List *fdw_private,
                    int subplan_index,
                    int eflags);
    </programlisting>

    Commence l'exécution d'une opération de modification de la table distante.
    Cette routine est appelée lors du démarrage de l'exécuteur. Elle doit
    réaliser toute initialisation nécessaire avant de procéder aux modifications
    de la table. En conséquence, <function>ExecForeignInsert</function>,
    <function>ExecForeignUpdate</function> ou <function>ExecForeignDelete</function>
    seront appelées pour chaque ligne à insérer, mettre à jour ou supprimer.
   </para>

   <para>
    <literal>mtstate</literal> est l'état général du n&oelig;ud de plan
    <structname>ModifyTable</structname> en cours d'exécution&nbsp;; les
    données globales sur le plan et l'état d'exécution sont disponibles via
    cette structure.
    <literal>rinfo</literal> est la structure
    <structname>ResultRelInfo</structname> décrivant la table distante cible.
    (Le champ <structfield>ri_FdwState</structfield> de
    <structname>ResultRelInfo</structname> est disponible pour que le FDW
    enregistre tout état privé dont il aurait besoin pour réaliser cette
    opération.)
    <literal>fdw_private</literal> contient les données privées générées par
    <function>PlanForeignModify</function>.
    <literal>subplan_index</literal> identifie la cible du n&oelig;ud de
    plan <structname>ModifyTable</structname>.
    <literal>eflags</literal> contient les bits de drapeaux décrivant le mode
    opératoire de l'exécuteur pour ce n&oelig;ud de plan.
   </para>

   <para>
    Notez que quand <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal>
    est vrai, cette fonction ne devrait réaliser aucune action visible
    externe&nbsp;; il devrait seulement faire le minimum requis pour rendre
    l'état du n&oelig;ud valide pour
    <function>ExplainForeignModify</function> et
    <function>EndForeignModify</function>.
   </para>

   <para>
    Si le pointeur <function>BeginForeignModify</function> est initialisé à
    <literal>NULL</literal>, aucune action n'est prise lors du démarrage
    de l'exécuteur.
   </para>

   <para>
    <programlisting>
TupleTableSlot *
ExecForeignInsert (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);
    </programlisting>

    Insère une ligne dans la table distante.
    <literal>estate</literal> est un état global de l'exécution de la requête.
    <literal>rinfo</literal> est la structure <structname>ResultRelInfo</structname>
    décrivant la table distante cible.
    <literal>slot</literal> contient la ligne à insérer&nbsp;; ça correspondra
    à la définition du type de la ligne de la table distante.
    <literal>planSlot</literal> contient la ligne qui a été générée par le
    sous-plan du n&oelig;ud <structname>ModifyTable</structname>&nbsp;; cela
    diffère du <literal>slot</literal> qui contient aussi les colonnes
    supplémentaires.
    (Le <literal>planSlot</literal> a typiquement peu d'intérêt pour
    <command>INSERT</command> mais est fourni pour être complet.)
   </para>

   <para>
    La valeur de retour est soit un emplacement contenant les données
    effectivement insérées (elles peuvent différer des données fournies, par
    exemple le résultat de l'action de triggers), soit NULL si aucune ligne
    n'a été insérée (là-aussi typiquement le résultat d'un trigger). Le
    <literal>slot</literal> peut être ré-utilisé dans ce contexte.
   </para>

   <para>
    Les données dans l'emplacement renvoyé sont utilisées seulement si la
    requête <command>INSERT</command> a une clause <literal>RETURNING</literal>
    ou si la table distante a un trigger <literal>AFTER ROW</literal>. Les
    triggers requièrent toutes les colonnes mais le Foreign Data Wrapper
    pourrait choisir d'optimiser en ne renvoyant que certaines ou toutes les
    colonnes suivant le contenu de la clause <literal>RETURNING</literal>.
    Quoi qu'il en soit, un slot doit être renvoyé pour indiquer le succès.
    Dans le cas contraire, le nombre de lignes renvoyé par la requête sera
    mauvais.
   </para>

   <para>
    Si le pointeur <function>ExecForeignInsert</function> est initialisé à
    <literal>NULL</literal>, les tentatives d'insertion dans la table distante
    échoueront avec un message d'erreur.
   </para>

   <para>
    <programlisting>
TupleTableSlot *
ExecForeignUpdate (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);
    </programlisting>

    Met à jour une ligne dans la table distante.
    <literal>estate</literal> est l'état global de l'exécution de la requête.
    <literal>rinfo</literal> est la structure <structname>ResultRelInfo</structname>
    décrivant la table distante cible.
    <literal>slot</literal> contient les nouvelles données de la ligne&nbsp;;
    elles correspondront à la définition du type de ligne pour la table
    distante.
    <literal>planSlot</literal> contient la ligne qui a été générée par le
    sous-plan du n&oelig;ud <structname>ModifyTable</structname>&nbsp;; il
    diffère de <literal>slot</literal> car il peut contenir des colonnes
    supplémentaires. En particulier, toute colonne supplémentaire qui était
    réclamée par <function>AddForeignUpdateTargets</function> sera disponible
    à partir de cet emplacement.
   </para>

   <para>
    La valeur de retour est soit un emplacement contenant la nouvelle ligne
    modifiée (elle peut différer des données fournies suite, par exemple, à
    l'exécution d'un trigger), ou NULL si aucune ligne n'a été réellement
    mise à jour (là-encore typiquement l'action d'un trigger).
    L'emplacement <literal>slot</literal> fourni peut être réutilisé dans
    ce contexte.
   </para>

   <para>
    Les données renvoyées dans l'emplacement sont utilisées seulement si la
    requête <command>UPDATE</command> a une clause <literal>RETURNING</literal>
    ou si la table distante a un trigger <literal>AFTER ROW</literal>. Les
    triggers requièrent toutes les colonnes mais le Foreign Data Wrapper
    pourrait choisir d'optimiser en ne renvoyant que certaines ou toutes les
    colonnes suivant le contenu de la clause <literal>RETURNING</literal>.
    Quoi qu'il en soit, un slot doit être renvoyé pour indiquer le succès.
    Dans le cas contraire, le nombre de lignes renvoyé par la requête sera
    mauvais.
   </para>

   <para>
    Si le pointeur <function>ExecForeignUpdate</function> est initialisée à
    <literal>NULL</literal>, les tentatives de mise à jour de la table
    distante échoueront avec un message d'erreur.
   </para>

   <para>
    <programlisting>
TupleTableSlot *
ExecForeignDelete (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);
    </programlisting>

    Supprime une ligne de la table distante.
    <literal>estate</literal> est l'état global de l'exécution de la requête.
    <literal>rinfo</literal> est la structure <structname>ResultRelInfo</structname>
    décrivant la table distante cible.
    <literal>slot</literal> ne contient rien d'utile à l'appel de la fonction
    mais peut être utilisé pour contenir la ligne renvoyée.
    <literal>planSlot</literal> contient la ligne générée par le sous-plan du
    n&oelig;ud du plan <structname>ModifyTable</structname>&nbsp;; en particulier,
    elle contient toute colonne supplémentaire réclamée par
    <function>AddForeignUpdateTargets</function>. Les colonnes supplémentaires
    doivent être utilisées pour identifier la ligne à supprimer.
   </para>

   <para>
    The return value is either a slot containing the row that was deleted,
    or NULL if no row was deleted (typically as a result of triggers).  The
    passed-in <literal>slot</literal> can be used to hold the tuple to be returned.
   </para>

   <para>
    les données placées dans l'emplacement sont utilisées seulement si la
    requête <command>DELETE</command> dispose de la clause
    <literal>RETURNING</literal> or the foreign table has
    an <literal>AFTER ROW</literal> trigger.  Triggers require all columns, but the
    FDW could choose to optimize away returning some or all columns depending
    on the contents of the <literal>RETURNING</literal> clause.  Regardless, some
    slot must be returned to indicate success, or the query's reported row
    count will be wrong.
   </para>

   <para>
    Si le pointeur the <function>ExecForeignDelete</function> est initialisé à
    <literal>NULL</literal>, les tentatives de suppression dans la table
    distante échoueront avec un message d'erreur.
   </para>

   <para>
    <programlisting>
void
EndForeignModify (EState *estate,
                  ResultRelInfo *rinfo);
    </programlisting>

    Termine la mise à jour et libère les ressources. Il n'est normalement pas
    importante de libérer la mémoire prise avec palloc mais, par exemple, les
    fichiers ouverts et les connexions vers des serveurs distants doivent
    être nettoyés.
   </para>

   <para>
    Si le pointeur vers <function>EndForeignModify</function> est initialisé
    à <literal>NULL</literal>, aucune action n'a lieu pendant l'arrêt de
    l'exécuteur.
   </para>

   <para>
    <programlisting>
int
IsForeignRelUpdatable (Relation rel);
    </programlisting>

    Indique les opérations de mise à jour supportées par la table distante
    indiquée. La valeur de retour doit être un masque de bits correspondant
    aux numéros d'événement des règles, indiquant les opérations supportées
    par la table disante, en utilisant l'énumération <literal>CmdType</literal>.
    Autrement dit
    <literal>(1 &lt;&lt; CMD_UPDATE) = 4</literal> pour <command>UPDATE</command>,
    <literal>(1 &lt;&lt; CMD_INSERT) = 8</literal> pour <command>INSERT</command> et
    <literal>(1 &lt;&lt; CMD_DELETE) = 16</literal> pour <command>DELETE</command>.
   </para>

   <para>
    Si le pointeur <function>IsForeignRelUpdatable</function> est configuré à
    <literal>NULL</literal>, les tables distantes sont supposées accepter les
    INSERT, UPDATE et DELETE si le connecteur FDW fournit respectivement les
    fonctions <function>ExecForeignInsert</function>,
    <function>ExecForeignUpdate</function> et
    <function>ExecForeignDelete</function>. Cette fonction est uniquement
    nécessaire si le FDW supporte quelques tables modifiables et d'autres qui
    ne le sont pas. (Et même là, il est possible de renvoyer une erreur dans la
    routine d'exécution au lieu de vérifier avec cette fonction. Néanmoins, cette
    fonction est utilisé pour déterminer l'état modifiable des tables qui sera
    affiché dans les vues <literal>information_schema</literal>.)
   </para>

  </sect2>

   <sect2 id="fdw-callbacks-row-locking">
    <title>FDW Routines For Row Locking</title>

    <para>
     If an FDW wishes to support <firstterm>late row locking</firstterm> (as described
     in <xref linkend="fdw-row-locking"/>), it must provide the following
     callback functions:
    </para>

    <para>
<programlisting>
RowMarkType
GetForeignRowMarkType (RangeTblEntry *rte,
                       LockClauseStrength strength);
</programlisting>

     Report which row-marking option to use for a foreign table.
     <literal>rte</literal> is the <structname>RangeTblEntry</structname> node for the table
     and <literal>strength</literal> describes the lock strength requested by the
     relevant <literal>FOR UPDATE/SHARE</literal> clause, if any.  The result must be
     a member of the <literal>RowMarkType</literal> enum type.
    </para>

    <para>
     This function is called during query planning for each foreign table that
     appears in an <command>UPDATE</command>, <command>DELETE</command>, or <command>SELECT
     FOR UPDATE/SHARE</command> query and is not the target of <command>UPDATE</command>
     or <command>DELETE</command>.
    </para>

    <para>
     If the <function>GetForeignRowMarkType</function> pointer is set to
     <literal>NULL</literal>, the <literal>ROW_MARK_COPY</literal> option is always used.
     (This implies that <function>RefetchForeignRow</function> will never be called,
     so it need not be provided either.)
    </para>

    <para>
     See <xref linkend="fdw-row-locking"/> for more information.
    </para>

    <para>
<programlisting>
HeapTuple
RefetchForeignRow (EState *estate,
                   ExecRowMark *erm,
                   Datum rowid,
                   bool *updated);
</programlisting>

     Re-fetch one tuple from the foreign table, after locking it if required.
     <literal>estate</literal> is global execution state for the query.
     <literal>erm</literal> is the <structname>ExecRowMark</structname> struct describing
     the target foreign table and the row lock type (if any) to acquire.
     <literal>rowid</literal> identifies the tuple to be fetched.
     <literal>updated</literal> is an output parameter.
    </para>

    <para>
     This function should return a palloc'ed copy of the fetched tuple,
     or <literal>NULL</literal> if the row lock couldn't be obtained.  The row lock
     type to acquire is defined by <literal>erm-&gt;markType</literal>, which is the
     value previously returned by <function>GetForeignRowMarkType</function>.
     (<literal>ROW_MARK_REFERENCE</literal> means to just re-fetch the tuple without
     acquiring any lock, and <literal>ROW_MARK_COPY</literal> will never be seen by
     this routine.)
    </para>

    <para>
     In addition, <literal>*updated</literal> should be set to <literal>true</literal>
     if what was fetched was an updated version of the tuple rather than
     the same version previously obtained.  (If the FDW cannot be sure about
     this, always returning <literal>true</literal> is recommended.)
    </para>

    <para>
     Note that by default, failure to acquire a row lock should result in
     raising an error; a <literal>NULL</literal> return is only appropriate if
     the <literal>SKIP LOCKED</literal> option is specified
     by <literal>erm-&gt;waitPolicy</literal>.
    </para>

    <para>
     The <literal>rowid</literal> is the <structfield>ctid</structfield> value previously read
     for the row to be re-fetched.  Although the <literal>rowid</literal> value is
     passed as a <type>Datum</type>, it can currently only be a <type>tid</type>.  The
     function API is chosen in hopes that it may be possible to allow other
     data types for row IDs in future.
    </para>

    <para>
     If the <function>RefetchForeignRow</function> pointer is set to
     <literal>NULL</literal>, attempts to re-fetch rows will fail
     with an error message.
    </para>

    <para>
     See <xref linkend="fdw-row-locking"/> for more information.
    </para>

    <para>
<programlisting>
bool
RecheckForeignScan (ForeignScanState *node, TupleTableSlot *slot);
</programlisting>
     Recheck that a previously-returned tuple still matches the relevant
     scan and join qualifiers, and possibly provide a modified version of
     the tuple.  For foreign data wrappers which do not perform join pushdown,
     it will typically be more convenient to set this to <literal>NULL</literal> and
     instead set <structfield>fdw_recheck_quals</structfield> appropriately.
     When outer joins are pushed down, however, it isn't sufficient to
     reapply the checks relevant to all the base tables to the result tuple,
     even if all needed attributes are present, because failure to match some
     qualifier might result in some attributes going to NULL, rather than in
     no tuple being returned.  <literal>RecheckForeignScan</literal> can recheck
     qualifiers and return true if they are still satisfied and false
     otherwise, but it can also store a replacement tuple into the supplied
     slot.
    </para>

    <para>
     To implement join pushdown, a foreign data wrapper will typically
     construct an alternative local join plan which is used only for
     rechecks; this will become the outer subplan of the
     <literal>ForeignScan</literal>.  When a recheck is required, this subplan
     can be executed and the resulting tuple can be stored in the slot.
     This plan need not be efficient since no base table will return more
     than one row; for example, it may implement all joins as nested loops.
    </para>
   </sect2>

  <sect2 id="fdw-callbacks-explain">
   <title>Routines FDW pour <command>EXPLAIN</command></title>

   <para>
    <programlisting>
void
ExplainForeignScan (ForeignScanState *node,
                    ExplainState *es);
    </programlisting>

    Affiche une sortie <command>EXPLAIN</command> supplémentaire pour un
    parcours de table distante. Cette fonction peut faire appel à
    <function>ExplainPropertyText</function> et aux fonctions relatives pour
    ajouter des champs à la sortie d'<command>EXPLAIN</command>. Les champs
    drapeaux dans <literal>es</literal> peuvent être utilisés pour déterminer
    ce qui doit être affiché, et l'état du n&oelig;ud
    <structname>ForeignScanState</structname> peut être inspecté pour fournir
    des statistiques d'exécution dans le cas du <command>EXPLAIN
     ANALYZE</command>.
   </para>

   <para>
    Si le pointeur <function>ExplainForeignScan</function> vaut
    <literal>NULL</literal>, aucune information supplémentaire n'est affichée
    lors de l'<command>EXPLAIN</command>.
   </para>

   <para>
    <programlisting>
void
ExplainForeignModify (ModifyTableState *mtstate,
                      ResultRelInfo *rinfo,
                      List *fdw_private,
                      int subplan_index,
                      struct ExplainState *es);
    </programlisting>

    Affiche une sortie supplémentaire pour <command>EXPLAIN</command> lors
    de la mise à jour d'une table distante. Cette fonction peut appeler
    <function>ExplainPropertyText</function> et les fonctions en relation
    pour ajouter des champs à la sortie d'<command>EXPLAIN</command>. Les champs
    drapeaux de <literal>es</literal> peuvent être utilisés pour déterminer
    quoi afficher, et l'état du n&oelig;ud
    <structname>ModifyTableState</structname> peut être inspecté pour fournir
    des statistiques en exécution dans le cas du <command>EXPLAIN
     ANALYZE</command>. Les quatre premiers arguments sont les mêmes que pour
    <function>BeginForeignModify</function>.
   </para>

   <para>
    Si le pointeur <function>ExplainForeignModify</function> vaut
    <literal>NULL</literal>, aucune information supplémentaire n'est affichée
    lors de l'<command>EXPLAIN</command>.
   </para>

  </sect2>

  <sect2 id="fdw-callbacks-analyze">
   <title>Routines FDW pour <command>ANALYZE</command></title>

   <para>
    <programlisting>
bool
AnalyzeForeignTable (Relation relation,
                     AcquireSampleRowsFunc *func,
                     BlockNumber *totalpages);
    </programlisting>

    Cette fonction est appelée quand <xref linkend="sql-analyze"/> est exécuté
    sur une table distante. Si le wrapper de données distantes peut récupérer
    des statistiques pour cette table distante, il doit renvoyer
    <literal>true</literal>, et fournir un pointeur vers une fonction qui
    récupérera un échantillon de lignes à partir de la table dans
    <parameter>func</parameter>, ainsi que la taille estimée de la table en
    blocs dans <parameter>totalpages</parameter>. Sinon, il doit renvoyer
    <literal>false</literal>.
   </para>

   <para>
    Si le wrapper de données distantes ne supporte
    pas la récupération de statistiques quelque soit la table, le pointeur
    <function>AnalyzeForeignTable</function> doit être configuré à
    <literal>NULL</literal>.
   </para>

   <para>
    Si fourni, la fonction de récupération de l'échantillon doit avoir la
    signature suivante&nbsp;:
    <programlisting>
int
AcquireSampleRowsFunc (Relation relation, int elevel,
                       HeapTuple *rows, int targrows,
                       double *totalrows,
                       double *totaldeadrows);
    </programlisting>

    Un échantillon récupéré au hasard et comprenant au plus
    <parameter>targrows</parameter> lignes doit être récupéré à partir de la
    table et stocké dans le tableau <parameter>rows</parameter> fourni par
    l'appelant. Le nombre réel de lignes récupérées doit être renvoyé. De plus,
    les estimations du nombre total de lignes vivantes et mortes doivent être
    enregistrées dans les paramètres en sortie appelés
    <parameter>totalrows</parameter> et <parameter>totaldeadrows</parameter>.
    (Configurez <parameter>totaldeadrows</parameter> à zéro si le wrapper de
    données distantes ne connaît pas le concept des lignes mortes.)
   </para>

  </sect2>

   <sect2 id="fdw-callbacks-import">
    <title>FDW Routines For <command>IMPORT FOREIGN SCHEMA</command></title>

    <para>
<programlisting>
List *
ImportForeignSchema (ImportForeignSchemaStmt *stmt, Oid serverOid);
</programlisting>

     Obtain a list of foreign table creation commands.  This function is
     called when executing <xref linkend="sql-importforeignschema"/>, and is
     passed the parse tree for that statement, as well as the OID of the
     foreign server to use.  It should return a list of C strings, each of
     which must contain a <xref linkend="sql-createforeigntable"/> command.
     These strings will be parsed and executed by the core server.
    </para>

    <para>
     Within the <structname>ImportForeignSchemaStmt</structname> struct,
     <structfield>remote_schema</structfield> is the name of the remote schema from
     which tables are to be imported.
     <structfield>list_type</structfield> identifies how to filter table names:
     <literal>FDW_IMPORT_SCHEMA_ALL</literal> means that all tables in the remote
     schema should be imported (in this case <structfield>table_list</structfield> is
     empty), <literal>FDW_IMPORT_SCHEMA_LIMIT_TO</literal> means to include only
     tables listed in <structfield>table_list</structfield>,
     and <literal>FDW_IMPORT_SCHEMA_EXCEPT</literal> means to exclude the tables
     listed in <structfield>table_list</structfield>.
     <structfield>options</structfield> is a list of options used for the import process.
     The meanings of the options are up to the FDW.
     For example, an FDW could use an option to define whether the
     <literal>NOT NULL</literal> attributes of columns should be imported.
     These options need not have anything to do with those supported by the
     FDW as database object options.
    </para>

    <para>
     The FDW may ignore the <structfield>local_schema</structfield> field of
     the <structname>ImportForeignSchemaStmt</structname>, because the core server
     will automatically insert that name into the parsed <command>CREATE
     FOREIGN TABLE</command> commands.
    </para>

    <para>
     The FDW does not have to concern itself with implementing the filtering
     specified by <structfield>list_type</structfield> and <structfield>table_list</structfield>,
     either, as the core server will automatically skip any returned commands
     for tables excluded according to those options.  However, it's often
     useful to avoid the work of creating commands for excluded tables in the
     first place.  The function <function>IsImportableForeignTable()</function> may be
     useful to test whether a given foreign-table name will pass the filter.
    </para>

    <para>
     If the FDW does not support importing table definitions, the
     <function>ImportForeignSchema</function> pointer can be set to <literal>NULL</literal>.
    </para>

   </sect2>

 </sect1>

 <sect1 id="fdw-helpers">
  <title>Fonctions d'aide pour les wrapper de données distantes</title>

  <para>
   Plusieurs fonctions d'aide sont exportées à partir du cœur du serveur, pour
   que les auteurs de wrappers de données distantes puissent accéder facilement
   aux attributs des objets en relation avec les wrappers, comme par exemple les
   options d'un wrapper. Pour utiliser une de ces fonctions, vous avez besoin
   d'inclure le fichier en-tête <filename>foreign/foreign.h</filename> dans
   votre fichier source. Cet en-tête définit aussi les types de structures qui
   sont renvoyés par ces fonctions.
  </para>

  <para>
   <programlisting>
ForeignDataWrapper *
GetForeignDataWrapper(Oid fdwid);
   </programlisting>

   Cette fonction renvoie un objet <structname>ForeignDataWrapper</structname>
   pour le wrapper de données distantes de l'OID spécifié. Un objet
   <structname>ForeignDataWrapper</structname> contient les propriétés du
   wrapper (voir <filename>foreign/foreign.h</filename> pour les détails).
  </para>

  <para>
   <programlisting>
ForeignServer *
GetForeignServer(Oid serverid);
   </programlisting>

   Cette fonction renvoie un objet <structname>ForeignServer</structname>
   pour le serveur distant de l'OID donné. Un objet
   <structname>ForeignServer</structname> contient les propriétés du serveur
   (voir <filename>foreign/foreign.h</filename> pour les détails).
  </para>

  <para>
   <programlisting>
UserMapping *
GetUserMapping(Oid userid, Oid serverid);
   </programlisting>

   Cette fonction renvoie un objet <structname>UserMapping</structname> pour
   la correspondance utilisateur du rôle donné sur le serveur donné.
   (S'il n'existe pas de correspondance utilisateur, la fonction renvoie
   la correspondance pour <literal>PUBLIC</literal> ou une erreur si cette
   dernière n'existe pas non plus.) Un objet
   <structname>UserMapping</structname> contient les propriétés de la
   correspondance utilisateur (voir <filename>foreign/foreign.h</filename>
   pour les détails).
  </para>

  <para>
   <programlisting>
ForeignTable *
GetForeignTable(Oid relid);
   </programlisting>

   Cette fonction renvoie un objet <structname>ForeignTable</structname> pour
   la table distante de l'OID donné. Un objet
   <structname>ForeignTable</structname> contient les propriétés de la table
   distante (voir <filename>foreign/foreign.h</filename> pour les détails).
  </para>

  <para>
   <programlisting>
List *
GetForeignColumnOptions(Oid relid, AttrNumber attnum);
   </programlisting>

   Cette fonction renvoie les opérations du wrapper de données distantes par
   colonne pour l'OID de la table distante donnée et le numéro de l'attribut
   sous la forme d'une liste de <structname>DefElem</structname>. NIL est
   renvoyé sur la colonne n'a pas d'options.
  </para>

  <para>
   Certains types d'objets ont des fonctions de recherche basées sur le nom
   en plus de celles basées sur l'OID&nbsp;:
  </para>

  <para>
   <programlisting>
ForeignDataWrapper *
GetForeignDataWrapperByName(const char *name, bool missing_ok);
   </programlisting>

   Cette fonction renvoie un objet <structname>ForeignDataWrapper</structname>
   pour le wrapper de données distante du nom indiqué. Si le wrapper n'est pas
   trouvé, cette fonction renvoie NULL si missing_ok vaut true, et renvoie
   une erreur sinon.
  </para>

  <para>
   <programlisting>
ForeignServer *
GetForeignServerByName(const char *name, bool missing_ok);
   </programlisting>

   Cette fonction renvoie un objet <structname>ForeignServer</structname> pour
   le serveur distant du nom donné. Si le serveur n'est pas trouvé, cette
   fonction renvoie NULL si missing_ok vaut true, et renvoie une erreur sinon.
  </para>

 </sect1>

 <sect1 id="fdw-planning">
  <title>Planification de la requête avec un wrapper de données distantes</title>

  <para>
   Les fonctions d'appels d'un wrapper de données distantes, <function>GetForeignRelSize</function>,
   <function>GetForeignPaths</function>, <function>GetForeignPlan</function>
   <function>PlanForeignModify</function> et <function>GetForeignJoinPaths</function>
   doivent s'intégrer au fonctionnement du planificateur de
   <productname>PostgreSQL</productname>. Voici quelques notes sur ce qu'elles
   doivent faire.
  </para>

  <para>
   Les informations dans <literal>root</literal> et <literal>baserel</literal>
   peuvent être utilisées pour réduire la quantité d'informations qui doivent
   être récupérées sur la table distante (et donc réduire le coût)
   <literal>baserel-&gt;baserestrictinfo</literal> est tout particulièrement
   intéressant car il contient les qualificatifs de restriction (clauses
   <literal>WHERE</literal>) qui doivent être utilisées pour filtrer les lignes
   à récupérer. (Le wrapper lui-même n'est pas requis de respecter ces clauses
   car l'exécuteur du moteur peut les vérifier à sa place.)
   <literal>baserel-&gt;reltargetlist</literal> peut être utilisé pour
   déterminer les colonnes à récupérer&nbsp;; mais notez qu'il liste seulement
   les colonnes qui doivent être émises par le nœud
   <structname>ForeignScan</structname>, et non pas les colonnes qui sont
   utilisées pour satisfaire l'évaluation des qualificatifs et non renvoyées
   par la requête.
  </para>

  <para>
   Divers champs privés sont disponibles pour que les fonctions de planification
   du wrapper de données distantes conservent les informations. Habituellement,
   tout ce que vous stockez dans les champs privées doit avoir été alloué avec
   la fonction palloc, pour que l'espace soit récupéré à la fin de la
   planification.
  </para>

  <para>
   <literal>baserel-&gt;fdw_private</literal> est un pointeur <type>void</type>
   disponible pour que les fonctions de planification du wrapper y stockent
   des informations correspondant à la table distante spécifique. Le planificateur
   du moteur n'y touche pas sauf lors de son initialisation à NULL quand le
   nœud <literal>RelOptInfo</literal> est créé. Il est utile de passer des
   informations de <function>GetForeignRelSize</function> à
   <function>GetForeignPaths</function> et/ou <function>GetForeignPaths</function>
   à <function>GetForeignPlan</function>, évitant du coup un recalcul.
  </para>

  <para>
   <function>GetForeignPaths</function> peut identifier la signification de
   chemins d'accès différents pour enregistrer des informations privées dans
   le champ <structfield>fdw_private</structfield> des nœuds
   <structname>ForeignPath</structname>. <structfield>fdw_private</structfield>
   est déclaré comme un pointeur <type>List</type> mais peut contenir réellement
   n'importe quoi car le planificateur du moteur n'y touche pas. Néanmoins, une
   bonne pratique est d'utiliser une représentation qui est affichable par
   <function>nodeToString</function>, pour son utilisation avec le support du
   débogage disponible dans le processus.
  </para>

  <para>
   <function>GetForeignPlan</function> peut examiner le champ
   <structfield>fdw_private</structfield> du nœud
   <structname>ForeignPath</structname>, et peut générer les listes
   <structfield>fdw_exprs</structfield> et <structfield>fdw_private</structfield>
   à placer dans le nœud de plan <structname>ForeignScan</structname>, où
   elles seront disponibles au moment de l'exécution. Les deux listes doivent
   être représentées sous une forme que <function>copyObject</function> sait
   copier. La liste <structfield>fdw_private</structfield> n'a pas d'autres
   restrictions et n'est pas interprétée par le processus moteur. La liste
   <structfield>fdw_exprs</structfield>, si non NULL, devrait contenir
   les arbres d'expressions qui devront être exécutées. Ces arbres passeront
   par un post-traitement par le planificateur qui les rend complètement
   exécutables.
  </para>

  <para>
   Dans <function>GetForeignPlan</function>, habituellement, la liste cible
   fournie peut être copiée dans le nœud du plan tel quel. La liste
   <literal>scan_clauses</literal> fournie contient les mêmes clauses que
   <literal>baserel-&gt;baserestrictinfo</literal> mais ces clauses pourraient
   être ré-ordonnées pour une meilleure efficacité à l'exécution. Dans les cas
   simples, le wrapper peut seulement supprimer les nœuds
   <structname>RestrictInfo</structname> de la liste <literal>scan_clauses</literal> (en utilisant
   <function>extract_actual_clauses</function>) et placer toutes les clauses
   dans la liste des qualificatifs du nœud. Cela signifie que toutes les clauses
   seront vérifiées par l'exécuteur au moment de l'exécution. Les wrappers les
   plus complexes peuvent être capables de vérifier certaines clauses en interne,
   auquel cas ces clauses peuvent être supprimées de la liste de qualificatifs
   du nœud du plan pour que le planificateur ne perde pas de temps à les
   vérifier de nouveau.
  </para>

  <para>
   Comme exemple, le wrapper peut identifier certaines clauses de restriction
   de la forme <replaceable>variable_distante</replaceable> <literal>=</literal>
   <replaceable>sous_expression</replaceable>, qui, d'après lui, peut être
   exécuté sir le serveur distant en donnant la valeur évaluée localement de
   la <replaceable>sous_expression</replaceable>. L'identification réelle d'une
   telle clause doit survenir lors de l'exécution de
   <function>GetForeignPaths</function> car cela va affecter l'estimation ddu
   coût pour le chemin. Le champ <structfield>fdw_private</structfield> du
   chemin pourrait probablement inclure un pointeur vers le nœud
   <structname>RestrictInfo</structname> de la clause identifiée. Puis,
   <function>GetForeignPlan</function> pourrait supprimer cette clause de
   scan_clauses et ajouter la <replaceable>sous_expression</replaceable> à
   <structfield>fdw_exprs</structfield> pour s'assurer qu'elle soit convertie
   en une forme exécutable. Il pourrait aussi placer des informations de contrôle
   dans le champ <structfield>fdw_private</structfield> du nœud pour dire aux
   fonctions d'exécution ce qu'il faudra faire au moment de l'exécution. La
   requête transmise au serveur distant va impliquer quelque chose comme
   <literal>WHERE <replaceable>variable_distante</replaceable> =
    $1</literal>, avec la valeur du paramètre obtenu à l'exécution à partir de
   l'évaluation de l'arbre d'expression <structfield>fdw_exprs</structfield>.
  </para>

  <para>
     Any clauses removed from the plan node's qual list must instead be added
     to <literal>fdw_recheck_quals</literal> or rechecked by
     <literal>RecheckForeignScan</literal> in order to ensure correct behavior
     at the <literal>READ COMMITTED</literal> isolation level.  When a concurrent
     update occurs for some other table involved in the query, the executor
     may need to verify that all of the original quals are still satisfied for
     the tuple, possibly against a different set of parameter values.  Using
     <literal>fdw_recheck_quals</literal> is typically easier than implementing checks
     inside <literal>RecheckForeignScan</literal>, but this method will be
     insufficient when outer joins have been pushed down, since the join tuples
     in that case might have some fields go to NULL without rejecting the
     tuple entirely.
    </para>

    <para>
     Another <structname>ForeignScan</structname> field that can be filled by FDWs
     is <structfield>fdw_scan_tlist</structfield>, which describes the tuples returned by
     the FDW for this plan node.  For simple foreign table scans this can be
     set to <literal>NIL</literal>, implying that the returned tuples have the
     row type declared for the foreign table.  A non-<symbol>NIL</symbol> value must be a
     target list (list of <structname>TargetEntry</structname>) containing Vars and/or
     expressions representing the returned columns.  This might be used, for
     example, to show that the FDW has omitted some columns that it noticed
     won't be needed for the query.  Also, if the FDW can compute expressions
     used by the query more cheaply than can be done locally, it could add
     those expressions to <structfield>fdw_scan_tlist</structfield>.  Note that join
     plans (created from paths made by <function>GetForeignJoinPaths</function>) must
     always supply <structfield>fdw_scan_tlist</structfield> to describe the set of
     columns they will return.
    </para>

    <para>
   Le wrapper de données distantes devrait toujours construire au moins un
   chemin qui dépend seulement des clauses de restriction de la table. Dans
   les requêtes de jointure, il pourrait aussi choisir de construire des
   chemins qui dépendent des clauses de jointures. Par exemple,
   <replaceable>variable_distante</replaceable> <literal>=</literal>
   <replaceable>variable_local</replaceable>. De telles clauses ne se trouveront
   pas dans <literal>baserel-&gt;baserestrictinfo</literal> mais doivent être
   dans les listes de jointures des relations. Un chemin utilisant une telle
   clause est appelé un <quote>parameterized path</quote>. Il doit identifier
   les autres relations utilisées dans le(s) clause(s) de jointure
   sélectionnée(s) avec une valeur convenable pour
   <literal>param_info</literal>&nbsp;; utilisez
   <function>get_baserel_parampathinfo</function> pour calculer cette valeur.
   Dans <function>GetForeignPlan</function>, la portion
   <replaceable>local_variable</replaceable> de la clause de jointure pourra être
   ajoutée à <structfield>fdw_exprs</structfield>, et ensuite à l'exécution, cela
   fonctionne de la même façon que pour une clause de restriction standard.
  </para>

  <para>
     If an FDW supports remote joins, <function>GetForeignJoinPaths</function> should
     produce <structname>ForeignPath</structname> for potential remote joins in much
     the same way as <function>GetForeignPaths</function> works for base tables.
     Information about the intended join can be passed forward
     to <function>GetForeignPlan</function> in the same ways described above.
     However, <structfield>baserestrictinfo</structfield> is not relevant for join
     relations; instead, the relevant join clauses for a particular join are
     passed to <function>GetForeignJoinPaths</function> as a separate parameter
     (<literal>extra-&gt;restrictlist</literal>).
    </para>

    <para>
   Lors de la planification d'un <command>UPDATE</command> ou d'un
   <command>DELETE</command>, <function>PlanForeignModify</function> peut
   rechercher la structure <structname>RelOptInfo</structname> pour la table
   distante et utiliser la donnée
   <literal>baserel-&gt;fdw_private</literal> créée précédemment par les
   fonctions de planification de parcours. Néanmoins, pour un
   <command>INSERT</command>, la table cible n'est pas parcourue, donc il
   n'existe aucun <structname>RelOptInfo</structname> pour elle.
   La structure <structname>List</structname> renvoyée par
   <function>PlanForeignModify</function> a les mêmes restrictions que la liste
   <structfield>fdw_private</structfield> d'un n&oelig;ud de plan
   <structname>ForeignScan</structname>, c'est-à-dire qu'elle doit contenir
   seulement les structures que <function>copyObject</function> sait copier.
  </para>

  <para>
     <command>INSERT</command> with an <literal>ON CONFLICT</literal> clause does not
     support specifying the conflict target, as unique constraints or
     exclusion constraints on remote tables are not locally known. This
     in turn implies that <literal>ON CONFLICT DO UPDATE</literal> is not supported,
     since the specification is mandatory there.
    </para>

   </sect1>

   <sect1 id="fdw-row-locking">
    <title>Row Locking in Foreign Data Wrappers</title>

    <para>
     If an FDW's underlying storage mechanism has a concept of locking
     individual rows to prevent concurrent updates of those rows, it is
     usually worthwhile for the FDW to perform row-level locking with as
     close an approximation as practical to the semantics used in
     ordinary <productname>PostgreSQL</productname> tables.  There are multiple
     considerations involved in this.
    </para>

    <para>
     One key decision to be made is whether to perform <firstterm>early
     locking</firstterm> or <firstterm>late locking</firstterm>.  In early locking, a row is
     locked when it is first retrieved from the underlying store, while in
     late locking, the row is locked only when it is known that it needs to
     be locked.  (The difference arises because some rows may be discarded by
     locally-checked restriction or join conditions.)  Early locking is much
     simpler and avoids extra round trips to a remote store, but it can cause
     locking of rows that need not have been locked, resulting in reduced
     concurrency or even unexpected deadlocks.  Also, late locking is only
     possible if the row to be locked can be uniquely re-identified later.
     Preferably the row identifier should identify a specific version of the
     row, as <productname>PostgreSQL</productname> TIDs do.
    </para>

    <para>
     By default, <productname>PostgreSQL</productname> ignores locking considerations
     when interfacing to FDWs, but an FDW can perform early locking without
     any explicit support from the core code.  The API functions described
     in <xref linkend="fdw-callbacks-row-locking"/>, which were added
     in <productname>PostgreSQL</productname> 9.5, allow an FDW to use late locking if
     it wishes.
    </para>

    <para>
     An additional consideration is that in <literal>READ COMMITTED</literal>
     isolation mode, <productname>PostgreSQL</productname> may need to re-check
     restriction and join conditions against an updated version of some
     target tuple.  Rechecking join conditions requires re-obtaining copies
     of the non-target rows that were previously joined to the target tuple.
     When working with standard <productname>PostgreSQL</productname> tables, this is
     done by including the TIDs of the non-target tables in the column list
     projected through the join, and then re-fetching non-target rows when
     required.  This approach keeps the join data set compact, but it
     requires inexpensive re-fetch capability, as well as a TID that can
     uniquely identify the row version to be re-fetched.  By default,
     therefore, the approach used with foreign tables is to include a copy of
     the entire row fetched from a foreign table in the column list projected
     through the join.  This puts no special demands on the FDW but can
     result in reduced performance of merge and hash joins.  An FDW that is
     capable of meeting the re-fetch requirements can choose to do it the
     first way.
    </para>

    <para>
     For an <command>UPDATE</command> or <command>DELETE</command> on a foreign table, it
     is recommended that the <literal>ForeignScan</literal> operation on the target
     table perform early locking on the rows that it fetches, perhaps via the
     equivalent of <command>SELECT FOR UPDATE</command>.  An FDW can detect whether
     a table is an <command>UPDATE</command>/<command>DELETE</command> target at plan time
     by comparing its relid to <literal>root-&gt;parse-&gt;resultRelation</literal>,
     or at execution time by using <function>ExecRelationIsTargetRelation()</function>.
     An alternative possibility is to perform late locking within the
     <function>ExecForeignUpdate</function> or <function>ExecForeignDelete</function>
     callback, but no special support is provided for this.
    </para>

    <para>
     For foreign tables that are specified to be locked by a <command>SELECT
     FOR UPDATE/SHARE</command> command, the <literal>ForeignScan</literal> operation can
     again perform early locking by fetching tuples with the equivalent
     of <command>SELECT FOR UPDATE/SHARE</command>.  To perform late locking
     instead, provide the callback functions defined
     in <xref linkend="fdw-callbacks-row-locking"/>.
     In <function>GetForeignRowMarkType</function>, select rowmark option
     <literal>ROW_MARK_EXCLUSIVE</literal>, <literal>ROW_MARK_NOKEYEXCLUSIVE</literal>,
     <literal>ROW_MARK_SHARE</literal>, or <literal>ROW_MARK_KEYSHARE</literal> depending
     on the requested lock strength.  (The core code will act the same
     regardless of which of these four options you choose.)
     Elsewhere, you can detect whether a foreign table was specified to be
     locked by this type of command by using <function>get_plan_rowmark</function> at
     plan time, or <function>ExecFindRowMark</function> at execution time; you must
     check not only whether a non-null rowmark struct is returned, but that
     its <structfield>strength</structfield> field is not <literal>LCS_NONE</literal>.
    </para>

    <para>
     Lastly, for foreign tables that are used in an <command>UPDATE</command>,
     <command>DELETE</command> or <command>SELECT FOR UPDATE/SHARE</command> command but
     are not specified to be row-locked, you can override the default choice
     to copy entire rows by having <function>GetForeignRowMarkType</function> select
     option <literal>ROW_MARK_REFERENCE</literal> when it sees lock strength
     <literal>LCS_NONE</literal>.  This will cause <function>RefetchForeignRow</function> to
     be called with that value for <structfield>markType</structfield>; it should then
     re-fetch the row without acquiring any new lock.  (If you have
     a <function>GetForeignRowMarkType</function> function but don't wish to re-fetch
     unlocked rows, select option <literal>ROW_MARK_COPY</literal>
     for <literal>LCS_NONE</literal>.)
    </para>

    <para>
     See <filename>src/include/nodes/lockoptions.h</filename>, the comments
     for <type>RowMarkType</type> and <type>PlanRowMark</type>
     in <filename>src/include/nodes/plannodes.h</filename>, and the comments for
     <type>ExecRowMark</type> in <filename>src/include/nodes/execnodes.h</filename> for
     additional information.
  </para>

 </sect1>

</chapter>
