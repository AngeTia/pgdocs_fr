<?xml version="1.0" encoding="UTF-8"?>
<!-- doc/src/sgml/archive-modules.sgml -->

<chapter id="archive-modules">
 <title>Modules d'archivage</title>
 <indexterm zone="archive-modules">
  <primary>Modules d'archivage</primary>
 </indexterm>

 <para>
  PostgreSQL fourni l'infrastructure nécessaire à la création de modules
  personnalisés pour l'archivage continu (voir
  <xref linkend="continuous-archiving"/>). Alors que l'archivage via une
  commande shell (par exemple, <xref linkend="guc-archive-command"/>) est bien
  plus simple, un module d'archivage personnalisé sera souvent considéré plus
  robuste et plus performant.
 </para>

 <para>
  Quand un <xref linkend="guc-archive-library"/> personnalisé est configuré,
  PostgreSQL soumettra les fichiers segment WAL complets au module, et le
  serveur évitera de recycler ou supprimer ces fichiers segment WAL jusqu'à ce
  que le module indique qu'ils ont été archivé avec succès. C'est au final au
  module de décider quoi faire avec chaque fichier segment WAL, mais de
  nombreuses recommandations sont listées sur
  <xref linkend="backup-archiving-wal"/>.
 </para>

 <para>
  Les modules d'archivage doivent au moins comporter une fonction
  d'initialisation (voir <xref linkend="archive-module-init"/>) ainsi que les
  callbacks requis (voir <xref linkend="archive-module-callbacks"/>). Cependant,
  les modules d'archivage peuvent également faire bien plus (par exemple,
  déclarer des paramètres GUCs et démarrer des processus d'arrière plan).
 </para>

 <para>
  Le module <filename>contrib/basic_archive</filename> contient un exemple
  fonctionnel, qui démontre quelques techniques utiles.
 </para>

 <sect1 id="archive-module-init">
  <title>Fonctions d'initialisation</title>
  <indexterm zone="archive-module-init">
   <primary>_PG_archive_module_init</primary>
  </indexterm>
  <para>
   Une librairie d'archivage est chargée en appelant dynamiquement une librairie
   partagée dont le nom de base est fourni par
   <xref linkend="guc-archive-library"/>. Le chemin de cherche de librairie
   habituel est utilisé pour localiser cette librairie. Pour fournir les
   callbacks nécessaires au module d'archivage et pour indiquer que la librairie
   est en fait un module d'archivage, une fonction
   <function>_PG_archive_module_init</function> doit y être fournie. Cette
   fonction reçoit une structure définie par les pointeurs des fonctions de
   callback pour chaque action individuelle.

<programlisting>
typedef struct ArchiveModuleCallbacks
{
    ArchiveCheckConfiguredCB check_configured_cb;
    ArchiveFileCB archive_file_cb;
    ArchiveShutdownCB shutdown_cb;
} ArchiveModuleCallbacks;
typedef void (*ArchiveModuleInit) (struct ArchiveModuleCallbacks *cb);
</programlisting>

   Seulement le callback <function>archive_file_cb</function> est requis. Les
   autres sont optionnels.
  </para>
 </sect1>

 <sect1 id="archive-module-callbacks">
  <title>Callbacks d'un module d'archivage</title>
  <para>
   Les callbacks d'archivage définissent le comportement d'archivage proprement
   dit du module. Le serveur les appellera comme requis pour traiter chaque
   fichier segment WAL individuellement.
  </para>

  <sect2 id="archive-module-check">
   <title>Callback de vérification</title>
   <para>
    Le callback <function>check_configured_cb</function> is appelé pour
    déterminer si le module est pleinement configuré et prêt à traiter des
    fichiers segment WAL (par exemple, si ses paramètres de configuration sont
    définis avec des valeurs valides). Si la fonction
    <function>check_configured_cb</function>  n'est pas définie, le serveur
    présumera que le module est configuré.

<programlisting>
typedef bool (*ArchiveCheckConfiguredCB) (void);
</programlisting>

    Si <literal>true</literal> est renvoyé, le serveur procédera à l'archivage
    en appelant le callback <function>archive_file_cb</function>. Si
    <literal>false</literal> est renvoyé, l'archivage ne sera pas effectué, et
    l'archiver émettra le message suivant dans les traces du serveur:
<screen>
WARNING:  archive_mode activé, cependant archive_command n'est pas configuré
</screen>
    Dans ce dernier cas, le serveur appellera périodiquement cette fonction, et
    l'archivage ne sera effectué que lorsque <literal>true</literal> sera
    renvoyé.
   </para>
  </sect2>

  <sect2 id="archive-module-archive">
   <title>Callback d'archivage</title>
   <para>
    Le callback <function>archive_file_cb</function> est appelé pour archiver un
    seul fichier segment WAL.

<programlisting>
typedef bool (*ArchiveFileCB) (const char *file, const char *path);
</programlisting>

    Si <literal>true</literal> est renvoyé, le serveur procédera comme si le
    fichier était archivé avec succès, ce qui peut inclure recycler ou supprimer
    le fichier segment WAL original. Si <literal>false</literal> est renvoyé, le
    serveur conservera le fichier segment WAL original et réessayera de
    l'archiver plus tard.
    <literal>file</literal> contiendra juste le nom du fichier du segment WAL à
    archiver, alors que <literal>path</literal> contiendra le chemin complet du
    fichier segment WAL (nom du fichier inclus).
   </para>
  </sect2>

  <sect2 id="archive-module-shutdown">
   <title>Callback d'arrêt</title>
   <para>
    Le callback <function>shutdown_cb</function> est appelé quand le processus
    archiver s'arrête (par exemple, après une erreur) ou si la valeur de
    <xref linkend="guc-archive-library"/> change. Si la fonction
    <function>shutdown_cb</function> n'est pas définie, aucune action spécifique
    ne sera entreprise lors de ces situations.

<programlisting>
typedef void (*ArchiveShutdownCB) (void);
</programlisting>
   </para>
  </sect2>
 </sect1>
</chapter>
