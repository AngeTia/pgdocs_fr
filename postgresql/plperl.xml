<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

 <chapter id="plperl">
  <title>PL/Perl - Langage de procédures Perl</title>

  <indexterm zone="plperl">
   <primary>PL/Perl</primary>
  </indexterm>

  <indexterm zone="plperl">
   <primary>Perl</primary>
  </indexterm>

  <para>
   PL/Perl est un langage de procédures chargeable qui vous permet d'écrire des
   fonctions <productname>PostgreSQL</productname> dans le <ulink
   url="http://www.perl.org">langage de programmation Perl</ulink>.
  </para>

  <para>
   Le principal avantage habituellement cité quant à l'utilisation de Perl est que cela
   permet l'utilisation des nombreux opérateurs et fonctions de <quote>gestion
   de chaînes</quote> disponibles grâce à Perl dans des procédures stockées.
   L'analyse de chaînes complexes se trouve facilité par l'utilisation de Perl
   et des fonctions et structures de contrôles fournies dans PL/pgSQL.
  </para>
  
  <para>
   Pour installer PL/Perl dans une base de données spécifique, utilisez la
   commande <literal>createlang plperl <replaceable>nom_base</replaceable></literal>.
  </para>

  <tip>
   <para>
    Si un langage est installé dans <literal>template1</literal>, toutes les
    bases de données créées ultérieurement disposeront automatiquement de ce
    langage.
   </para>
  </tip>

  <note>
   <para>
    Les utilisateurs des paquetages sources doivent explicitement autoriser la
    construction de PL/Perl pendant le processus d'installation (se référer à
    la <xref linkend="install-short"/> pour plus d'informations). Les utilisateurs
    des paquetages binaires peuvent trouver PL/Perl dans un sous-paquetage
    séparé.
   </para>
  </note>

 <sect1 id="plperl-funcs">
  <title>Fonctions et arguments PL/Perl</title>

  <para>
   Pour créer une fonction dans le langage PL/Perl, utilisez la syntaxe
   standard <xref linkend="sql-createfunction"/>&nbsp;:
<programlisting>CREATE FUNCTION <replaceable>nom_fonction</replaceable> (<replaceable>types-arguments</replaceable>) RETURNS
<replaceable>type-retour</replaceable> AS $$
    # Corps de la fonction PL/Perl
$$ LANGUAGE plperl;
</programlisting>
   Le corps de la fonction est du code Perl normal. En fait, le code
   supplémentaire PL/Perl l'emballe dans une sous-routine Perl. Une fonction
   PL/Perl est appelée dans un contexte scalaire, il ne peut donc pas retourner 
   une liste. Vous pouvez retourner des valeurs non scalaire par référence comme
   indiqué ci-dessous.
  </para>

  <para>
   PL/Perl peut aussi être utilisé au sein de blocs de procédures anonymes avec 
   l'ordre <xref linkend="sql-do"/> :

<programlisting>
DO $$
    # PL/Perl code
$$ LANGUAGE plperl;
</programlisting>

   Un bloc de procédure anonyme ne prend pas d'arguments et toute valeur 
   retourné est ignorée. Ceci mis à part, il se comporte comme une fonction 
   classique.
  </para>

  <note>
   <para>
    L'utilisation de sous-routines nommées est dangereux en Perl, spécialement
    si elles font références à des variables lexicales dans la partie
    englobante. Comme une fonction PL/Perl est englobée dans une sous-routine,
    toute sous-routine nommée que vous y créez 
    sera englobée. En général, il est bien plus sûr de créer des sous-routines anonymes
    que vous appellerez via un coderef. Pour de plus amples détails, voir 
    les entrées <literal>Variable "%s" will not stay shared</literal> et
    <literal>Variable "%s" is not available</literal> dans le manuel
    <citerefentry><refentrytitle>perldiag</refentrytitle></citerefentry>, ou
    recherchez <quote>perl nested named subroutine</quote> sur internet.
   </para>
  </note>

  <para>
    La syntaxe de la commande <command>CREATE FUNCTION</command> requiert que le
    corps de la fonction soit écrit comme une constante de type chaîne. Il est
    habituellement plus agréable d'utiliser les guillemets dollar (voir la <xref
    linkend="sql-syntax-dollar-quoting"/>) pour cette constante. Si vous
    choisissez d'utiliser la syntaxe d'échappement des chaînes <literal>E''</literal>,
    vous devez doubler les marques de guillemets simples (<literal>'</literal>)
    et les antislashs (<literal>\</literal>) utilisés dans le corps de la
    fonction (voir la <xref linkend="sql-syntax-strings"/>).
  </para>

  <para>
   Les arguments et les résultats sont manipulés comme dans n'importe quel
   routine Perl&nbsp;: les arguments sont passés au tableau
   <varname>@_</varname> et une valeur de retour
   est indiquée par <literal>return</literal> ou par la dernière expression
   évaluée dans la fonction.
  </para>

  <para>
   Par exemple, une fonction retournant le plus grand de deux entiers
   peut être définie comme suit&nbsp;:

<programlisting>CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    if ($_[0] &gt; $_[1]) { return $_[0]; }
    return $_[1];
$$ LANGUAGE plperl;
</programlisting>
  </para>

  <para>
   Si une valeur NULL en SQL<indexterm><primary>valeur NULL</primary><secondary
   sortas="PL/Perl">en PL/Perl</secondary></indexterm> est passée à une fonction,
   cet argument apparaîtra comme <quote>undefined</quote> en Perl. La
   fonction définie ci-dessus ne se comportera pas correctement avec des
   arguments NULL (en fait, tout se passera comme s'ils avaient été des zéros).
   Nous aurions pu ajouter <literal>STRICT</literal> à la définition de la fonction
   pour forcer <productname>PostgreSQL</productname> à faire quelque chose de
   plus raisonnable&nbsp;: si une valeur NULL est passée en argument, la
   fonction ne sera pas du tout appelée mais retournera automatiquement un
   résultat NULL. D'une autre façon, nous aurions pu vérifier dans le corps de
   la fonction la présence d'arguments NULL. Par exemple, supposons que nous
   voulions que <function>perl_max</function> avec un argument NULL et un autre
   non NULL retourne une valeur non NULL plutôt qu'une valeur NULL, on aurait
   écrit&nbsp;:

<programlisting>CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    my ($x, $y) = @_;
    if (not defined $x) {
        return undef if not defined $y;
        return $y;
    }
    return $x if not defined $y;
    return $x if $x &gt; $y;
    return $y;
$$ LANGUAGE plperl;
</programlisting>
   Comme le montre l'exemple ci-dessus, passer une valeur NULL en SQL
   à une fonction en PL/Perl retourne une valeur non définie. Et ceci,
   que la fonction soit déclarée stricte ou non.
  </para>

  <para>
   Dans un argument de fonction, tout ce qui n'est pas une référence est une
   chaîne qui est dans la représentation texte externe standard de
   <productname>PostgreSQL</productname> pour ce type de données. Dans le cas
   de types numériques ou texte, Perl fera ce qu'il faut et le programmeur
   n'aura pas à s'en soucier. Néanmoins, dans d'autres cas, l'argument aura
   besoin d'être converti dans une forme qui est plus utilisable que Perl.
   Par exemple, la fonction <function>decode_bytea</function> peut-être utilisée
   pour convertir un argument de type 
   <type>bytea</type> en données binaires non échappées.
  </para>

  <para>
   De façon similaire, les valeurs renvoyées à
   <productname>PostgreSQL</productname> doivent être dans le format textuel.
   Par exemple, 
   la fonction <function>encode_bytea</function> peut être utilisée
   pour échapper des données binaires en retournant une valeur de type <type>bytea</type>.
  </para>

  <para>
   Perl peut renvoyer des tableaux <productname>PostgreSQL</productname>
   comme référence à des tableaux Perl. Voici un exemple&nbsp;:

<programlisting>CREATE OR REPLACE function renvoit_tableau()
RETURNS text[][] AS $$
    return [['a&quot;b','c,d'],['e\\f','g']];
$$ LANGUAGE plperl;

select renvoit_tableau();
</programlisting>
  </para>

  <para>
   Les arguments de type composite sont passés à la fonction en tant que
   références d'un tableau de découpage, les clés du tableau de découpage étant
   les noms des attributs du type composé. Voici un exemple&nbsp;:

<programlisting>CREATE TABLE employe (
    nom text,
    basesalaire integer,
    bonus integer
);

CREATE FUNCTION empcomp(employe) RETURNS integer AS $$
    my ($emp) = @_;
    return $emp-&gt;{basesalaire} + $emp-&gt;{bonus};
$$ LANGUAGE plperl;

SELECT nom, empcomp(employe.*) FROM employe;
</programlisting>
  </para>

  <para>
   Une fonction PL/Perl peut renvoyer un résultat de type composite en utilisant
   la même approche&nbsp;: renvoyer une référence à un hachage qui a les 
   attributs requis. Par exemple&nbsp;

    <programlisting>      CREATE TYPE testligneperl AS (f1 integer, f2 text, f3 text);

      CREATE OR REPLACE FUNCTION perl_ligne() RETURNS test_ligne_perl AS $$
      return {f2 =&gt; 'hello', f1 =&gt; 1, f3 =&gt; 'world'};
      $$ LANGUAGE plperl;

      SELECT * FROM perl_row();
    </programlisting>

    Toute colonne dans le type de données déclaré du résultat qui n'est pas
    présente dans le hachage sera renvoyée NULL.
  </para>

  <para>
    Les fonctions PL/Perl peuvent aussi renvoyer des ensembles de types
    scalaires ou composites. Habituellement, vous voulez renvoyer une ligne à
    la fois, à la fois pour améliorer le temps de démarrage et pour éviter
    d'allonger la queue de l'ensemble des résultats en mémoire. Vous pouvez
    faire ceci avec <function>return_next</function> comme indiqué ci-dessous.
    Notez qu'après le dernier <function>return_next</function>, vous devez
    placer soit <literal>return</literal> soit (encore mieux) <literal>return
    undef</literal>.

<programlisting>CREATE OR REPLACE FUNCTION perl_set_int(int)
RETURNS SETOF INTEGER AS $$
    foreach (0..$_[0]) {
        return_next($_);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set()
RETURNS SETOF test_ligne_perl AS $$
    return_next({ f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' });
    return_next({ f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' });
    return_next({ f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' });
    return undef;
$$ LANGUAGE plperl;
</programlisting>

    Pour les petits ensembles de résultats, vous pouvez renvoyer une référence
    à un tableau contenant soit des scalaires, soit des références à des
    tableaux soit des références à des hachages de types simples, de types
    tableaux ou de types composites. Voici quelques exemples simples pour
    renvoyer l'ensemble complet du résultant en tant que référence de
    tableau&nbsp;:

    <programlisting>CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS $$
      return [0..$_[0]];
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testligneperl AS $$
return [
      { f1 =&gt; 1, f2 =&gt; 'Bonjour', f3 =&gt; 'Monde' },
      { f1 =&gt; 2, f2 =&gt; 'Bonjour', f3 =&gt; 'PostgreSQL' },
      { f1 =&gt; 3, f2 =&gt; 'Bonjour', f3 =&gt; 'PL/Perl' }
      ];
$$  LANGUAGE plperl;

SELECT * FROM perl_set();</programlisting>

  </para>

  <para>
   Si vous souhaitez utiliser le pragma <literal>strict</literal> dans votre code,
   vous avez plusieurs options. Pour une utilisation temporaire globale vous pouvez positionner (<command>SET</command>)
   <literal>plperl.use_strict</literal> à « true ». Ce paramètre affectera les
   compilations suivantes de fonctions <application>PL/Perl</application>, mais
   pas les fonctions déjà compilées dans la session en cours.
   Pour une utilisation globale permanente, vous pouvez positionner <literal>plperl.use_strict</literal>
   à « true » dans le fichier <filename>postgresql.conf</filename>.
  </para>

  <para>
   Pour une utilisation permanente dans des fonctions spécifiques, vous pouvez simplement placer:
<programlisting>use strict;
</programlisting>
   en haut du corps de la fonction.
  </para>
  
  <para>
  Le pragma <literal>feature</literal> est aussi disponible avec <function>use</function> si votre version de Perl est 5.10.0 ou supérieur.
  </para>
 </sect1>

 <sect1 id="plperl-data">
  <title>Valeurs en PL/Perl</title>

  <para>
   Les valeurs des arguments fournis au code d'une fonction PL/Perl sont
   simplement les arguments d'entrée convertis en tant que texte (comme s'ils 
   avaient été affichés par une commande <command>SELECT</command>).
   Inversement, les commandes <function>return</function> and <function>return_next</function>
   accepterons toute chaîne qui a un format d'entrée acceptable
   pour le type de retour déclaré de la fonction.
  </para>
 </sect1>

 <sect1 id="plperl-builtins">
  <title>Fonction incluses</title>

 <sect2 id="plperl-database">
  <title>Accès à la base de données depuis PL/Perl</title>

  <para>
   L'accès à la base de données à l'intérieur de vos fonctions écrites en Perl
   peut se faire à partir des fonctions suivantes&nbsp;:
  </para>

   <variablelist>
    <varlistentry>
     <indexterm>
      <primary>spi_exec_query</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_query</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_fetchrow</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_prepare</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_exec_prepared</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_query_prepared</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_cursor_close</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_freeplan</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>spi_exec_query</function>(<replaceable>query</replaceable> [, <replaceable>max-rows</replaceable>])</literal></term>
     <listitem>
      <para>
       <literal>spi_exec_query</literal> exécute une commande SQL et renvoie
       l'ensemble complet de la ligne comme une référence à un table de
       références hachées. <emphasis>Vous ne devez utiliser cette commande
       que lorsque vous savez que l'ensemble de résultat sera relativement
       petit.</emphasis>  Voici un exemple d'une requête (commande
       <command>SELECT</command>) avec le nombre optionnel maximum de
       lignes&nbsp;:
       <programlisting>$rv = spi_exec_query('SELECT * FROM ma_table', 5);</programlisting>
       Ceci entrevoit cinq lignes au maximum de la table
       <literal>ma_table</literal>. Si <literal>ma_table</literal> a une 
       colonne <literal>ma_colonne</literal>, vous obtenez la valeur de la
       ligne <literal>$i</literal> du résultat de cette façon&nbsp;:
       <programlisting>$foo = $rv-&gt;{rows}[$i]-&gt;{ma_colonne};</programlisting>
       Le nombre total des lignes renvoyées d'une requête 
       <command>SELECT</command> peut être accédé de cette façon&nbsp;:
       <programlisting>$nrows = $rv-&gt;{processed}</programlisting>
     </para>
     
     <para>
       Voici un exemple en utilisant un type de commande différent&nbsp;:
       <programlisting>$query = "INSERT INTO ma_table VALUES (1, 'test')";
$rv = spi_exec_query($query);</programlisting>
       Ensuite, vous pouvez accéder au statut de la commande (c'est-à-dire,
       <literal>SPI_OK_INSERT</literal>) de cette façon&nbsp;:
       <programlisting>$res = $rv-&gt;{status};</programlisting>
       Pour obtenir le nombre de lignes affectées, exécutez&nbsp;:
       <programlisting>$nrows = $rv-&gt;{processed};</programlisting>
     </para>

     <para>
       Voici un exemple complet&nbsp;:
       <programlisting>CREATE TABLE test (
    i int,
    v varchar
    );

INSERT INTO test (i, v) VALUES (1, 'première ligne');
INSERT INTO test (i, v) VALUES (2, 'deuxième ligne');
INSERT INTO test (i, v) VALUES (3, 'troisième ligne');
INSERT INTO test (i, v) VALUES (4, 'immortel');

CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS $$
    my $rv = spi_exec_query('select i, v from test;');
    my $status = $rv-&gt;{status};
    my $nrows = $rv-&gt;{processed};
    foreach my $rn (0 .. $nrows - 1) {
        my $row = $rv-&gt;{rows}[$rn];
        $row-&gt;{i} += 200 if defined($row-&gt;{i});
        $row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));
        return_next($row);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM test_munge();
       </programlisting>
     </para>
    </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><function>spi_query</function>(<replaceable>command</replaceable>)</literal></term>
     <term><literal><function>spi_fetchrow</function>(<replaceable>cursor</replaceable>)</literal></term>
     <term><literal><function>spi_cursor_close</function>(<replaceable>cursor</replaceable>)</literal></term>

    <listitem>
    <para>
    <literal>spi_query</literal> et <literal>spi_fetchrow</literal>
    fonctionnent ensemble comme une paire d'ensembles de lignes pouvant être
    assez importants ou pour les cas où vous souhaitez renvoyer les lignes dès
    qu'elles arrivent. <literal>spi_fetchrow</literal> fonctionne
    <emphasis>seulement</emphasis> avec <literal>spi_query</literal>. L'exemple
    suivant illustre comment vous les utilisez ensemble&nbsp;:

<programlisting>CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);

CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS $$
    use Digest::MD5 qw(md5_hex);
    my $file = '/usr/share/dict/words';
    my $t = localtime;
    elog(NOTICE, "opening file $file at $t" );
    open my $fh, '&lt;', $file # ooh, it's a file access!
        or elog(ERROR, "cannot open $file for reading: $!");
    my @words = &lt;$fh&gt;;
    close $fh;
    $t = localtime;
    elog(NOTICE, "closed file $file at $t");
    chomp(@words);
    my $row;
    my $sth = spi_query("SELECT * FROM generate_series(1,$_[0]) AS b(a)");
    while (defined ($row = spi_fetchrow($sth))) {
        return_next({
            the_num =&gt; $row-&gt;{a},
            the_text =&gt; md5_hex($words[rand @words])
        });
    }
    return;
$$ LANGUAGE plperlu;

SELECT * from lotsa_md5(500);
</programlisting>
    </para>

    <para>
     Habituellement, <function>spi_fetchrow</function> devra être répété jusqu'à
     ce qu'il renvoie <literal>undef</literal>, indiquant qu'il n'y a plus de
     lignes à lire. Le curseur renvoyé par <literal>spi_query</literal> est
     automatiquement libéré quand
     <function>spi_fetchrow</function> renvoie <literal>undef</literal>. Si vous
     ne souhaitez pas lire toutes les lignes, appelez à la place
     <function>spi_cursor_close</function> pour libérer le curseur. Un échec ici
     résultera en des pertes mémoire.
    </para>
   </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><function>spi_prepare</function>(<replaceable>command</replaceable>, <replaceable>argument types</replaceable>)</literal></term>
     <term><literal><function>spi_query_prepared</function>(<replaceable>plan</replaceable>, <replaceable>arguments</replaceable>)</literal></term>
     <term><literal><function>spi_exec_prepared</function>(<replaceable>plan</replaceable> [, <replaceable>attributes</replaceable>], <replaceable>arguments</replaceable>)</literal></term>
     <term><literal><function>spi_freeplan</function>(<replaceable>plan</replaceable>)</literal></term>

    <listitem>
    <para>
    <literal>spi_prepare</literal>, <literal>spi_query_prepared</literal>,
    <literal>spi_exec_prepared</literal> et <literal>spi_freeplan</literal>
    implémentent la même fonctionnalité, mais pour des requêtes préparées.
    <literal>spi_prepare</literal> accepte une chaîne pour la requête avec des
    arguments numérotés ($1, $2, etc) et une liste de chaînes indiquant le type
    des arguments&nbsp;:
<programlisting>
$plan = spi_prepare('SELECT * FROM test WHERE id &gt; $1 AND name = $2', 'INTEGER', 'TEXT');
</programlisting>
    Une fois qu'un plan est préparé suite à un appel à
    <literal>spi_prepare</literal>, le plan peut être utilisé à la place de la
    requête, soit dans <literal>spi_exec_prepared</literal>, où le résultat est
    identique à celui renvoyé par <literal>spi_exec_query</literal>, soit dans
    <literal>spi_query_prepared</literal> qui renvoi un curseur exactement comme
    le fait <literal>spi_query</literal>, qui peut ensuite être passé à
    <literal>spi_fetchrow</literal>. Le deuxième paramètre, optionnel, de
    <literal>spi_exec_prepared</literal> est une référence hachée des
    attributs&nbsp;; le seul attribut actuellement supporté est
    <literal>limit</literal>, qui configure le nombre maximum de lignes renvoyées
    par une requête. 
    </para>

    <para>
    L'avantage des requêtes préparées est que cela rend possible l'utilisation
    d'un plan préparé par plusieurs exécutions de la requête. Une fois que le
    plan n'est plus utile, il peut être libéré avec
    <literal>spi_freeplan</literal>&nbsp;:
    </para>

    <para>
    <programlisting>
CREATE OR REPLACE FUNCTION init() RETURNS VOID AS $$
        $_SHARED{my_plan} = spi_prepare( 'SELECT (now() + $1)::date AS now', 'INTERVAL');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS $$
        return spi_exec_prepared(
                $_SHARED{my_plan},
                $_[0]
        )->{rows}->[0]->{now};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION done() RETURNS VOID AS $$
        spi_freeplan( $_SHARED{my_plan});
        undef $_SHARED{my_plan};
$$ LANGUAGE plperl;

SELECT init();
SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');
SELECT done();

  add_time  |  add_time  |  add_time
------------+------------+------------
 2005-12-10 | 2005-12-11 | 2005-12-12
    </programlisting>
    </para>

    <para>
    Notez que l'indice du paramètre dans <literal>spi_prepare</literal> est
    défini via $1, $2, $3, etc, donc évitez de déclarer des chaînes de requêtes
    qui pourraient aisément amener des bogues difficiles à trouver et corriger.
    </para>

    <para>
    Cet autre exemple illustre l'utilisation d'un paramètre optionnel avec
    <literal>spi_exec_prepared</literal>&nbsp;:
    </para>

    <para>
    <programlisting>
CREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address FROM generate_series(1,3) AS id;

CREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS $$
        $_SHARED{plan} = spi_prepare('SELECT * FROM hosts WHERE address &lt;&lt; $1', 'inet');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS $$
        return spi_exec_prepared(
                $_SHARED{plan},
                {limit =&gt; 2},
                $_[0]
        )->{rows};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS $$
        spi_freeplan($_SHARED{plan});
        undef $_SHARED{plan};
$$ LANGUAGE plperl;

SELECT init_hosts_query();
SELECT query_hosts('192.168.1.0/30');
SELECT release_hosts_query();

    query_hosts    
-----------------
 (1,192.168.1.1)
 (2,192.168.1.2)
(2 rows)
    </programlisting>
    </para>
    </listitem>
    </varlistentry>
   </variablelist>
 </sect2>

 <sect2 id="plperl-utility-functions">
  <title>Fonctions utiles en PL/Perl</title>

   <variablelist>
    <varlistentry>
     <term><literal><function>elog</function>(<replaceable>level</replaceable>,
     <replaceable>msg</replaceable>)</literal></term>
     <listitem>
     <indexterm>
      <primary>elog</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

      <para>
       Produit un message de trace ou d'erreur. Les niveaux possibles sont
       <literal>DEBUG</literal>, <literal>LOG</literal>, <literal>INFO</literal>,
       <literal>NOTICE</literal>, <literal>WARNING</literal> et <literal>ERROR</literal>.
       <literal>ERROR</literal> lève une condition d'erreur&nbsp;; si elle n'est pas
       récupérée par le code Perl l'entourant, l'erreur se propage à
       l'extérieur de la requête appelante, causant l'annulation de la 
       transaction ou sous-transaction en cours. Ceci est en fait identique à
       la commande <literal>die</literal> de Perl. Les autres niveaux génèrent 
       seulement des messages de niveaux de priorité différents. Le fait que
       les messages d'un niveau de priorité particulier soient rapportés au
       client, écrit dans les journaux du serveur, voire les deux, est contrôlé
       par les variables de configuration <xref
       linkend="guc-log-min-messages"/> et <xref
       linkend="guc-client-min-messages"/>. Voir le <xref
       linkend="runtime-config"/> pour plus d'informations.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>quote_literal</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><literal><function>quote_literal</function>(<replaceable>string</replaceable>)</literal></term>
     <listitem>
      <para>
        Retourne la chaîne donnée convenablement placé entre simple guillemets pour être utilisée comme une chaîne littérale au sein
        d'une chaîne représentant un ordre SQL. Les simples guillemets et antislashes de la chaîne sont correctement doublés
        Notez que <function>quote_literal</function> retourne undef avec une entrée undef ; si l'argument
        peut être undef, <function>quote_nullable</function> est souvent plus approprié.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>quote_nullable</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><literal><function>quote_nullable</function>(<replaceable>string</replaceable>)</literal></term>
     <listitem>
      <para>
	    Retourne la chaîne donnée convenablement placé entre simple guillemets pour être utilisée comme une chaîne littérale au sein
        d'une chaîne représentant un ordre SQL. Si l'argument d'entrée est undef, retourne la chaîne "NULL" sans simple guillemet.
        Les simples guillemets et antislashes de la chaîne sont correctement doublés
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>quote_ident</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><literal><function>quote_ident</function>(<replaceable>string</replaceable>)</literal></term>
     <listitem>
      <para>
        Retourne la chaîne donnée convenablement placé entre guillemets pour être utilisée 
        comme un identifiant au sein d'une chaîne représentant un ordre SQL. 
        Les guillemets sont ajoutées seulement si cela est nécessaire (i.e. si 
        la chaîne contient des caractères non-identifiant ou est en majuscule). 
        Les guillemets  de la chaîne seront convenablement doublés.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>decode_bytea</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><literal><function>decode_bytea</function>(<replaceable>string</replaceable>)</literal></term>
     <listitem>
      <para>
	    Retourne les données binaires non échappé représentées par le contenu de 
	    la chaîne donnée, qui doit être encodé au format <type>bytea</type>.
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>encode_bytea</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><literal><function>encode_bytea</function>(<replaceable>string</replaceable>)</literal></term>
     <listitem>
      <para>
        Retourne sous la forme d'un <type>bytea</type> le contenu binaire dans la chaîne passé en argument.
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>encode_array_literal</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><literal><function>encode_array_literal</function>(<replaceable>array</replaceable>)</literal></term>
     <term><literal><function>encode_array_literal</function>(<replaceable>array</replaceable>, <replaceable>delimiter</replaceable>)</literal></term>
     <listitem>
      <para>
	    Retourne le contenu de tableau passé par référence sous forme d'une chaîne littérale.
        (voir <xref linkend="arrays-input"/>).
        Retourne la valeur de l'argument non altérée si ce n'est pas une référence à un tableau.
        Le délimiteur utilisé entre les éléments du tableau sous forme littérale sera par défaut "<literal>, </literal>"
        si aucun délimiteur n'est spécifié ou s'il est undef.
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>encode_array_constructor</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><literal><function>encode_array_constructor</function>(<replaceable>array</replaceable>)</literal></term>
     <listitem>
      <para>
        Retourne le contenu de tableau passé par référence sous forme d'une chaîne 
        permettant de construire un tableau en SQL.
        (voir <xref linkend="sql-syntax-array-constructors"/>).
        Chaque élément est entouré de simple guillemets par <function>quote_nullable</function>.
        Retourne la valeur de l'argument, entouré de simple guillemets par <function>quote_nullable</function>,
        si ce n'est pas une référence à un tableau.
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>looks_like_number</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><literal><function>looks_like_number</function>(<replaceable>string</replaceable>)</literal></term>
     <listitem>
      <para>
        Retourne une valeur vraie si le contenu de la chaîne passée ressemble à 
        un nombre, selon l'interprétation de Perl, et faux dans le cas contraire.
        Retourne undef si undef est passé en argument. Tout espace en début et fin de chaîne sont
        ignorés. <literal>Inf</literal> et <literal>Infinity</literal> sont vu comme des nombres.
        </para>
     </listitem>
    </varlistentry>

   </variablelist>
 </sect2>
 </sect1>

<sect1 id="plperl-global">
  <title>Valeurs globales dans PL/Perl</title>
  
  <para>
    Vous pouvez utiliser le hachage global <varname>%_SHARED</varname> pour
    stocker les données, incluant les références de code, entre les appels de
    fonction pour la durée de vie de la session en cours.
  </para>
  
  <para>
    Voici un exemple simple pour des données partagées&nbsp;:
    <programlisting>CREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS $$
if ($_SHARED{$_[0]} = $_[1]) {
      return 'ok';
} else {
      return "Ne peux pas initialiser la variable partagée $_[0] à $_[1]";
}
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS $$
      return $_SHARED{$_[0]};
$$ LANGUAGE plperl;

SELECT set_var('sample', 'Bonjour, PL/Perl ! Comment va ?');
SELECT get_var('sample');</programlisting>
  </para>
  
  <para>
    Voici un exemple légèrement plus compliqué utilisant une référence de
    code&nbsp;:
    
    <programlisting>CREATE OR REPLACE FUNCTION ma_fonction() RETURNS void AS $$
$_SHARED{myquote} = sub {
      my $arg = shift;
      $arg =~ s/(['\\])/\\$1/g;
      return "'$arg'";
      };
$$ LANGUAGE plperl;

SELECT ma_fonction(); /* initialise la fonction */

/* Initialise une fonction qui utilise la fonction quote */

CREATE OR REPLACE FUNCTION utilise_quote(TEXT) RETURNS text AS $$
      my $text_to_quote = shift;
      my $qfunc = $_SHARED{myquote};
      return &amp;$qfunc($text_to_quote);
$$ LANGUAGE plperl;</programlisting>

    (Vous pouviez avoir remplacé le code ci-dessus avec la seule ligne
    <literal>return $_SHARED{myquote}-&gt;($_[0]);</literal>
    au prix d'une mauvaise lisibilité.)
  </para>

  <para>
    La variable <varname>%_SHARED</varname> et d'autre état global au sein du langage
    sont des données publique, 
    <!-- FIXME The <varname>%_SHARED</varname> variable and other global state within
    the language is public data -->
    accessible à toute fonction PL/Perl au cours de la session.
    À utiliser avec précaution, spécifiquement dans les situations qui impliquent l'utilisation 
    de plusieurs rôles ou les fonctions <literal>SECURITY DEFINER</literal>.
  </para>
</sect1>

 <sect1 id="plperl-trusted">
  <title>Niveaux de confiance de PL/Perl</title>

  <indexterm zone="plperl-trusted">
   <primary>trusted</primary>
   <secondary>PL/Perl</secondary>
  </indexterm>

  <para>
   Normalement, PL/Perl est installé en tant que langage de programmation de
   <quote>confiance</quote>, de nom <literal>plperl</literal>. Durant cette installation,
   certaines commandes Perl sont désactivées pour préserver la sécurité. En
   général, les commandes qui interagissent avec l'environnement sont
   restreintes. Cela inclut les commandes sur les descripteurs de fichiers,
   <literal>require</literal> et <literal>use</literal> (pour les modules
   externes). Il n'est pas possible d'accéder aux fonctions et variables
   internes du processus du serveur de base de données ou d'obtenir un accès au
   niveau du système d'exploitation avec les droits du processus serveur, tel
   qu'une fonction C peut le faire. Ainsi, n'importe quel utilisateur sans
   droits sur la base de données est autorisé à utiliser ce langage.
  </para>

  <para>
   Voici l'exemple d'une fonction qui ne fonctionnera pas car les commandes système
   ne sont pas autorisées pour des raisons de sécurité&nbsp;:
<programlisting>CREATE FUNCTION badfunc() RETURNS integer AS $$
    my $tmpfile = "/tmp/badfile";
    open my $fh, '&gt;', $tmpfile
        or elog(ERROR, qq{could not open the file "$tmpfile": $!});
    print $fh "Testing writing to a file\n";
    close $fh or elog(ERROR, qq{could not close the file "$tmpfile": $!});
    return 1;
$$ LANGUAGE plperl;
</programlisting>
   La création de cette fonction échouera car le validateur détectera
   l'utilisation par cette fonction d'une opération interdite.
  </para>

  <para>
   Il est parfois souhaitable d'écrire des fonctions Perl qui ne sont pas
   restreintes. Par exemple, on peut souhaiter vouloir envoyer des courriers
   électroniques. Pour supporter ce cas de figure, PL/Perl peut aussi être
   installé comme un langage <quote>douteux</quote> (habituellement nommé
   <application>PL/PerlU</application>
   <indexterm><primary>PL/PerlU</primary></indexterm>).
   Dans ce cas, la totalité du langage Perl est accessible. Si la commande
   <command>createlang</command> est utilisée pour installer le langage, le nom
   du langage <literal>plperlu</literal> sélectionnera la version douteuse de
   PL/Perl.
  </para>

  <para>
   Les auteurs des fonctions <application>PL/PerlU</application> doivent faire attention au
   fait que celles-ci ne puissent être utilisées pour faire quelque chose de non
   désiré car cela donnera la possibilité d'agir comme si l'on possédait les
   privilèges d'administrateur de la base de données. Il est à noter que le
   système de base de données ne permet qu'aux super-utilisateurs de créer des
   fonctions dans un langage douteux.
  </para>

  <para>
   Si la fonction ci-dessus a été créée par un super-utilisateur en utilisant
   le langage <literal>plperlu</literal>, l'exécution de celle-ci réussira.
  </para>

  <para>
   De la même façon, les blocs de procédure anonymes écris en perl peuvent utiliser
   les opérations restreintes si le langage est spécifié comme 
   <literal>plperlu</literal> plutôt que <literal>plperl</literal>, mais l'appelant
   doit être un super-utilisateur.
  </para>

  <note>
    <para>
      Pour des raisons de sécurité, pour stopper une faille des opérations
      privilégiées à partir de <application>PL/PerlU</application> vers
      <application>PL/Perl</application>, ces deux langages doivent être exécutés
      dans des instances séparées de l'interpréteur Perl. Si votre installation
      Perl a été compilé de façon approprié, ce n'est pas un problème. Néanmoins,
      toutes les installations ne sont pas compilées avec les options requises.
      Si <productname>PostgreSQL</productname> détecte que c'est le cas, alors
      il n'exécutera pas le deuxième interpréteur mais lèvera une erreur à la
      place. En conséquence, dans une telle installation, vous ne pouvez pas
      utiliser à la fois <application>PL/PerlU</application> et
      <application>PL/Perl</application> dans le même processus serveur. Le
      remède à ceci est d'obtenir une installation Perl configurée avec les options
      appropriées, nommément <literal>usemultiplicity</literal> ou
      <literal>useithreads</literal>. <literal>usemultiplicity</literal> est préférée
      à moins que vous n'ayez vraiment besoin d'utiliser les threads. 
      Pour plus de détails, voir la page de man
      <citerefentry><refentrytitle>perlembed</refentrytitle></citerefentry>.
    </para>
  </note>

 </sect1>

 <sect1 id="plperl-triggers">
   <title>Déclencheurs PL/Perl</title>
   
   <para>
     PL/Perl peut être utilisé pour écrire des fonctions pour déclencheurs.
     Dans une fonction déclencheur, la référence hachée 
     <varname>$_TD</varname> contient des informations sur l'événement du
     déclencheur en cours. <varname>$_TD</varname> est une variable globale
     qui obtient une valeur locale séparée à chaque appel du déclencheur.
     Les champs de la référence de hachage
     <varname>$_TD</varname> sont&nbsp;:
     
     <variablelist>
       <varlistentry>
         <term><literal>$_TD-&gt;{new}{foo}</literal></term>
         <listitem>
           <para>
             Valeur <literal>NEW</literal> de la colonne <literal>foo</literal>
           </para>
         </listitem>
       </varlistentry>
       
       <varlistentry>
         <term><literal>$_TD-&gt;{old}{foo}</literal></term>
         <listitem>
           <para>
             Valeur <literal>OLD</literal> de la colonne <literal>foo</literal>
           </para>
         </listitem>
       </varlistentry>
       
       <varlistentry>
         <term><literal>$_TD-&gt;{name}</literal></term>
         <listitem>
           <para>
             Nom du déclencheur appelé
           </para>
         </listitem>
       </varlistentry>
       
       <varlistentry>
         <term><literal>$_TD-&gt;{event}</literal></term>
         <listitem>
           <para>
             Événement du déclencheur&nbsp;: <literal>INSERT</literal>,
             <literal>UPDATE</literal>, <literal>DELETE</literal>,
             <literal>TRUNCATE</literal> ou <literal>UNKNOWN</literal>
           </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>$_TD-&gt;{when}</literal></term>
         <listitem>
           <para>
             Quand le déclencheur a été appelé&nbsp;:
             <literal>BEFORE</literal> (avant), <literal>AFTER</literal>
             (après) ou <literal>UNKNOWN</literal> (inconnu)
           </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>$_TD-&gt;{level}</literal></term>
         <listitem>
           <para>
             Le niveau du déclencheur&nbsp;: <literal>ROW</literal> (ligne),
             <literal>STATEMENT</literal> (instruction) ou
             <literal>UNKNOWN</literal> (inconnu)
           </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>$_TD-&gt;{relid}</literal></term>
         <listitem>
           <para>
             L'OID de la table sur lequel le déclencheur a été exécuté
           </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>$_TD-&gt;{table_name}</literal></term>
         <listitem>
           <para>
             Nom de la table sur lequel le déclencheur a été exécuté
           </para>
         </listitem>
       </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relname}</literal></term>
     <listitem>
      <para>
       Nom de la table sur lequel le déclencheur a été exécuté. Elle est obsolète
       et pourrait être supprimée dans une prochaine version. Utilisez
       $_TD-&gt;{table_name} à la place.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_schema}</literal></term>
     <listitem>
      <para>
       Nom du schéma sur lequel le déclencheur a été exécuté.
      </para>
     </listitem>
    </varlistentry>

       <varlistentry>
         <term><literal>$_TD-&gt;{argc}</literal></term>
         <listitem>
           <para>
             Nombre d'arguments de la fonction déclencheur
           </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>@{$_TD-&gt;{args}}</literal></term>
         <listitem>
           <para>
             Arguments de la fonction déclencheur. N'existe pas si
             <literal>$_TD-&gt;{argc}</literal> vaut 0.
           </para>
         </listitem>
       </varlistentry>

     </variablelist>
   </para>

   <para>
     Les déclencheurs niveau ligne peuvent renvoyer un des éléments suivants&nbsp;:
  
     <variablelist>
       <varlistentry>
         <term><literal>return;</literal></term>
         <listitem>
           <para>
             Exécute l'opération
           </para>
         </listitem>
       </varlistentry>
    
       <varlistentry>
         <term><literal>"SKIP"</literal></term>
         <listitem>
           <para>
             N'exécute pas l'opération
           </para>
         </listitem>
       </varlistentry>
    
       <varlistentry>
         <term><literal>"MODIFY"</literal></term>
         <listitem>
           <para>
             Indique que la ligne <literal>NEW</literal> a été modifiée par la
             fonction déclencheur
           </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </para>

   <para>
     Voici un exemple d'une fonction déclencheur illustrant certains points
     ci-dessus&nbsp;:
     <programlisting>CREATE TABLE test (
    i int,
    v varchar
);

CREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$
    if (($_TD-&gt;{new}{i} &gt;= 100) || ($_TD-&gt;{new}{i} &lt;= 0)) {
        return "SKIP";    # passe la commande INSERT/UPDATE
    } elsif ($_TD-&gt;{new}{v} ne "immortal") {
        $_TD-&gt;{new}{v} .= "(modified by trigger)";
        return "MODIFY";  # modifie la ligne et exécute la commande INSERT/UPDATE
    } else {
        return;           # exécute la commande INSERT/UPDATE
    }
$$ LANGUAGE plperl;

CREATE TRIGGER test_valid_id_trig
    BEFORE INSERT OR UPDATE ON test
    FOR EACH ROW EXECUTE PROCEDURE valid_id();</programlisting>
   </para>
 </sect1>

 <sect1 id="plperl-under-the-hood">
  <title>PL/Perl sous le capot</title>

 <sect2 id="plperl-config">
  <title>Configuration</title>

  <para>
  Cette section liste les paramètres de configuration de <application>PL/Perl</application>.
  Pour paramétrer n'importe lequel d'entre eux avant que <application>PL/Perl</application> ne soit chargé, 
  il est nécessaire d'avoir ajouté <quote><literal>plperl</literal></quote> à la liste
  <xref linkend="guc-custom-variable-classes"/> dans <filename>postgresql.conf</filename>.
  </para>

  <variablelist>

     <varlistentry id="guc-plperl-on-init" xreflabel="plperl.on_init">
      <term><varname>plperl.on_init</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>paramètre de configuration <varname>plperl.on_init</varname></primary>
      </indexterm>
      <listitem>
       <para><!--TODO-->
       Spécifie un code perl à exécuter lorsque l'interpréteur Perl est initialisé 
       pour la première fois et avant qu'il soit spécialisé pour être utilisé par 
       <literal>plperl</literal> ou <literal>plperlu</literal>.
       Les fonction SPI ne sont pas disponible lorsque ce code est exécuté.
       Si le code lève une erreur, il interrompra l'initialisation de 
       l'interpréteur et la propagera à la requête originale, provoquant ainsi 
       l'annulation de la transaction ou sous-transaction courante.
       </para>
       <para>
       Le code Perl est limité à une seule ligne. Un code plus long peut
       être placé dans un module et chargé par <literal>on_init</literal>.
       Exemples:
<programlisting>
plperl.on_init = 'require "plperlinit.pl"'
plperl.on_init = 'use lib "/my/app"; use MyApp::PgInit;'
</programlisting>
       </para>
       <para>
       Tous les modules chargés par <literal>plperl.on_init</literal>, directement
       ou indirectement, seront disponibles depuis <literal>plperl</literal>.
       Cela entraîne un problème de sécurité potentiel. Pour consulter 
       la liste des modules chargés, vous pouvez utiliser :
<programlisting>
DO 'elog(WARNING, join ", ", sort keys %INC)' language plperl;
</programlisting>
       </para>
       <para>
       L'initialisation aura lieu au sein du postmaster si la librairie plperl 
       est incluse dans le paramètre 
       <literal>shared_preload_libraries</literal> (voir <xref linkend="guc-shared-preload-libraries"/>), 
       auquel cas une plus grande attention doit être portée au risque de 
       déstabiliser ce dernier
       </para>
       <para>
       Ce paramètre ne peut être positionné que dans le fichier postgresql.conf ou 
       depuis la ligne de commande de démarrage du serveur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-plperl-on-plperl-init" xreflabel="plperl.on_plperl_init">
      <term><varname>plperl.on_plperl_init</varname> (<type>string</type>)</term>
      <term><varname>plperl.on_plperlu_init</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>paramètre de configuration <varname>plperl.on_plperl_init</varname></primary>
      </indexterm>
      <indexterm>
       <primary>paramètre de configuration <varname>plperl.on_plperlu_init</varname></primary>
      </indexterm>
      <listitem>
       <para>
       Ces paramètres spécifient le code Perl à exécuter lorsque respectivement 
       <literal>plperl</literal> ou <literal>plperlu</literal> sont utilisé 
       pour la première fois dans une session. Modifier ces paramètres après 
       que le langage correspondant est été utilisé n'aura aucun effet.
       Les fonctions SPI ne sont pas disponibles lorsque ce code est exécuté.
       Seuls les super utilisateurs peuvent modifier ces paramètres.
       Le code Perl dans <literal>plperl.on_plperl_init</literal>  ne peut 
       effectuer que des opérations dites de confiances.
       </para>
       <para>
       L'effet de ces paramètres est très similaire à l'exécution d'une 
       commande <literal>DO</literal> avec le code Perl avant tout autre 
       utilisation du langage. Ces paramètres sont utiles lorsque vous voulez 
       exécuter le morceau de code Perl à chaque connexion, ou lorsque la 
       connexion n'est pas interactive. Ces paramètres peuvent être utilisé 
       utilisés par des non-super utilisateurs en exécutant tant que 
       super-utilisateur la commande <literal>ALTER USER ... SET ...</literal>.
       
       Par exemple:
<programlisting>
ALTER USER joe SET plperl.on_plperl_init = '$_SHARED{debug} = 1';
</programlisting>
       </para>
       <para>
       Si le code lève une erreur, il interrompra l'initialisation et la 
       propagera à la requête originale, provoquant ainsi l'annulation de la 
       transaction ou sous-transaction courante. Toutes les modifications au 
       sein de Perl ne seront pas annulées. Si le langage est utilisé de 
       nouveau, l'initialisation sera de nouveau exécutée.
       </para>
       <para>
       La différence entre ces deux paramètres et 
       <literal>plperl.on_init</literal> est qu'ils peuvent être utilisés 
       pour positionner des paramètres spécifiques pour chacune des 
       variantes sûre et douteuse, comme pour positionner des valeurs 
       différentes dans la variable <varname>%_SHARED</varname>. 
       <literal>plperl.on_init</literal> lui, sera plus utile pour effectuer 
       des actions comme positionner le chemin de recherche des librairies 
       pour <productname>Perl</productname> ou charger des modules qui 
       n'interagissent pas directement avec 
       <productname>PostgreSQL</productname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-plperl-use-strict" xreflabel="plperl.use_strict">
      <term><varname>plperl.use_strict</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>paramètre de configuration <varname>plperl.use_strict</varname></primary>
      </indexterm>
      <listitem>
       <para>
       Lorsqu'il est positionné à « true », les compilations des fonction 
       PL/Perl suivantes auront le pragma <literal>strict</literal> activé.
       Ce paramètre n'affecte pas les fonctions déjà compilées au sein de 
       la session courante.
       </para>
      </listitem>
     </varlistentry>

  </variablelist>
</sect2>

 <sect2 id="plperl-missing">
  <title>Limitations et fonctionnalités absentes</title>

  <para>
   Les fonctionnalités suivantes ne sont actuellement pas implémentées dans
   PL/Perl, mais peuvent faire l'objet de contributions généreuses de votre part.

   <itemizedlist>
    <listitem>
     <para>
      Les fonctions PL/Perl ne peuvent pas s'appeler entre elles.
     </para>
    </listitem>

    <listitem>
     <para>
      SPI n'est pas complètement implémenté.
     </para>
    </listitem>

    <listitem>
     <para>
      Si vous récupérez des ensembles de données très importants en utilisant
      <literal>spi_exec_query</literal>, vous devez être conscient qu'ils
      iront tous en mémoire. Vous pouvez l'éviter en utilisant
      <literal>spi_query</literal>/<literal>spi_fetchrow</literal> comme
      montré précédemment.
     </para>
     <para>
        Un problème similaire survient si une fonction renvoyant un ensemble
        passe un gros ensemble de lignes à PostgreSQL via
        <literal>return</literal>. Vous pouvez l'éviter aussi en utilisant à la
        place <literal>return_next</literal> pour chaque ligne renvoyée, comme
        indiqué précédemment.
     </para>
    </listitem>

     <listitem>
      <para>
        Lorsque'une session se termine normalement, et pas à cause d'une erreur fatale,
        tous les blocs <literal>END</literal> qui ont été définis sont exécutés.
        Actuellement, aucune autre action ne sont réalisées.
        Spécifiquement, les descripteurs de fichiers ne sont pas vidés automatiquement
        et les objets ne sont pas détruits automatiquement.
      </para>
     </listitem>
   </itemizedlist>
  </para>
 </sect2>
 </sect1>

</chapter>

