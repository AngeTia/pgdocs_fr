<!-- doc/src/sgml/sepgsql.sgml -->

<sect1 id="sepgsql" xreflabel="sepgsql">
 <title>sepgsql</title>

 <indexterm zone="sepgsql">
  <primary>sepgsql</primary>
 </indexterm>

 <para>
  <filename>sepgsql</filename> est un module chargeable ajoutant le
  support des contrôles d'accès par label basé sur la politique de
  sécurité de <productname>SELinux</productname>.
 </para>

 <warning>
   <para>
     Cette implémentation a des limitations importantes et ne force pas
     le contrôle d'accès pour toutes les actions. Voir
     <xref linkend="sepgsql-limitations"/>.
   </para>
 </warning>

 <sect2 id="sepgsql-overview">
  <title>Aperçu</title>

  <para>
   Ce module s'intègre avec <productname>SELinux</productname> pour
   fournir une couche de vérification de sécurité supplémentaire qui va
   au-delà de ce qui est déjà fournit par
   <productname>PostgreSQL</productname>. De la perspective de
   <productname>SELinux</productname>, ce module permet à
   <productname>PostgreSQL</productname> de fonctionner comme un
   gestionnaire d'objet en espace utilisateur. Chaque accès à une table
   ou à une fonction initié par une requête DML sera vérifié par rapport
   à la politique de sécurité du système. Cette vérification est en plus
   des vérifications de droits habituels effectuées par
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   Les décisions de contrôle d'accès de <productname>SELinux</productname>
   sont faites en utilisant les labels de sécurité qui sont représentés
   par des chaînes comme
   <literal>system_u:object_r:sepgsql_table_t:s0</literal>. Chaque
   décision de contrôle d'accès implique deux labels&nbsp;: celui de
   l'utilisateur tentant de réaliser l'action et celui de l'objet sur
   lequel l'action est réalisée. Comme ces labels peuvent être appliqués
   sur tout type d'objet, les décisions de contrôle d'accès pour les
   objets stockés dans la base peuvent être (et avec ce module, sont)
   sujets au même critère général utilisé pour les objets de tout type
   (par exemple les fichiers). Ce concept a pour but de permettre la mise
   en place d'une politique centralisée pour protéger l'information
   quelque soit la façon dont l'information est stockée.
  </para>

  <para>
   L'instruction <xref linkend="sql-security-label"/> permet d'affecter
   un label de sécurité à un objet de la base de données.
  </para>

 </sect2>
 <sect2 id="sepgsql-installation">
  <title>Installation</title>

  <para>
    Ce module peut seulement être utilisé sur
    <productname>Linux</productname> 2.6.28 ou ultérieur, avec
    <productname>SELinux</productname> activé. Il n'est pas disponible
    sur les autres plateformes et doit être explicitement activé en
    utilisant <literal>--with-selinux</literal>. Vous aurez aussi besoin
    de <productname>libselinux</productname> ou ultérieur et de
    <productname>selinux-policy</productname> 3.9.13 ou ultérieur
    (certaines distributions peuvent proposer les règles nécessaires
    dans des versions antérieures de politique).
  </para>

  <para>
   La commande <command>sestatus</command> vous permet de vérifier le
   statut de <productname>SELinux</productname>.
<screen>
$ sestatus
SELinux status:                 enabled
SELinuxfs mount:                /selinux
Current mode:                   enforcing
Mode from config file:          enforcing
Policy version:                 24
Policy from config file:        targeted
</screen>
   Si <productname>SELinux</productname> est désactivé ou non installé,
   vous devez tout d'abord configurer ce produit avant d'utiliser ce
   module.
  </para>

  <para>
   Pour utiliser ce module, vous devez ajouter <literal>sepgsql</literal>
   dans <xref linkend="guc-shared-preload-libraries"/>. Le module ne
   fonctionnera pas s'il est chargé d'une autre façon. Une fois que le
   module est chargé, vous devez exécuter
   <filename>sepgsql.sql</filename> dans chaque base de données. Cela
   installera les fonctions nécessaires à la gestion des labels de
   sécurité et affectera des labels initiaux de sécurité.
  </para>

  <para>
   Les instructions suivantes supposent que votre installation se trouve
   dans le répertoire <filename>/usr/local/pgsql</filename> et que
   le répertoire des données se trouve dans
   <filename>/chemin/vers/base</filename>. Ajustez
   les chemins affichés ci-dessous pour votre installation.
  </para>

<screen>
$ export PGDATA=/chemin/vers/base
$ initdb
$ vi $PGDATA/postgresql.conf
$ for DBNAME in template0 template1 postgres; do
  postgres --single -F -O -c exit_on_error=true $DBNAME \
      &lt; /usr/local/pgsql/share/contrib/sepgsql.sql &gt; /dev/null
  done
</screen>

  <para>
   Si le processus d'installation se termine sans erreur, vous pouvez
   commencer à lancer le serveur normalement.
  </para>

  <para>
   Notez que vous pourriez voir les notifications suivantes, suivant la
   combinaison de versions particulières de
   <productname>libselinux</productname> et de
   <productname>selinux-policy</productname>.
<screen>
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 33 has invalid object type db_blobs
</screen>
   Ce message n'est pas grave et peut être ignoré sans conséquence.
  </para>
 </sect2>

 <sect2 id="sepgsql-regression">
  <title>Tests de régression</title>
  <para>
   Dû à la nature de <productname>SELinux</productname>, exécuter les
   tests de régression pour ce module nécessite quelques étapes de
   configuration supplémentaires.
  </para>

  <para>
   Tout d'abord, configurez <productname>sepgsql</productname> suivant
   <xref linkend="sepgsql-installation"/>. Le test de régression a pour
   but d'être exécuté sur un système ayant une implémentation
   fonctionnelle de SE-Linux. L'utilisateur courant du système
   d'exploitation doit être capable de se connecter à la base de données
   en tant que superutilisateur et sans authentification.
  </para>

  <para>
   Ensuite, construisez et installez le paquet de politique pour les
   tests de régression. Le fichier <filename>sepgsql-regtest.pp</filename>
   est un paquet de politique à but spécial. Il fournit un ensemble de
   règles à autoriser pendant les tests de régression. Il doit être
   construit à partir du fichier source de politique
   (<filename>sepgsql-regtest.te</filename>), ce qui se fait normalement
   en utilisant <command>make</command>. Vous aurez besoin de localiser
   le Makefile approprié sur votre système&nbsp;; le chemin affiché
   ci-dessous est seulement un exemple. Une fois construit, vous pouvez
   installer ce paquet de politique en utilisant la commande
   <command>semodule</command>, qui lie les paquets de politique fournis
   et les charge dans l'espace noyau. Si ce paquet est correctement
   installé, <literal><command>semodule</command> -l</literal> doit lister
   sepgsql-regtest comme un paquet de politique disponible.
  </para>

<screen>
$ make -C ./contrib/sepgsql -f /usr/share/selinux/devel/Makefile
$ su
# semodule -u ./contrib/sepgsql/sepgsql-regtest.pp
# semodule -l
    :
sepgsql-regtest 1.03
    :
</screen>

  <para>
   Puis, activez <literal>sepgsql_regression_test_mode</literal>. Nous
   n'activons pas toutes les règles du fichier
   <filename>sepgsql-regtest.pp</filename> par défaut, pour la sécurité
   de votre système. Le paramètre
   <literal>sepgsql_regression_test_mode</literal> est associé à des
   règles pour le lancement des tests de régression. Il peut être
   activé en utilisant la commande <command>setsebool</command>.
  </para>

<screen>
$ su
# setsebool sepgsql_regression_test_mode on
# getsebool sepgsql_regression_test_mode
sepgsql_regression_test_mode --> on
</screen>

  <para>
   Enfin, lancez les tests de régression à partir du domaine
   <literal>unconfined_t</literal>.
  </para>

  <para>
   La commande <command>id</command> nous indique le domaine en cours.
   Confirmez que votre shell utilise le domaine
   <literal>unconfined_t</literal> ainsi&nbsp;:
  </para>
<screen>
$ id -Z
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
</screen>

  <para>
   Voir <xref linkend="sepgsql-resources"/> pour des détails sur
   l'ajustement de votre domaine de travail, si nécessaire.
  </para>

  <para>
   Si <command>pg_regress</command> échoue au lancement de la commande
   <command>psql</command>, vous devez vous assurer que la commande
   <command>psql</command> est labelisée <literal>bin_t</literal>. Dans
   le cas contraire, la commande <command>restorecon</command> peut être
   utilisée pour corriger les labels de sécurité dans le répertoire
   d'installation de <productname>PostgreSQL</productname>.
  </para>

<screen>
$ restorecon -R /usr/local/pgsql/
</screen>
 </sect2>

 <sect2 id="sepgsql-parameters">
  <title>Paramètres GUC</title>

  <variablelist>
   <varlistentry id="guc-sepgsql-permissive" xreflabel="sepgsql.permissive">
    <term><varname>sepgsql.permissive</varname> (<type>boolean</type>)</term>
    <indexterm>
     <primary>paramètre de configuration <varname>sepgsql.permissive</varname></primary>
    </indexterm>
    <listitem>
     <para>
      Ce paramètre active <productname>SE-PostgreSQL</productname> pour
      qu'il fonctionne en mode permissif, quelque soit la configuration
      du système. La valeur par défaut est off.
      Ce paramètre es configurable dans le fichier
      <filename>postgresql.conf</filename> et sur la ligne de commande.
     </para>

     <para>
      Quand ce paramètre est activé, <productname>SE-PostgreSQL</productname>
      fonctionne en mode permissif, même si le système de la plateforme
      fonctionne en mode forcé. Ce paramètre est utile principalement
      pour des tests.
     </para>
    </listitem>

   </varlistentry>
   <varlistentry id="guc-sepgsql-debug-audit" xreflabel="sepgsql.debug_audit">
    <term><varname>sepgsql.debug_audit</varname> (<type>boolean</type>)</term>
    <indexterm>
     <primary>paramètre de configuration <varname>sepgsql.debug_audit</varname></primary>
    </indexterm>
    <listitem>
     <para>
      Ce paramètre active l'affichage de messages d'audit indépendants
      de la configuration de la politique. La valeur par défaut est
      off (d'après la configuration de la politique de sécurité).
     </para>

     <para>
      La politique de sécurité de <productname>SELinux</productname> a
      aussi des règles pour contrôler la trace des accès. Par défaut,
      les violations d'accès sont tracées, contrairement aux accès
      autorisés.
     </para>

     <para>
      Ce paramètre force l'activation de toutes les traces, quelque soit
      la politique du système.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="sepgsql-features">
  <title>Fonctionnalités</title>
  <sect3>
   <title>Classes d'objet contrôlé</title>
   <para>
    Le modèle de sécurité <productname>SELinux</productname> décrit toutes
    les règles de contrôle d'accès comme une relation entre une entité
    sujet (habituellement le client d'une base) et une entité objet. Les
    deux sont identifiés par un label de sécurité. Si un accès à un
    objet sans label est tenté, l'objet est traité comme si le label
    <literal>unlabeled_t</literal> lui est affecté.
   </para>

   <para>
    Actuellement, <productname>sepgsql</productname> autorise l'affectation
    de label de sécurité aux schémas, tables, colonnes, séquences, vues
    et fonctions. Quand <productname>sepgsql</productname> est en cours
    d'utilisation, des labels de sécurité sont automatiquement affectés
    aux objets de la base au moment de leur création. Ce label est appelé
    un label de sécurité par défaut et est configuré par la politique de
    sécurité du système, qui prend en entrée le label du créateur et le
    label affecté à l'objet parent du nouvel objet.
   </para>

   <para>
    Un nouvel objet base de données hérite en gros du label de sécurité
    de l'objet parent, sauf quand la politique de sécurité a des règles
    spéciales, connues sous le nom de règles de transition, auquel cas
    un label différent est affecté. Pour les schémas, l'objet parent est
    la base de données&nbsp;; pour les colonnes, il s'agit de la table&nbsp;;
    pour les tables, séquences, vues et fonctions, il s'agit du schéma.
   </para>
  </sect3>

  <sect3>
   <title>Droits DML</title>

   <para>
    Pour les tables, <literal>db_table:select</literal>, <literal>db_table:insert</literal>,
    <literal>db_table:update</literal> ou <literal>db_table:delete</literal>
    est vérifié pour toutes les tables cibles référencées, suivant l'ordre
    de l'instruction. De plus, <literal>db_table:select</literal> est
    aussi vérifié pour toutes les tables qui contiennent des colonnes
    référencées dans la clause <literal>WHERE</literal> ou
    <literal>RETURNING</literal>, comme source de données d'un
    <literal>UPDATE</literal>, et ainsi de suite.
   </para>

   <para>
<synopsis>
UPDATE t1 SET x = 2, y = md5sum(y) WHERE z = 100;
</synopsis>

    Dans ce cas, vous devez avoir <literal>db_table:select</literal> en
    plus de <literal>db_table:update</literal> car <literal>t1.a</literal>
    est référencée dans la clause <literal>WHERE</literal>. Les droits
    sur les colonnes seront aussi vérifiés pour chaque colonne référencée.
   </para>

   <para>
    Le client doit être autorisé à accéder à toutes les tables et colonnes
    référencées, même si elles proviennent de vues qui ont été aplaties,
    pour pouvoir appliquer des règles de contrôles d'accès cohérentes
    indépendamment de la manère dont le contenu des tables est référencé.
   </para>

   <para>
    Pour les colonnes, <literal>db_column:select</literal> est vérifié,
    non seulement pour les colonnes lus en utilisant
    <literal>SELECT</literal>, mais aussi pour les colonnes référencées
    par d'autres instructions DML.
   </para>

   <para>
    Bien sûr, il vérifie aussi <literal>db_column:update</literal> ou
    <literal>db_column:insert</literal> sur la colonne en cours de
    modification par <literal>UPDATE</literal> ou <literal>INSERT</literal>.
   </para>

   <para>
<synopsis>
UPDATE t1 SET x = 2, y = md5sum(y) WHERE z = 100;
</synopsis>
    Dans ce cas, il vérifie <literal>db_column:update</literal> sur la
    colonne <literal>t1.x</literal> en cours de mise à jour,
    <literal>db_column:{select update}</literal> sur la colonne
    <literal>t1.y</literal> en cours de mise à jour et référencée, et
    <literal>db_column:select</literal> sur la colonne
    <literal>t1.z</literal> référencée uniquement dans la clause
    <literal>WHERE</literal>. <literal>db_table:{select update}</literal>
    vérifiera aussi la table.
   </para>

   <para>
    Pour les séquences, <literal>db_sequence:get_value</literal> est
    vérifié quand nous référençons un objet séquence en utilisant
    <literal>SELECT</literal>&nbsp;; néanmoins, notez que nous ne vérifions
    pas les droits d'exécution sur les fonctions correspondantes, par
    exemple <literal>lastval()</literal>.
   </para>

   <para>
    Pour les vues, <literal>db_view:expand</literal> devrait être
    vérifié, et ensuite tous les autres droits des objets dus à
    l'aplatissement de la vue, individuellement.
   </para>

   <para>
    Pour les fonctions, <literal>db_procedure:{execute}</literal> est
    défini mais n'est pas vérifié dans cettet version.
   </para>

   <para>
    Le système des droits de la base, par défaut, autorise les
    superutilisateurs de la base à modifier les catalogues systèmes en
    utilisant des commandes DML, et de référencer ou modifier les tables
    TOAST. Ces opérations sont interdites quand
    <productname>sepgsql</productname> est activé.
   </para>
  </sect3>

  <sect3>
   <title>Droits DDL</title>
   <para>
    Sur la commande <xref linkend="sql-security-label"/>,
    <literal>setattr</literal> et <literal>relabelfrom</literal> devraient
    être vérifiés sur l'objet en cours de labelisation avec un ancien
    label de sécurité, puis <literal>relabelto</literal> sur le nouveau
    label de sécurité fourni.
   </para>

   <para>
    Dans le cas où plusieurs fournisseurs de labels sont installés et
    que l'utilisateur essaie de configurer un label de sécurité qui n'est
    pas géré par <productname>SELinux</productname>, seul
    <literal>setattr</literal> devrait être vérifié ii. Ceci n'est pas
    fait dû à des restrictions de l'implémentation.
   </para>
  </sect3>

  <sect3>
   <title>Procédure de confiance</title>
   <para>
    Les procédures de confiance sont similaires aux fonctions dont la
    sécurité est définie à la création ou aux commandes set-uid. 
    <productname>SELinux</productname> propose une fonctionnalité qui
    permet d'autoriser un code de confiance à s'exécuter en utilisant
    un label de sécurité différent de celui du client, généralement pour
    donner un accès hautement contrôlé à des données sensibles (par
    exemple, des lignes peuvent être omises ou la précision des valeurs
    stockées peut être réduite). Que la fonction agisse ou pas comme
    une procédure de confiance est contrôlé par son label de sécurité et
    la politique de sécurité du système d'exploitation. Par exemple&nbsp;:
   </para>

<screen>
postgres=# CREATE TABLE customer (
               cid     int primary key,
               cname   text,
               credit  text
           );
CREATE TABLE
postgres=# SECURITY LABEL ON COLUMN customer.credit
               IS 'system_u:object_r:sepgsql_secret_table_t:s0';
SECURITY LABEL
postgres=# CREATE FUNCTION show_credit(int) RETURNS text
             AS 'SELECT regexp_replace(credit, ''-[0-9]+$'', ''-xxxx'', ''g'')
                        FROM customer WHERE cid = $1'
           LANGUAGE sql;
CREATE FUNCTION
postgres=# SECURITY LABEL ON FUNCTION show_credit(int)
               IS 'system_u:object_r:sepgsql_trusted_proc_exec_t:s0';
SECURITY LABEL
</screen>

   <para>
    Les opérations ci-dessus doivent être réalisées par un utilisateur
    administrateur.
   </para>

<screen>
postgres=# SELECT * FROM customer;
ERROR:  SELinux: security policy violation
postgres=# SELECT cid, cname, show_credit(cid) FROM customer;
 cid | cname  |     show_credit
-----+--------+---------------------
   1 | taro   | 1111-2222-3333-xxxx
   2 | hanako | 5555-6666-7777-xxxx
(2 rows)
</screen>

   <para>
    Dans ce cas, un utilisateur standard ne peut pas faire référence à
    <literal>customer.credit</literal> directement mais une procédure de
    confiance comme <literal>show_credit</literal> nous permet d'afficher
    le numéro de carte de crédit de clients, avec quelques chiffres
    masqués.
   </para>
  </sect3>

  <sect3>
   <title>Divers</title>
   <para>
    Nous rejetons la commande <xref linkend="sql-load"/> car tout module
    chargé pourrait facilement court-circuiter la politique de sécurité.
   </para>

  </sect3>
 </sect2>

 <sect2 id="sepgsql-limitations">
  <title>Limitations</title>

  <variablelist>
   <varlistentry>
    <term>Cache des vecteurs d'accès en espace utilisateur</term>
    <listitem>
     <para>
      <productname>sepgsql</productname> ne supporte pas encore un cache
      des vecteurs d'accès. Une fois ajouté, cela devrait améliorer les
      performances.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Droits DDL</term>
    <listitem>
     <para>
      Dû aux restrictions d'implémentations, les droits DDL ne sont pas
      vérifiés.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Droits DCL</term>
    <listitem>
     <para>
      Dû aux restrictions d'implémentations, les droits DCL ne sont pas
      vérifiés.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Contrôle d'accès au niveau ligne</term>
    <listitem>
     <para>
      <productname>PostgreSQL</productname> ne supporte pas le contrôle
      d'accès au niveau ligne. Du coup, <productname>sepgsql</productname>
      ne le supporte pas non plus.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Canaux cachés</term>
    <listitem>
     <para>
      <productname>sepgsql</productname> n'essaie jamais de cacher
      l'existence d'un objet particulier, même si l'utilisateur n'est
      pas autorisé à y accéder. Par exemple, nous pouvons inférer
      l'existence d'un objet invisible suite à un conflit de clé primaire,
      à des violations de clés étrangèes et ainsi de suite, même si nous
      ne pouvons pas accéder au contenu de ces objets. L'existence d'une
      table secrète ne peut pas être caché. Nous ne faisons que
      verrouiller l'accès à son contenu.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="sepgsql-resources">
  <title>Ressources externes</title>
  <variablelist>
   <varlistentry>
    <term><ulink url="http://wiki.postgresql.org/wiki/SEPostgreSQL">SE-PostgreSQL Introduction</ulink></term>
    <listitem>
     <para>
      Cette page wiki fournit un bref aperçu, le concept de la sécurité,
      l'architecture, l'administration et les fonctionnalités futures.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><ulink url="http://docs.fedoraproject.org/selinux-user-guide/">Fedora SELinux User Guide</ulink></term>
    <listitem>
     <para>
      Ce document fournit une connaissance large pour administrer
      <productname>SELinux</productname> sur vos systèmes.
      Il cible principalement Fedora mais n'y est pas limité.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><ulink url="http://docs.fedoraproject.org/selinux-faq">Fedora SELinux FAQ</ulink></term>
    <listitem>
     <para>
      Ce document répond aux questions fréquemment posées sur
      <productname>SELinux</productname>.
      Il cible principalement Fedora mais n'y est pas limité.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="sepgsql-author">
  <title>Auteur</title>
  <para>
   KaiGai Kohei <email>kaigai@ak.jp.nec.com</email>
  </para>
 </sect2>
</sect1>
