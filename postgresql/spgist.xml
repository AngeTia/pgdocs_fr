<!-- doc/src/sgml/spgist.sgml -->

<chapter id="SPGiST">
<title>Index SP-GiST</title>

   <indexterm>
    <primary>index</primary>
    <secondary>SP-GiST</secondary>
   </indexterm>

<sect1 id="spgist-intro">
 <title>Introduction</title>

 <para>
  <acronym>SP-GiST</acronym> est une abréviation pour les espaces géographiques
  partitionnées avec <acronym>GiST</acronym>. <acronym>SP-GiST</acronym> 
  supporte les arbres de recherche partitionnés, qui facilitent le développement
  d'un grand nombre de structures de données non balancées différentes, comme
  les <foreignphrase>quadtree</foreignphrase>, les arbres k-d et les arbres de
  suffixes (<foreignphrase>suffix trees</foreignphrase>).
  Le principal intérêt de ces structures et la division régulière de l'espace de recherche
  en partitions de taille égales. Les recherches qui correspondent bien avec la règle
  de partitionnement peuvent être très rapides.
 </para>

 <para>
  Ces fameuses structures de données ont été initialement conçues pour une
  exécution en mémoire. Dans la mémoire principale, elles sont généralement
  conçues comme un ensemble de nœuds alloués dynamiquement et reliés entre eux
  par des pointeurs. Cette organisation ne peut pas être transposée directement
  sur disque car ces suites de pointeurs peuvent nécessiter un nombre d'accès
  disque trop important. Au contraire, les structures de données adaptées
  au disque devraient permettre de charger simultanément un grand nombre de données
  (<foreignphrase>high fanout</foreignphrase>) pour minimiser les accès disque.
  Le challenge proposé par <acronym>SP-GiST</acronym> est de faire correspondre
  les nœuds des arbres de recherche avec les pages du disque de manière à ce
  qu'une recherche ne nécessite qu'un faible nombre d'accès disque, même si
  il nécessite de traverser plusieurs nœuds.
 </para>

 <para>
  Tout comme <acronym>GiST</acronym>, <acronym>SP-GiST</acronym> est destiné
  à permettre le développement de types de données personnalisées, disposant
  des méthodes d'accés appropriées, par un expert du domaine plutôt que par 
  un expert en base de données.
 </para>

 <para>
  Une partie des informations fournies ici sont extraites du
  <ulink url="http://www.cs.purdue.edu/spgist/">site web</ulink> du projet
  d'indexation SP-GiST de l'université Purdue.
  L'implémentation de <acronym>SP-GiST</acronym> dans <productname>PostgreSQL</productname>
  est principalement maintenue par Teodor Sigaev et Oleg Bartunov, plus
  d'informations sont disponibles sur leur
  <!-- URL will be changed -->
  <ulink url="http://www.sai.msu.su/~megera/wiki/spgist_dev">site web</ulink>.
 </para>

</sect1>

<sect1 id="spgist-extensibility">
 <title>Extensibilité</title>

 <para>
  <acronym>SP-GiST</acronym> offre une interface avec un haut niveau d'abstraction,
  imposant au développeur des méthodes d'accès de n'implémenter que des méthodes
  spécifiques à un type de donnée spécifié. Le cœur de <acronym>SP-GiST</acronym>
  est responsable de l'efficacité du stockage sur le disque et de la recherche
  dans la structure arborescente. Il s'occupe aussi de la concurrence d'accès
  et des journaux.
 </para>

 <para>
  Les lignes des feuilles d'un arbre <acronym>SP-GiST</acronym> contiennent
  des valeurs du même type de données que la colonne indexée. Les lignes
  des feuilles à la racine contiendront toujours la valeur originale de la
  donnée indexée, mais les lignes des feuilles à des niveaux inférieurs
  peuvent en contenir seulement des représentations réduites, comme
  un suffixe. Dans ce cas, les classes d'opérateur des fonctions supportées
  devront être capables de reconstruire la valeur originale en utilisant les
  informations accumulées dans les lignes intermédiaires au travers du parcours
  de l'arbre et vers le niveau le plus bas.
 </para>

 <para>
  Les lignes intermédiaires sont plus complexes car elles relient des points
  dans l'arbre de recherche. Chaque ligne intermédiaire contient un ensemble
  d'au moins un <firstterm>nœud</firstterme>, qui représente des groupes
  de valeurs similaires de feuilles. Un nœud contient un lien qui mène
  vers un autre nœud de niveau inférieur, ou une petite liste de lignes de
  feuilles qui appartiennent toutes à la même page d'index.
  Chaque nœud a un <firstterm>label</firstterm> qui le décrit. Par exemple,
  dans un arbre à suffixe, le label du nœud peut être le caractère suivant de
  la chaîne de caractère. En option, une ligne intermédiaire peut avoir une valeur
  de <firstterm>préfixe</firstterm> qui décrit tous ses membres. Dans un arbre
  à suffixe, cela peut être le préfixe commun des chaînes représentant les données.
  La valeur du préfixe n'est pas nécessairement réellement un préfixe, mais peut
  être toute donnée utilisée par la classe d'opérateur. Par exemple, pour un 
  <foreignphrase>quadtree</foreignphrase>, il peut stocker le barycentre des
  quatre points représenté par chaque feuille. Une ligne intermédiaire d'un
  <foreignphrase>quadtree</foreignphrase> contiendra aussi quatre nœuds correspondants
  à des points autour de ce point central.
 </para>

 <para>
  Quelques algorithmes de recherche arborescente nécessite la connaissance
  du niveau (ou profondeur) de la ligne en cours, et ainsi le cœur de
  <acronym>SP-GiST</acronym> fournit aux classes d'opérateur la possibilité
  de gérer le décompte des niveaux lors du parcours de l'arbre.
  Il fournit aussi le moyen de reconstruire de façon incrémentale la valeur
  représentée lorsque cela est nécessaire.
 </para>

 <note>
  <para>
   Le code du cœur de <acronym>SP-GiST</acronym> tient aussi compte
   des valeurs NULL. Bien que les index <acronym>SP-GiST</acronym>
   stockent des entrées pour les valeurs NULL dans les colonnes indexées, 
   cette implémentation reste non apparente au code de l'index de classe
   d'opérateur : aucune valeur NULL d'index ou de condition de recherche ne sera
   jamais transmis aux méthodes de la classe d'opérateur (il est convenu
   que les opérateurs <acronym>SP-GiST</acronym> sont stricts et ainsi
   ne peuvent trouver des valeurs NULL). Le cas des valeurs NULL n'est
   ainsi plus abordé dans les paragraphes qui suivent.
  </para>
 </note>

 <para>
  Un index de classe d'opérateur pour <acronym>SP-GiST</acronym> peut
  proposer cinq méthodes personnalisées. Chacune de ces cinq méthodes doit
  suivre la convention qui consiste à accepter deux arguments de type
  <type>internal</type>, le premier étant un pointeur vers une structure C
  contenant les valeurs en entrée de cette méthode, et le second étant un
  pointeur vers une structure C où les valeurs en sortie seront placées. Quatre
  de ces méthodes retournent <type>void</type> car leurs résultats sont présent
  dans la structure en sortie. Mais la méthode <function>leaf_consistent</function>
  retourne en complément une valeur de type <type>boolean</type>. Les méthodes
  ne doivent modifier aucun des champs de la structure en entrée. Dans tous les
  cas, la structure en sortie est initialisée avec des zéros avant l'appel à la
  méthode personnalisée.
 </para>

 <para>
  Les cinq méthodes personnalisées sont&nbsp;:
 </para>

 <variablelist>
    <varlistentry>
     <term><function>config</function></term>
     <listitem>
      <para>
	   Retourne des informations statiques concernant l'implémentation des index,
	   incluant les OID du type de données du préfixe et le type de données
	   du label du nœud.
      </para>
     <para>
      La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à&nbsp;:
<programlisting>
CREATE FUNCTION ma_configuration(internal, internal) RETURNS void ...
</programlisting>
    Le premier argument est un pointeur vers une structure C <structname>spgConfigIn</structname>,
	  qui contient les données en entrée de la fonction.
	  Le second argument est un pointeur vers une structure C <structname>spgConfigOut</structname>,
	  qui permet à la fonction d'y spécifier les données en sortie.
<programlisting>
typedef struct spgConfigIn
{
    Oid         attType;        /* Le type de donnée à indexer */
} spgConfigIn;

typedef struct spgConfigOut
{
    Oid         prefixType;     /* Le type de donnée des préfixe des tuples intermédiaires */
    Oid         labelType;      /* Le type de donnée des labels de nœud des tuples intermédiaires */
    bool        canReturnData;  /* Opclass peut reconstruire les données originales */
    bool        longValuesOK;   /* Opclass sait gérer les valeurs plus grandes qu'une page */
} spgConfigOut;
</programlisting>

    <structfield>attType</structfield> est fourni pour gérer les index polymorphiques
	  de classe d'opérateur. Pour les types de données ordinaires de classe d'opérateur (fixés),
	  il aura toujours la même valeur et peut ainsi être ignoré.
     </para>

     <para>
	    Pour les classes d'opérateurs qui n'utilisent pas de préfixe,
      <structfield>prefixType</structfield> peut être défini à <literal>VOIDOID</literal>.
      De la même façon, pour les classes d'opérateurs qui n'utilisent pas de label de nœud, 
      <structfield>labelType</structfield> peut être défini à <literal>VOIDOID</literal>.
      <structfield>canReturnData</structfield> peut être défini à true si la classe d'opérateur
	    est capable de reconstruire la valeur d'index fournie initialement.
      <structfield>longValuesOK</structfield> doit être défini à true uniquement lorsque
      <structfield>attType</structfield> est de longueur variable et que la classe
	    d'opérateur est capable de segmenter les grandes valeurs en répétant les suffixes
      (voir <xref linkend="spgist-limits"/>).
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>choose</function></term>
     <listitem>
      <para>
	    Choisit une méthode pour insérer une nouvelle valeur dans une ligne intermédiaire.
      </para>

     <para>
      La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à&nbsp;:
<programlisting>
CREATE FUNCTION mon_choix(internal, internal) RETURNS void ...
</programlisting>
    Le premier argument est un pointeur vers une structure C <structname>spgChooseIn</structname>,
	  qui contient les données en entrée de la fonction.
	  Le second argument est un pointeur vers une structure C <structname>spgChooseOut</structname>,
	  qui permet à la fonction d'y spécifier les données en sortie.
<programlisting>
typedef struct spgChooseIn
{
    Datum       datum;          /* donnée initiale à indexer */
    Datum       leafDatum;      /* donnée en cours à stocker dans la feuille */
    int         level;          /* niveau en cours (à partir de 0) */

    /* Données issues de la ligne intermédiaire */
    bool        allTheSame;     /* la ligne contient des valeurs équivalentes ? */
    bool        hasPrefix;      /* la ligne a-t-elle un préfixe? */
    Datum       prefixDatum;    /* si c'est le cas, la valeur de ce préfixe */
    int         nNodes;         /* nombre de nœuds dans la ligne intermédiaire */
    Datum      *nodeLabels;     /* valeurs du label du nœud (NULL sinon) */
} spgChooseIn;

typedef enum spgChooseResultType
{
    spgMatchNode = 1,           /* descend dans le nœud existant */
    spgAddNode,                 /* ajoute un nœud dans la ligne intermédiaire */
    spgSplitTuple               /* scinde une ligne intermédiaire (modifie son préfixe) */
} spgChooseResultType;

typedef struct spgChooseOut
{
    spgChooseResultType resultType;     /* code d'action, voir plus bas */
    union
    {
        struct                  /* resultats de spgMatchNode */
        {
            int         nodeN;      /* descend dans ce nœud (à partir de 0) */
            int         levelAdd;   /* incrémente le niveau de cette valeur */
            Datum       restDatum;  /* nouvelle valeur de la feuille */
        }           matchNode;
        struct                  /* résultats de spgAddNode */
        {
            Datum       nodeLabel;  /* nouveau label du nœud */
            int         nodeN;      /* là où l'insérer (à partir de 0) */
        }           addNode;
        struct                  /* résultats pour spgSplitTuple */
        {
            /* Informations pour former a nouveau tuple intermédiaire avec un nœud */
            bool        prefixHasPrefix;    /* la ligne doit-elle avoir un préfixe ? */
            Datum       prefixPrefixDatum;  /* si oui, sa valeur */
            Datum       nodeLabel;          /* label du nœud */

            /* Informations pour former une nouvelle ligne intermédaire de niveau inférieur 
			à partir de tous les anciens nœuds */
            bool        postfixHasPrefix;   /* la ligne doit-elle avoir un préfixe ? */
            Datum       postfixPrefixDatum; /* si oui, sa valeur */
        }           splitTuple;
    }           result;
} spgChooseOut;
</programlisting>

       <structfield>datum</structfield> est la valeur initiale de la donnée qui
       a été insérée dans l'index.
       <structfield>leafDatum</structfield> est initialement le même que
       <structfield>datum</structfield>, mais peut changer à des niveaux inférieurs de l'arbre
       si la fonction <function>choose</function> ou <function>picksplit</function>
       change cette valeur. Lorsque la recherche liée à l'insertion atteint une feuille,
	     la valeur actuelle de <structfield>leafDatum</structfield> sera stockée
	     dans la nouvelle ligne de feuille créée.
       <structfield>level</structfield> est le niveau actuel de la ligne
       intermédiaire, en considérant que 0 est le niveau racine.
       <structfield>allTheSame</structfield> est true si la ligne intermédiaire
       actuelle est marquée comme contenant plusieurs nœuds équivalents.
       (voir <xref linkend="spgist-all-the-same"/>).
       <structfield>hasPrefix</structfield> est vrai si la ligne intermédiaire
       actuelle contient un préfixe&nbsp;; si c'est le cas, 
       <structfield>prefixDatum</structfield> est sa valeur.
       <structfield>nNodes</structfield> est le nombre de nœuds enfants contenus
       dans la ligne intermédiaire, et <structfield>nodeLabels</structfield> est
       un tableau des valeurs de leurs labels, ou NULL s'il n'y a pas de labels.
      </para>

      <para>
	   La fonction <function>choose</function> peut déterminer si la nouvelle
	   valeur correspond à un des nœuds enfants existants, ou si un nouvel
	   enfant doit être ajouté, ou si la nouvelle valeur n'est pas consistante
	   avec les préfixes de ligne et qu'ainsi la ligne intermédiaire doit être
	   découpée pour créer un préfixe moins restrictif.
      </para>

      <para>
	   Si la nouvelle valeur correspond à un des nœuds enfants existants,
	   définir <structfield>resultType</structfield> à <literal>spgMatchNode</literal>.
       et définir <structfield>nodeN</structfield> à l'index (à partir de 0) du nœud dans
       le tableau de nœud.
       Définir <structfield>levelAdd</structfield> à l'incrément de
       <structfield>level</structfield> nécessaire pour descendre au travers de ce nœud,
	   ou le laisser à 0 si la classe d'opérateur n'utilise pas de niveaux.
       Définir <structfield>restDatum</structfield> à la valeur de <structfield>datum</structfield>
       si la classe d'opérateur ne modifie pas les valeurs d'un niveau au suivant,
	   ou dans le cas contraire, définir la valeur modifiée pour être utilisée comme
	   valeur de <structfield>leafDatum</structfield> au niveau suivant.
      </para>

      <para>
	   Si un nouveau nœud enfant doit être ajouté,
       définir <structfield>resultType</structfield> à <literal>spgAddNode</literal>.
       Définir <structfield>nodeLabel</structfield> au label à utiliser pour le nouveau nœud,
	   et définir <structfield>nodeN</structfield> à l'index (de 0) auquel insérer
	   le nœud dans le tableau de nœud.
	   Après que ce nœud ait été ajouté, la fonction <function>choose</function>
	   sera appelée à nouveau avec la ligne intermédiaire modifiée.
	   Cet appel devrait produire un résultat <literal>spgMatchNode</literal>.
      </para>

      <para>
	   Si la nouvelle valeur est cohérente avec le préfixe de ligne,
	   définir <structfield>resultType</structfield> à <literal>spgSplitTuple</literal>.
	   Cette action déplace tous les nœuds existants dans le nouveau niveau inférieur
	   de la ligne intermédiaire, et remplace la ligne intermédiaire existant avec une ligne
	   qui dispose d'un unique nœud qui est lié à la nouvelle ligne intermédiaire de niveau inférieur.
	   Définir <structfield>prefixHasPrefix</structfield> pour indiquer si les nouvelles lignes
	   supérieures doivent avoir un préfixe, et si c'est le cas, définir 
       <structfield>prefixPrefixDatum</structfield> à la valeur du préfixe. Cette nouvelle
	   valeur de préfixe doit être suffisamment moins restrictive que l'original pour accepter
	   que la nouvelle valeur soit indexée, et ne doit pas être plus longue que le préfixe original.
       Définir <structfield>nodeLabel</structfield> à la valeur du label à utiliser pour le
	   nœud qui pointera vers la ligne intermédiaire de niveau inférieur.
       Définir <structfield>postfixHasPrefix</structfield> pour indiquer si la nouvelle
	   ligne intermédiaire de niveau inférieur aura un préfixe, et dans ce cas définir
       <structfield>postfixPrefixDatum</structfield> à la valeur du préfixe. La
	   combinaison de ces deux préfixes et le label additionnel doit
	   avoir la même signification que le préfixe original car il n'y a pas de moyen
	   de modifier le label du nœud qui est déplacé vers la nouvelle ligne de niveau inférieur,
	   ni de modifier une quelconque entrée d'index enfant.
	   Après que ce nœud ait été découpé, la fonction <function>choose</function>
	   sera appelée à nouveau avec la ligne intermédiaire de remplacement.
	   Cet appel devrait retourner un <literal>spgAddNode</literal> car,
	   à priori, le label du nœud ajouté lors de l'étape de découpage ne correspondra
	   pas à la nouvelle valeur. Ainsi, après cette étape, il y aura une troisième étape
	   qui retournera finalement <literal>spgMatchNode</literal> et permettra l'insertion
	   pour descendre au niveau feuille.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>picksplit</function></term>
     <listitem>
      <para>
	   Décide de la manière à suivre pour créer une ligne intermédiaire à partir d'un ensemble de lignes de feuilles.
      </para>

      <para>
	    La déclaration de fonction <acronym>SQL</acronym> doit ressembler à&nbsp;:
<programlisting>
CREATE FUNCTION mon_decoupage(internal, internal) RETURNS void ...
</programlisting>
      Le premier argument est un pointeur vers une structure C <structname>spgPickSplitIn</structname>,
	  qui contient les données en entrée de la fonction.
	  Le second argument est un pointeur vers une structure C <structname>spgPickSplitOut</structname>,
	  qui permet à la fonction d'y spécifier les données en sortie.
<programlisting>
typedef struct spgPickSplitIn
{
    int         nTuples;        /* nombre de lignes feuilles */
    Datum      *datums;         /* leur données (tableau de taille nTuples) */
    int         level;          /* niveau actuel (à partir de 0) */
} spgPickSplitIn;

typedef struct spgPickSplitOut
{
    bool        hasPrefix;      /* les nouvelles lignes intermédiaires doivent-elles avoir un préfixe ? */
    Datum       prefixDatum;    /* si oui, la valeur du préfixe */

    int         nNodes;         /* nombre de nœud pour une nouvelle ligne intermédiaire */
    Datum      *nodeLabels;     /* leurs labels (ou NULL s'il n'y a aucun label) */

    int        *mapTuplesToNodes;   /* index du nœud de chaque lgne feuille */
    Datum      *leafTupleDatums;    /* données à stocker dans chaque nouvelle ligne feuille */
} spgPickSplitOut;
</programlisting>

       <structfield>nTuples</structfield> est le nombre de lignes feuilles fournies.
       <structfield>datums</structfield> est un tableau de leurs données.
       <structfield>level</structfield> est le niveau actuel que les lignes feuille concernées
	   partagent, qui deviendra le niveau de la nouvelle ligne intermédiaire.
      </para>

      <para>
	   Définir <structfield>hasPrefix</structfield> pour indiquer que la nouvelle ligne intermédiaire
	   doit avoir un préfixe, et dans ce cas, définir <structfield>prefixDatum</structfield>
	   à la valeur de ce préfixe.
       Définir <structfield>nNodes</structfield> pour indiquer le nombre de nœuds que contiendra
	   la nouvelle ligne intermédiaire, et 
	   spécifier dans <structfield>nodeLabels</structfield> un tableau de leurs labels.
       (si les nœuds ne nécessitent pas de label, définir <structfield>nodeLabels</structfield>
       à NULL&nbsp;; voir <xref linkend="spgist-null-labels"/> pour plus de détails.)
       Attribuer à <structfield>mapTuplesToNodes</structfield> un tableau des index (à partir de zéro)
	   des nœuds auquels seront assignés chaque ligne feuille.
	   Attribuer à <structfield>leafTupleDatums</structfield> un tableau des valeurs à
	   stocker dans la nouvelle ligne de feuilles (ces valeurs seront les mêmes que celles des données
	   <structfield>datums</structfield> fournies en paramètre si la classe d'opérateur ne modifie
	   pas les données d'un niveau à un autre).
       À noter que la fonction <function>picksplit</function> est responsable de l'allocation de mémoire
	   des tableaux <structfield>nodeLabels</structfield>, <structfield>mapTuplesToNodes</structfield> et
       <structfield>leafTupleDatums</structfield>.
      </para>

      <para>
	   Si plus d'une ligne de feuille est fournie, il est nécessaire que la fonction
	   <function>picksplit</function> les classent en plus d'un nœud.
	   Dans le cas contraire, il ne sera pas possible de répartir les lignes des feuilles
	   sur des pages différentes, ce qui est pourtant l'objectif de cette opération.
	   À cet effet, si la fonction <function>picksplit</function> se termine après avoir
	   réparti toutes les lignes des feuilles dans le même nœud, le code du moteur de
	   SP-GiST ne tiendra pas compte de cette décision, et générera une ligne intermédiaire
	   dans lequel chaque ligne de feuille sera assigné aléatoirement à plusieurs nœuds
	   de labels identiques. De telles lignes sont marquées <literal>allTheSame</literal> pour
	   garder une trace de cette décision. Les fonctions <function>choose</function> et
	   <function>inner_consistent</function> doivent tenir compte de ces lignes
	   intermédiaires.
	   Voir <xref linkend="spgist-all-the-same"/> pour plus d'informations.
      </para>

      <para>
       <function>picksplit</function> peut être appliqué à une unique ligne de feuille
	   lorsque la fonction <function>config</function> définit <structfield>longValuesOK</structfield>
	   à true et qu'une valeur plus large qu'une page est donnée en paramètre.
	   Dans ce cas, l'objectif de la fonction est d'extraire un préfixe et de produire
	   une donnée de feuille moins longue. Cet appel sera répété jusqu'à ce que la donnée
	   de la feuille soit suffisamment petite pour tenir dans une page. Voir
	   <xref linkend="spgist-limits"/> pour plus d'information.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>inner_consistent</function></term>
     <listitem>
      <para>
	   Retourne un ensemble de nœuds (branches) à suivre durant une recherche arborescente.
      </para>

      <para>
	   La déclaration <acronym>SQL</acronym> de cette fonction doit ressembler à&nbsp;:
<programlisting>
CREATE FUNCTION ma_suite_de_nœuds(internal, internal) RETURNS void ...
</programlisting>
      Le premier argument est un pointeur vers une structure C <structname>spgInnerConsistentIn</structname>,
	  qui contient les données en entrée de la fonction.
	  Le second argument est un pointeur vers une structure C <structname>spgInnerConsistentOut</structname>,
	  qui permet à la fonction d'y spécifier les données en sortie.

<programlisting>
typedef struct spgInnerConsistentIn
{
    ScanKey     scankeys;       /* tableau d'opérateurs et de valeurs de comparaison */
    int         nkeys;          /* taille du tableau */

    Datum       reconstructedValue;     /* valeur reconstruite au niveau parent */
    int         level;          /* niveau actuel (à partir de zéro) */
    bool        returnData;     /* retourner la valeur originale ? */

    /* Données du tuple intermédiaire en cours */
    bool        allTheSame;     /* la ligne est-elle identifiée comme all-the-same ? */
    bool        hasPrefix;      /* la ligne a-t-elle un préfixe ? */
    Datum       prefixDatum;    /* dans ce cas, la valeur du préfixe */
    int         nNodes;         /* nombre de nœuds dans la ligne intermédiaire */
    Datum      *nodeLabels;     /* labels du nœud (NULL si pas de labels) */
} spgInnerConsistentIn;

typedef struct spgInnerConsistentOut
{
    int         nNodes;         /* nombre de nœuds enfants à visiter */
    int        *nodeNumbers;    /* leurs index dans le tableau de nœuds */
    int        *levelAdds;      /* l'incrément à apporter au niveau pour chaque enfant */
    Datum      *reconstructedValues;    /* valeurs reconstruites associées */
} spgInnerConsistentOut;
</programlisting>

       Le tableau <structfield>scankeys</structfield>, de longueur <structfield>nkeys</structfield>,
	   décrit les conditions de recherche d'index. Ces conditions sont combinées avec un opérateur
	   ET. Seuls les entrées d'index qui correspondent à toutes ces conditions sont conservées
	   (à noter que <structfield>nkeys</structfield> = 0 implique que toutes les entrées d'index sont
	   conservées). Généralement, la fonction <function>inner_consistent</function> ne tient compte que
	   des champs <structfield>sk_strategy</structfield> et <structfield>sk_argument</structfield>
	   de chaque entrée de tableau, qui fournissent respectivement l'opérateur indexé et la valeur de comparaison.
	   En particulier, il n'est pas nécessaire de vérifier si <structfield>sk_flags</structfield> est NULL
	   car le moteur de SP-GiST aura complété cette valeur.
       <structfield>reconstructedValue</structfield> est la valeur reconstruite pour la ligne parent.
       La valeur est <literal>(Datum) 0</literal> au niveau le plus haut ou si la fonction
       <function>inner_consistent</function> ne fournit pas de valeur pour le niveau supérieur.
       <structfield>level</structfield> est le niveau actuel de la ligne intermédiaire, en commençant à 0 pour le niveau racine.
       <structfield>returnData</structfield> est <literal>true</literal> pour la valeur reconstruite pour cette requête.
	   Ce n'est le cas que si la fonction <function>config</function> définit <structfield>canReturnData</structfield>.
       <structfield>allTheSame</structfield> est true si la ligne intermédiaire en cours est
	   marquée <quote>all-the-same</quote>. Dans ce cas, tous les nœuds ont le même label (si un label est défini) et
	   ainsi soit ils correspondent tous à la requête, soit aucun ne correspond (voir <xref linkend="spgist-all-the-same"/>).
       <structfield>hasPrefix</structfield> est true si la ligne intermédiaire en cours contient un préfixe.
	   Dans ce cas, <structfield>prefixDatum</structfield> est sa valeur.
       <structfield>nNodes</structfield> est le nombre de nœuds enfants de la ligne intermédiaire, et
       <structfield>nodeLabels</structfield> est un tableau de leurs labels, ou NULL
	   si les nœuds n'ont pas de labels.
      </para>

      <para>
       <structfield>nNodes</structfield> doit être défini comme le nombre de nœuds enfants qui doivent
	   être visités durant la recherche, et
       <structfield>nodeNumbers</structfield> doit être défini comme le tableau de leurs index.
	   Si la classe d'opérateur effectue le suivi des niveaux, définir 
       <structfield>levelAdds</structfield> comme un tableau des incréments à ajouter aux niveaux
	   pour descendre vers chaque nœud à visiter (dans la plupart des cas, les incréments seront
	   les mêmes pour chaque nœud, mais ce n'est pas systématique, et ainsi un tableau est employé).
	   Si la reconstruction de la valeur est nécessaire, définir
       <structfield>reconstructedValues</structfield> comme le tableau des valeurs reconstruites
	   pour chaque nœud enfant à visiter. Sinon, laisser
       <structfield>reconstructedValues</structfield> à la valeur NULL.
	   Notez que la fonction <function>inner_consistent</function> est
	   responsable de l'allocation mémoire des tableaux <structfield>nodeNumbers</structfield>,
	   <structfield>levelAdds</structfield> et
       <structfield>reconstructedValues</structfield>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>leaf_consistent</function></term>
     <listitem>
      <para>
	   Retourne true si une ligne de feuille satisfait une requête.
      </para>

      <para>
	  La déclaration <acronym>SQL</acronym> de cette fonction doit ressembler à&nbsp;:
<programlisting>
CREATE FUNCTION ma_fonction_leaf_consistent(internal, internal) RETURNS bool ...
</programlisting>
      Le premier argument est un pointeur vers une structure C <structname>spgLeafConsistentIn</structname>,
	  qui contient les données en entrée de la fonction.
	  Le second argument est un pointeur vers une structure C <structname>spgLeafConsistentOut</structname>,
	  qui permet à la fonction d'y spécifier les données en sortie.

<programlisting>
typedef struct spgLeafConsistentIn
{
    ScanKey     scankeys;       /* tableau d'opérateurs et de valeurs de comparaison */
    int         nkeys;          /* longueur d'un tableau */

    Datum       reconstructedValue;     /* valeur reconstruite au parent */
    int         level;          /* niveau actuel (à partir de zéro) */
    bool        returnData;     /* les données originales doivent-elles être reconstruites ? */

    Datum       leafDatum;      /* données de la ligne de feuille */
} spgLeafConsistentIn;

typedef struct spgLeafConsistentOut
{
    Datum       leafValue;      /* données originales reconstruites, le cas échéant */
    bool        recheck;        /* définir à true si l'opérateur doit être revérifié */
} spgLeafConsistentOut;
</programlisting>

       Le tableau <structfield>scankeys</structfield>, de longueur <structfield>nkeys</structfield>,
       décrit les conditions de recherche dans l'index. Ces conditions sont uniquement combinées avec AND &mdash;
	   Seules les entrées d'index qui satisfont toutes les conditions satisfont la requête
	   (Notez que <structfield>nkeys</structfield> = 0 implique que toutes les entrées de l'index satisfont la requête).
	   Généralement, la fonction de recherche ne tient compte que des champs <structfield>sk_strategy</structfield> et
	   <structfield>sk_argument</structfield> de chaque entrée du tableau, qui correspondent
	   respectivement à l'opérateur indexable et à la valeur de comparaison.
	   En particulier, il n'est pas nécessaire de vérifier <structfield>sk_flags</structfield> pour
	   savoir que la valeur de comparaison est NULL car le code du cœur de SP-GiST filtre
	   ces conditions.
       <structfield>reconstructedValue</structfield> est la valeur reconstruite pour la ligne parent&nbsp;;
	   Il s'agit de <literal>(Datum) 0</literal> au niveau racine ou si la fonction
       <function>inner_consistent</function> ne fournit pas de valeur au niveau parent.
       <structfield>level</structfield> est le niveau actuel de la ligne de feuille, qui commence à zéro
	   pour le niveau racine.
       <structfield>returnData</structfield> est <literal>true</literal> s'il est nécessaire de reconstruire
	   les données pour cette requête. Cela ne sera le cas que lorsque la fonction
       <function>config</function> vérifie <structfield>canReturnData</structfield>.
       <structfield>leafDatum</structfield> est la valeur de la clé stockée dans la ligne de feuille en cours.
      </para>

      <para>
	   La fonction doit retourner <literal>true</literal> si la ligne de feuille correspond à la requête
	   ou <literal>false</literal> sinon. Dans le cas où la valeur serait <literal>true</literal>,
       et que <structfield>returnData</structfield> est <literal>true</literal> alors
       <structfield>leafValue</structfield> doit être défini à la valeur originale fournie
	   pour être indexée pour cette ligne de feuille.
	   <structfield>recheck</structfield> peut être défini à <literal>true</literal> si la correspondance
	   est incertaine et ainsi l'opérateur doit être réappliqué à la pile de ligne courante
	   pour vérifier la correspondance.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  <para>
   Toutes les méthodes permettant d'utiliser SP-GiST sont normalement exécutées dans un 
   contexte mémoire de courte durée, c'est-à-dire que <varname>CurrentMemoryContext</varname> sera remis à zéro
   après le traitement de chaque ligne. Il n'est cependant pas réellement important de se soucier
   de désallouer la mémoire allouée avec palloc (la méthode <function>config</function> est
   une exception&nbsp;: elle essaiera d'éviter les fuites mémoire. Mais généralement, la méthode
   <function>config</function> ne nécessite rien si ce n'est assigner des constantes
   aux structures passées en paramètre).
  </para>

  <para>
   Si la colonne indexée a un type de donnée collationnable, l'index de collationnement
   sera passé à toutes les méthodes, en utilisant le mécanisme standard
   <function>PG_GET_COLLATION()</function>.
  </para>

</sect1>

<sect1 id="spgist-implementation">
 <title>Implémentation</title>

  <para>
   Cette section traite des détails d'implémentation et d'autres astuces qui sont
   utiles à connaître pour implémenter des opérateurs de classe <acronym>SP-GiST</acronym>.
  </para>

 <sect2 id="spgist-limits">
  <title>Limites de SP-GiST</title>

  <para>
   Les lignes de feuille individuelles et les lignes intermédiaires doivent tenir dans une
   unique page d'index (8 Ko par défaut). Cependant, lorsque des données de taille variable
   sont indexées, les longues valeurs ne sont uniquement supportées que par les arbres suffixés,
   dans lesquels chaque niveau de l'arbre contient un préfixe qui est suffisamment petit
   pour tenir dans une page. La classe d'opérateur doit uniquement définir <structfield>longValuesOK</structfield>
   à TRUE si elle supporte ce cas de figure. Dans le cas contraire, le cœur de <acronym>SP-GiST</acronym>
   rejètera l'indexation d'une valeur plus large qu'une page.
  </para>

  <para>
   De la même manière, il est de la responsabilité de l'opérateur de classe 
   de s'assurer que la taille des lignes intermédiaires soit plus petite
   qu'une page&nbsp;; cela limite le nombre de nœuds enfants qui peuvent être utilisés
   dans une ligne intermédiaire, ainsi que la taille maximum d'un préfixe.
  </para>

  <para>
   Une autre limite est que lorsqu'un nœud de ligne intermédiaire pointe vers
   un ensemble de lignes de feuille, ces lignes doivent toutes être dans la même
   page d'index (il s'agit d'une décision d'architecture pour réduire le temps de recherche
   et utiliser moins de mémoire dans les liens qui lient de telles lignes ensemble).
   Si l'ensemble de lignes de feuille grandit plus qu'une page, un découpage est réalisé
   et un nœud intermédiaire est inséré. Pour que ce mécanisme résolve le problème,
   le nouveau nœud intermédiaire <emphasis>doit</emphasis> diviser l'ensemble de valeurs
   de feuilles en plus d'un groupe de nœuds. Si la fonction <function>picksplit</function>
   de la classe d'opérateur n'y parvient pas, le cœur de <acronym>SP-GiST</acronym> met en œuvre
   des mesures extraordinaires telles que décrites dans <xref linkend="spgist-all-the-same"/>.
  </para>
 </sect2>

 <sect2 id="spgist-null-labels">
  <title>SP-GiST sans label de nœud</title>

  <para>
   Certains algorithmes d'arbres utilisent un ensemble de nœuds figé pour chaque ligne intermédiaire&nbsp;;
   par exemple, l'arbre quad-tree impose exactement quatre nœuds correspondant aux quatre coins autour du
   centroïde de la ligne intermédiaire. Dans ce cas, le code travaille généralement avec les nœuds
   au moyen de leur identifiant, et le besoin de label de nœud ne se fait pas ressentir.
   Pour supprimer les labels de nœud (et ainsi gagner de l'espace), la fonction <function>picksplit</function>
   peut retourner NULL pour le tableau <structfield>nodeLabels</structfield>.
   Cela aura pour effet d'obtenir une valeur NULL pour <structfield>nodeLabels</structfield> lors des appels
   aux fonctions <function>choose</function> et <function>inner_consistent</function>.
   En principe, les labels de nœuds peuvent être utilisés par certaines lignes intermédiaires, et ignorés
   pour les autres de même index.
  </para>

  <para>
   Lorsqu'une ligne intermédaire sans label est concerné, la fonction <function>choose</function>
   ne peut pas retourner <literal>spgAddNode</literal> car l'ensemble
   des nœuds est supposé être fixé dans de tels cas. De même, il n'y a aucune raison
   de générer un nœud sans label dans les actions <literal>spgSplitTuple</literal> à partir
   du moment où une action <literal>spgAddNode</literal> est attendue.
  </para>
 </sect2>

 <sect2 id="spgist-all-the-same">
  <title>Lignes intermédiaires <quote>All-the-same</quote></title>

  <para>
   Le cœur de <acronym>SP-GiST</acronym> peut surcharger les résultats de
   la fonction <function>picksplit</function> de l'opérateur de classe lorsque
   <function>picksplit</function> ne réussit pas à diviser la valeur de la feuille fournie en
   au moins un nœud. Dans ce cas, la nouvelle ligne intermédiaire
   est créée avec de multiples nœuds qui ont tous le même label (si un label est défini)
   qui est celui attribué au nœud utilisé par <function>picksplit</function> et les valeurs
   des feuilles sont divisées aléatoirement entre les nœuds équivalents.
   Le drapeau <literal>allTheSame</literal> est activé sur la ligne intermédiaire pour signifier aux fonctions
   <function>choose</function> et <function>inner_consistent</function> que la
   ligne n'a pas l'ensemble de nœud attendu.
  </para>

  <para>
   Lorsque le cas d'une ligne <literal>allTheSame</literal> est rencontré, le résultat de la fonction <function>choose</function>
   sous la forme <literal>spgMatchNode</literal> est interprété de manière à ce que la nouvelle valeur
   puisse être assignée à chacun des nœuds équivalents&nbsp;; le code du cœur de <acronym>SP-GiST</acronym> ignorera
   la valeur <structfield>nodeN</structfield> fournie et descendra dans l'un des nœuds enfants
   au hasard (pour conserver l'équilibre de l'arbre). Il s'agirait d'une erreur si 
   la fonction <function>choose</function> retournait <literal>spgAddNode</literal> car tous
   les nœuds ne seraient pas équivalent&nbsp;; l'action <literal>spgSplitTuple</literal> doit être utilisée
   si la valeur à insérer ne correspond pas aux nœuds existants.
  </para>

  <para>
   Lorsque le cas d'une ligne <literal>allTheSame</literal> est rencontré, la fonction
   <function>inner_consistent</function> peut tout autant retourner tous les nœuds ou aucun des nœuds ciblés
   pour continuer la recherche indexée car ils sont tous équivalents.
   Cela peut éventuellement nécessiter du code spécifique, suivant le support
   réalisé par la fonction <function>inner_consistent</function> concernant
   la signification des nœuds.
  </para>
 </sect2>

</sect1>

<sect1 id="spgist-examples">
 <title>Exemples</title>

 <para>
  Les sources de <productname>PostgreSQL</productname> incluent
  plusieurs exemples de classes d'opérateur d'index pour <acronym>SP-GiST</acronym>.
  Le cœur du système fournit actuellement des arbres à suffixe pour les colonnes textuelles
  et deux types d'arbre concernant les points&nbsp;: quad-tree et arbre k-d.
  Voir <filename>src/backend/access/spgist/</filename> pour étudier leur code source.
 </para>

</sect1>

</chapter>
