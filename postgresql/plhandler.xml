<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

 <chapter id="plhandler">
   <title>Écrire un gestionnaire de langage procédural</title>

   <indexterm zone="plhandler">
    <primary>langage procédural</primary>
    <secondary>gestionnaire</secondary>
   </indexterm>

   <para>
    Tous les appels de fonctions écrites dans un langage autre que celui
    de l'interface <quote>version 1</quote> pour les langages compilés (ce qui
    inclut les fonctions dans les langages procéduraux utilisateur, les
    fonctions SQL et les fonctions utilisant l'interface de langage compilé
    version 0), passent par une fonction spécifique au langage du
    <firstterm>gestionnaire d'appels</firstterm>.
    Le gestionnaire d'appels exécute la fonction de manière appropriée, 
    par exemple en interprétant le code source fourni. Ce chapitre 
    décrit l'écriture du gestionnaire d'appels d'un nouveau langage
    procédural.
   </para>

   <para>
    Le gestionnaire d'appel d'un langage procédural est une fonction
    <quote>normale</quote> qui doit être écrite dans un langage compilé tel que
    le C, en utilisant l'interface version-1, et enregistrée sous
    <productname>PostgreSQL</productname> comme une fonction sans argument
    et retournant le type <type>language_handler</type>. Ce pseudo-type spécial
    identifie la fonction comme gestionnaire d'appel et empêche son appel 
    à partir des commandes SQL.
   </para>

   <para>
    L'appel du gestionnaire d'appels est identique à celui de toute
    autre fonction&nbsp;: il reçoit un pointeur de <type>structure</type>
    <structname>FunctionCallInfoData</structname> qui contient les
    valeurs des arguments et d'autres informations de la fonction appelée.
    Il retourne un résultat <type>Datum</type> (et, initialise
    le champ <structfield>isnull</structfield> de la structure
    <structname>FunctionCallInfoData</structname> si un résultat SQL NULL doit
    être retourné). La différence entre un gestionnaire d'appels et une
    fonction ordinaire se situe au niveau du champ
    <structfield>flinfo-&gt;fn_oid</structfield> de la structure
    <structname>FunctionCallInfoData</structname>. Dans le cas du gestionnaire
    d'appels, il contiendra l'OID de la fonction à appeler, et non pas celui du
    gestionnaire d'appels lui-même.
    Le gestionnaire d'appels utilise ce champ pour déterminer la
    fonction à exécuter. De plus, la liste d'arguments passée a été dressée 
    à partir de la déclaration de la fonction cible, et non pas en
    fonction du gestionnaire d'appels.
   </para>

   <para>
    C'est le gestionnaire d'appels qui récupère l'entrée de la
    fonction dans la table système <classname>pg_proc</classname> et
    analyse les types des arguments et de la valeur de retour de la fonction
    appelée. La clause <literal>AS</literal> de la commande
    <command>CREATE FUNCTION</command> se situe dans la
    colonne <literal>prosrc</literal> de
    <classname>pg_proc</classname>. Il s'agit généralement du texte source du
    langage procédural lui-même (comme pour PL/Tcl) mais, en théorie, cela
    peut être un chemin vers un fichier ou tout ce qui indique
    au gestionnaire d'appels les détails des actions à effectuer.
   </para>

   <para>
    Souvent, la même fonction est appelée plusieurs fois dans la même
    instruction SQL.
    L'utilisation du champ <structfield>flinfo-&gt;fn_extra</structfield> 
    évite au gestionnaire d'appels de répéter la recherche des informations 
    concernant la fonction appelée. Ce champ, initialement
    <symbol>NULL</symbol>, peut être configuré par le gestionnaire d'appels pour
    pointer sur l'information concernant la fonction appelée. Lors des appels
    suivants, si <structfield>flinfo-&gt;fn_extra</structfield> est différent
    de <symbol>NULL</symbol>, alors il peut être utilisé et l'étape de
    recherche d'information évitée. Le gestionnaire d'appels doit
    s'assurer que <structfield>flinfo-&gt;fn_extra</structfield> pointe sur une 
    zone mémoire qui restera allouée au moins jusqu'à la fin de la requête en
    cours, car une structure de données <structname>FmgrInfo</structname> peut
    être conservée aussi longtemps. Cela peut-être obtenu par l'allocation
    des données supplémentaires dans le contexte mémoire spécifié par
    <structfield>flinfo-&gt;fn_mcxt</structfield>&nbsp;; de telles données
    ont la même espérance de vie que <structname>FmgrInfo</structname>. 
    Le gestionnaire peut également choisir d'utiliser un contexte mémoire de
    plus longue espérance de vie de façon à
    mettre en cache sur plusieurs
    requêtes les informations concernant les définitions des fonctions.
   </para>

   <para>
    Lorsqu'une fonction en langage procédural est appelée via un déclencheur,
    aucun argument ne lui est passé de façon traditionnelle mais le champ
    <structfield>context</structfield> de
    <structname>FunctionCallInfoData</structname> pointe sur une structure
    <structname>TriggerData</structname>. Il n'est pas
    <symbol>NULL</symbol> comme c'est le cas dans les appels de fonctions standard.
    Un gestionnaire de langage doit fournir les mécanismes pour que les
    fonctions de langages procéduraux obtiennent les informations du
    déclencheur.
   </para>

   <para>
    Voici un modèle de gestionnaire de langage procédural écrit en C&nbsp;:
<programlisting>#include "postgres.h"
#include "executor/spi.h"
#include "commands/trigger.h"
#include "fmgr.h"
#include "access/heapam.h"
#include "utils/syscache.h"
#include "catalog/pg_proc.h"
#include "catalog/pg_type.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

PG_FUNCTION_INFO_V1(plsample_call_handler);

Datum
plsample_call_handler(PG_FUNCTION_ARGS)
{
    Datum          retval;

    if (CALLED_AS_TRIGGER(fcinfo))
    {
        /*
         * Appelé comme procédure de déclencheur
         */
        TriggerData    *trigdata = (TriggerData *) fcinfo-&gt;context;

        retval = ...
    }
    else
    {
        /*
         * Appelé en tant que fonction
         */

        retval = ...
    }

    return retval;
}
</programlisting>
    Il suffit de remplacer les points de suspension par quelques milliers de
    lignes de codes pour compléter ce modèle.
   </para>

   <para>
    Lorsque la fonction du gestionnaire est compilée dans un module chargeable
    (voir <xref linkend="dfunc"/>), les commandes suivantes enregistrent le langage
    procédural défini dans l'exemple&nbsp;:
<programlisting>CREATE FUNCTION plsample_call_handler() RETURNS language_handler
    AS '<replaceable>nomfichier</replaceable>'
    LANGUAGE C;
CREATE LANGUAGE plsample
    HANDLER plsample_call_handler;
</programlisting>
   </para>

   <para>
    Bien que fournir un gestionnaire d'appels est suffisant pour créer un
    langage de procédures minimal, il existe deux autres fonctions qui peuvent
    être fournies pour faciliter l'utilisation du langage. Ce sont les
    fonctions de validation (<firstterm>validator</firstterm>) et de
    traitement en ligne (<firstterm>inline handler</firstterm>). Une fonction
    de validation peut être fournie pour activer une vérification spécifique
    au langage lors du <xref linkend="sql-createfunction"/>. Une fonction de
    traitement en ligne sera utilisé pour supporter les blocs de code anonymes
    exécutés via la commande <xref linkend="sql-do"/>.
   </para>

   <para>
    Si une fonction de validation est fournie par un langage de procédures,
    elle doit être déclarée comme une fonction prenant un seul paramètre, de
    type <type>oid</type>. Le résultat de la validation est ignoré, donc elle
    peut renvoyer le type <type>void</type>. La fonction de validation sera
    appelée à la fin de la commande <command>CREATE FUNCTION</command> qui a
    créé ou mis à jour une fonction écrite dans ce langage. L'OID passé en
    argument est l'OID de la fonction, disponible dans le catalogue
    <classname>pg_proc</classname>. La fonction de validation doit récupérer
    cette ligne de la façon habituelle et réaliser les vérifications
    appropriées. Les vérifications typiques incluent la vérification du
    support des types en arguments et en sortie, ainsi que la vérification
    syntaxique du corps de la requête pour ce langage. Si la fonction de
    validation est satisfait par la fonction, elle quitte sans erreur. Si, par
    contre, elle trouve une erreur, elle doit rapporter cette erreur au travers
    du mécanisme <function>ereport()</function> standard. Renvoyer une erreur
    forcera une annulation de la transaction et empêchera du même coup
    l'enregistrement de la fonction dont la définition est erronée.
   </para>

   <para>
    Les fonctions de validation devraient typiquement accepter le paramètre
    <xref linkend="guc-check-function-bodies"/>&nbsp;: s'il est désactivé,
    alors tout vérification coûteuse ou spécifique au contexte devrait être
    abandonnée. En particulier, ce paramètre est désactivé par
    <application>pg_dump</application>, pour qu'il puisse charger le langage
    de procédures sans avoir à s'inquiéter des dépendances possibles dans le
    corps des procédures stockées avec d'autres objets de la base de données.
    (À cause de cela, le gestionnaire d'appels doit éviter de supposer que la
    fonction de validation a vérifié complètement la fonction. Le but d'avoir
    une fonction de validation n'est pas d'éviter au gestionnaire d'appels de
    faire des vérifications, mais plutôt de notifier immédiatement à
    l'utilisateur si des erreurs évidentes apparaissent dans la commande
    <command>CREATE FUNCTION</command>.)
   </para>

   <para>
    Si une fonction de traitement en ligne est fournie au langage de
    procédures, elle doit être déclarée comme une fonction acceptant un seul
    paramètre de type <type>internal</type>. Le résultat de la fonction de
    traitement en ligne est ignoré, donc elle peut renvoyer le type
    <type>void</type>. Elle sera appelée quand une instruction
    <command>DO</command> est exécutée pour ce langage. Le paramètre qui lui
    est fourni est un pointeur vers une structure
    <structname>InlineCodeBlock</structname>, structure contenant des
    informations sur les paramètres de l'instruction <command>DO</command>, en
    particulier le texte du bloc de code anonyme à exécuter. La fonction doit
    exécuter ce code.
   </para>

   <para>
    Les langages procéduraux inclus dans la distribution standard sont de
    bons points de départ à l'écriture de son propre gestionnaire
    de langage. Les sources se trouvent dans le répertoire <filename>src/pl</filename>.
    La page de référence de <xref linkend="sql-createlanguage"/> contient aussi
    certains détails utiles.
   </para>

 </chapter>
