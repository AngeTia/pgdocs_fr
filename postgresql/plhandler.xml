<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

 <chapter id="plhandler">
   <title>Écrire un gestionnaire de langage procédural</title>

   <indexterm zone="plhandler">
    <primary>langage procédural</primary>
    <secondary>gestionnaire</secondary>
   </indexterm>

   <para>
    Tous les appels de fonctions écrites dans un langage autre que celui
    de l'interface <quote>version 1</quote> pour les langages compilés (ce qui
    inclut les fonctions dans les langages procéduraux utilisateur, les
    fonctions SQL et les fonctions utilisant l'interface de langage compilé
    version 0), passent par une fonction spécifique au langage du
    <firstterm>gestionnaire d'appels</firstterm>.
    Le gestionnaire d'appels exécute la fonction de manière appropriée, 
    par exemple en interprétant le code source fourni. Ce chapitre 
    décrit l'écriture du gestionnaire d'appels d'un nouveau langage
    procédural.
   </para>

   <para>
    Le gestionnaire d'appel d'un langage procédural est une fonction
    <quote>normale</quote> qui doit être écrite dans un langage compilé tel que
    le C, en utilisant l'interface version-1, et enregistrée sous
    <productname>PostgreSQL</productname> comme une fonction sans argument
    et retournant le type <type>language_handler</type>. Ce pseudo-type spécial
    identifie la fonction comme gestionnaire d'appel et empêche son appel 
    à partir des commandes SQL.
   </para>

   <para>
    L'appel du gestionnaire d'appels est identique à celui de toute
    autre fonction&nbsp;: il reçoit un pointeur de <type>structure</type>
    <structname>FunctionCallInfoData</structname> qui contient les
    valeurs des arguments et d'autres informations de la fonction appelée.
    Il retourne un résultat <type>Datum</type> (et, initialise
    le champ <structfield>isnull</structfield> de la structure
    <structname>FunctionCallInfoData</structname> si un résultat SQL NULL doit
    être retourné). La différence entre un gestionnaire d'appels et une
    fonction ordinaire se situe au niveau du champ
    <structfield>flinfo-&gt;fn_oid</structfield> de la structure
    <structname>FunctionCallInfoData</structname>. Dans le cas du gestionnaire
    d'appels, il contiendra l'OID de la fonction à appeler, et non pas celui du
    gestionnaire d'appels lui-même.
    Le gestionnaire d'appels utilise ce champ pour déterminer la
    fonction à exécuter. De plus, la liste d'arguments passée a été dressée 
    à partir de la déclaration de la fonction cible, et non pas en
    fonction du gestionnaire d'appels.
   </para>

   <para>
    C'est le gestionnaire d'appels qui récupère l'entrée de la
    fonction dans la table système <classname>pg_proc</classname> et
    analyse les types des arguments et de la valeur de retour de la fonction
    appelée. La clause <literal>AS</literal> de la commande
    <command>CREATE FUNCTION</command> se situe dans la
    colonne <literal>prosrc</literal> de
    <classname>pg_proc</classname>. Il s'agit généralement du texte source du
    langage procédural lui-même (comme pour PL/Tcl) mais, en théorie, cela
    peut être un chemin vers un fichier ou tout ce qui indique
    au gestionnaire d'appels les détails des actions à effectuer.
   </para>

   <para>
    Souvent, la même fonction est appelée plusieurs fois dans la même
    instruction SQL.
    L'utilisation du champ <structfield>flinfo-&gt;fn_extra</structfield> 
    évite au gestionnaire d'appels de répéter la recherche des informations 
    concernant la fonction appelée. Ce champ, initialement
    <symbol>NULL</symbol>, peut être configuré par le gestionnaire d'appels pour
    pointer sur l'information concernant la fonction appelée. Lors des appels
    suivants, si <structfield>flinfo-&gt;fn_extra</structfield> est différent
    de <symbol>NULL</symbol>, alors il peut être utilisé et l'étape de
    recherche d'information évitée. Le gestionnaire d'appels doit
    s'assurer que <structfield>flinfo-&gt;fn_extra</structfield> pointe sur une 
    zone mémoire qui restera allouée au moins jusqu'à la fin de la requête en
    cours, car une structure de données <structname>FmgrInfo</structname> peut
    être conservée aussi longtemps. Cela peut-être obtenu par l'allocation
    des données supplémentaires dans le contexte mémoire spécifié par
    <structfield>flinfo-&gt;fn_mcxt</structfield>&nbsp;; de telles données
    ont la même espérance de vie que <structname>FmgrInfo</structname>. 
    Le gestionnaire peut également choisir d'utiliser un contexte mémoire de
    plus longue espérance de vie de façon à
    mettre en cache sur plusieurs
    requêtes les informations concernant les définitions des fonctions.
   </para>

   <para>
    Lorsqu'une fonction en langage procédural est appelée via un déclencheur,
    aucun argument ne lui est passé de façon traditionnelle mais le champ
    <structfield>context</structfield> de
    <structname>FunctionCallInfoData</structname> pointe sur une structure
    <structname>TriggerData</structname>. Il n'est pas
    <symbol>NULL</symbol> comme c'est le cas dans les appels de fonctions standard.
    Un gestionnaire de langage doit fournir les mécanismes pour que les
    fonctions de langages procéduraux obtiennent les informations du
    déclencheur.
   </para>

   <para>
    Voici un modèle de gestionnaire de langage procédural écrit en C&nbsp;:
<programlisting>#include "postgres.h"
#include "executor/spi.h"
#include "commands/trigger.h"
#include "fmgr.h"
#include "access/heapam.h"
#include "utils/syscache.h"
#include "catalog/pg_proc.h"
#include "catalog/pg_type.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

PG_FUNCTION_INFO_V1(plsample_call_handler);

Datum
plsample_call_handler(PG_FUNCTION_ARGS)
{
    Datum          retval;

    if (CALLED_AS_TRIGGER(fcinfo))
    {
        /*
         * Appelé comme procédure de déclencheur
         */
        TriggerData    *trigdata = (TriggerData *) fcinfo-&gt;context;

        retval = ...
    }
    else
    {
        /*
         * Appelé en tant que fonction
         */

        retval = ...
    }

    return retval;
}
</programlisting>
    Il suffit de remplacer les points de suspension par quelques milliers de
    lignes de codes pour compléter ce modèle.
   </para>

   <para>
    Lorsque la fonction du gestionnaire est compilée dans un module chargeable
    (voir <xref linkend="dfunc"/>), les commandes suivantes enregistrent le langage
    procédural défini dans l'exemple&nbsp;:
<programlisting>CREATE FUNCTION plsample_call_handler() RETURNS language_handler
    AS '<replaceable>nomfichier</replaceable>'
    LANGUAGE C;
CREATE LANGUAGE plsample
    HANDLER plsample_call_handler;
</programlisting>
   </para>

   <para>
    Although providing a call handler is sufficient to create a minimal
    procedural language, there are two other functions that can optionally
    be provided to make the language more convenient to use.  These
    are a <firstterm>validator</firstterm> and an
    <firstterm>inline handler</firstterm>.  A validator can be provided
    to allow language-specific checking to be done during
    <xref linkend="sql-createfunction"/>.
    An inline handler can be provided to allow the language to support
    anonymous code blocks executed via the <xref linkend="sql-do"
   /> command.
   </para>

   <para>
    If a validator is provided by a procedural language, it
    must be declared as a function taking a single parameter of type
    <type>oid</type>.  The validator's result is ignored, so it is customarily
    declared to return <type>void</type>.  The validator will be called at
    the end of a <command>CREATE FUNCTION</command> command that has created
    or updated a function written in the procedural language.
    The passed-in OID is the OID of the function's <classname>pg_proc</classname>
    row.  The validator must fetch this row in the usual way, and do
    whatever checking is appropriate.  Typical checks include verifying
    that the function's argument and result types are supported by the
    language, and that the function's body is syntactically correct
    in the language.  If the validator finds the function to be okay,
    it should just return.  If it finds an error, it should report that
    via the normal <function>ereport()</function> error reporting mechanism.
    Throwing an error will force a transaction rollback and thus prevent
    the incorrect function definition from being committed.
   </para>

   <para>
    Validator functions should typically honor the <xref
    linkend="guc-check-function-bodies"/> parameter: if it is turned off then
    any expensive or context-sensitive checking should be skipped.
    In particular, this parameter is turned off by <application>pg_dump</application>
    so that it can load procedural language functions without worrying
    about possible dependencies of the function bodies on other database
    objects.  (Because of this requirement, the call handler should avoid
    assuming that the validator has fully checked the function.  The point
    of having a validator is not to let the call handler omit checks, but
    to notify the user immediately if there are obvious errors in a
    <command>CREATE FUNCTION</command> command.)
   </para>

   <para>
    If an inline handler is provided by a procedural language, it
    must be declared as a function taking a single parameter of type
    <type>internal</type>.  The inline handler's result is ignored, so it is
    customarily declared to return <type>void</type>.  The inline handler
    will be called when a <command>DO</command> statement is executed specifying
    the procedural language.  The parameter actually passed is a pointer
    to an <structname>InlineCodeBlock</structname> struct, which contains information
    about the <command>DO</command> statement's parameters, in particular the
    text of the anonymous code block to be executed.  The inline handler
    should execute this code and return.
   </para>

   <para>
    Les langages procéduraux inclus dans la distribution standard sont de
    bons points de départ à l'écriture de son propre gestionnaire
    de langage. Les sources se trouvent dans le répertoire <filename>src/pl</filename>.
    La page de référence de <xref linkend="sql-createlanguage"/> contient aussi
    certains détails utiles.
   </para>

 </chapter>
