<!-- $PostgreSQL: pgsql/doc/src/sgml/pgupgrade.sgml,v 1.12 2010-05-25 15:55:28 momjian Exp $ -->

<sect1 id="pgupgrade">
 <title>pg_upgrade</title>

 <indexterm zone="pgupgrade">
  <primary>pg_upgrade</primary>
 </indexterm>

 <para>
  <application>pg_upgrade</application> (auparavant appelé pg_migrator) permet
  la migration des fichiers de données d'une version majeure de
  <productname>PostgreSQL</productname> vers une autre version majeure sans
  nécessiter la partie sauvegarde/restauration typiquement requise pour les
  mises à jour majeures, par exemple de la version 8.4.7 à la version majeure
  courante de <productname>PostgreSQL</productname>. Cet outil n'est pas
  utile pour les mises à jour mineures, par exemple pour une migration de la
  9.0.1 à la 9.0.4.
 </para>

 <para>
  <application>pg_upgrade</application> fonctionne bien car, bien que de
  nouvelles fonctionnalités soient ajoutées à chaque version majeure de
  <productname>PostgreSQL</productname>, le format de stockage interne des
  données change rarement. <application>pg_upgrade</application> fait de son
  mieux pour s'assurer que les clusters, ancien et nouveau, soient compatibles
  binairement, c'est-à-dire en vérificant les paramètres de temps modifiables
  à la compilation. Il est important que tout module externe soit aussi
  compatible binairement, bien que cela ne soit pas vérifié
  <application>pg_upgrade</application>.
 </para>

 <sect2>
  <title>Versions supportées</title>

  <para>
   pg_upgrade supporte la mise à jour de version 8.3.X et ultérieures vers la
   dernière version majeure de <productname>PostgreSQL</productname>, ceci
   incluant les versions intermédiaires (snapshots) et les versions alpha.
  </para>

 </sect2>

 <sect2>
  <title>Options de <application>pg_upgrade</application></title>

   <para>
    <application>pg_upgrade</application> accepte les arguments suivant en
    ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-b</option> <replaceable>ancien_dir_exec</replaceable></term>
      <term><option>--old-bindir</option> <replaceable>ANCIENDIREXEC</replaceable></term>
      <listitem><para>indique le répertoire des exécutables de l'ancienne
        instance</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-B</option> <replaceable>nouveau_dir_exec</replaceable></term>
      <term><option>--new-bindir</option> <replaceable>NOUVEAUDIREXEC</replaceable></term>
      <listitem><para>indique le répertoire des exécutables de la nouvelle
        instance</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-c</option></term>
      <term><option>--check</option></term>
      <listitem><para>vérifie seulement les instances, ne modifie pas les
        données</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option> <replaceable>ancien_repdonnées</replaceable></term>
      <term><option>--old-datadir</option> <replaceable>ANCIENREPDONNÉES</replaceable></term>
      <listitem><para>indique le répertoire des données de l'ancienne
        instance</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-D</option> <replaceable>nouveau_repdonnées</replaceable></term>
      <term><option>--new-datadir</option> <replaceable>NOUVEAUREPDONNÉES</replaceable></term>
      <listitem><para>indique le répertoire des données de la nouvelle
        instance</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-g</option></term>
      <term><option>--debug</option></term>
      <listitem><para>active les traces de débogage</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-G</option> <replaceable>fichier_debug</replaceable></term>
      <term><option>--debugfile</option> <replaceable>FICHIERDEBUG</replaceable></term>
      <listitem><para>enregistre les traces de débogage dans un
        fichier</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-k</option></term>
      <term><option>--link</option></term>
      <listitem><para>utilise des liens plutôt que de copier les fichiers vers
        la nouvelle instance</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-l</option> <replaceable>fichier_trace</replaceable></term>
      <term><option>--logfile</option> <replaceable>FICHIERTRACE</replaceable></term>
      <listitem><para>trace l'activité de la session dans un fichier</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p</option> <replaceable>ancien_port</replaceable></term>
      <term><option>--old-port</option> <replaceable>port</replaceable></term>
      <listitem><para>indique le numéro de port de l'ancienne
        instance</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-P</option> <replaceable>nouveau_port</replaceable></term>
      <term><option>--new-port</option> <replaceable>port</replaceable></term>
      <listitem><para>indique le numéro de port de la nouvelle
        instance</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-u</option> <replaceable>nom_utilisateur</replaceable></term>
      <term><option>--user</option> <replaceable>nom_utilisateur</replaceable></term>
      <listitem><para>superutilisateur de l'instance</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>--verbose</option></term>
      <listitem><para>active la sortie verbeuse</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-V</option></term>
      <term><option>--version</option></term>
      <listitem><para>affiche la version puis quitte</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-?</option></term>
      <term><option>-h</option></term>
      <term><option>--help</option></term>
      <listitem><para>affiche l'aide puis quitte</para></listitem>
     </varlistentry>

    </variablelist>
   </para>

 </sect2>

 <sect2>
  <title>Étapes de mise à jour</title>

  <orderedlist>
   <listitem>
    <para>
     Si nécessaire, déplacez l'ancienne instance
    </para>
 
    <para>
     Si vous utilisez un répertoire d'installation spécifique à la version,
     par exemple /opt/PostgreSQL/8.4, vous n'avez pas besoin de déplacer
     l'ancien répertoire de l'instance. Les installeurs one-click utilisent
     tous des répertoires d'installation spécifiques à la version.
    </para>
 
    <para>    
     Si votre répertoire d'installation n'est pas spécifique à la version,
     par exemple /usr/local/pgsql, il est nécessaire de déplacer le répertoire
     d'installation actuelle de PostgreSQL pour qu'il n'interfère pas avec la
     nouvelle installation de <productname>PostgreSQL</productname>. Une fois
     que le serveur actuel <productname>PostgreSQL</productname> est arrêté,
     il est bon de renommer le répertoire d'installation de PostgreSQL&nbsp;;
     en supposant que l'ancien répertoire est /usr/local/pgsql, vous pouvez
     saisir ceci&nbsp;:
 
<programlisting>
mv /usr/local/pgsql /usr/local/pgsql.old
</programlisting>
     pour renommer le répertoire.
    </para>
 
   </listitem>
 
   <listitem>
    <para>
     Pour une installation par les sources, construisez la nouvelle version
    </para>
 
    <para>
     Construisez la nouvelle version de PostgreSQL avec des options de
     compilation compatibles avec l'ancienne instance.
     <application>pg_upgrade</application> utilisera
     <command>pg_controldata</command> pour vérifier que tous les paramètres
     sont compatibles avant de lancer la mise à jour.
    </para>
   </listitem>
 
   <listitem>
    <para>
     Installez les nouveaux exécutables de PostgreSQL
    </para>
 
    <para>
     Installez les nouveaux exécutables du serveur ainsi que les fichiers de
     support. Vous pouvez utiliser les même numéros de port, habituellement le
     5432, car l'ancienne et la nouvelle instance ne seront pas exécutées en
     même temps.
    </para>
 
    <para>
     Pour les installations à partir des sources, si vous préférez installer
     le nouveau serveur dans un emplacement particulier, utilisez le mot clé
     'prefix'&nbsp;:
 
<programlisting>
gmake prefix=/usr/local/pgsql.new install
</programlisting>
    </para>
   </listitem>
 
   <listitem>
    <para>
     Installez <application>pg_upgrade</application> et
     <application>pg_upgrade_support</application> dans la nouvelle instance
     PostgreSQL
    </para>
   </listitem>
 
   <listitem>
    <para>
     Initialisez la nouvelle instance PostgreSQL
    </para>
 
    <para>
     Initialisez la nouvelle instance avec <xref
     linkend="app-initdb"/>,<indexterm><primary>initdb</primary></indexterm>.
     Encore une fois, utilisez des options d'initdb qui correspondent à celles
     de l'ancienne instance. Beaucoup d'installeurs font cette étape
     automatiquement. Il n'est pas nécessaire de démarrer la nouvelle
     instance.
    </para>
 
   </listitem>
 
   <listitem>
    <para>
     Installez les fichiers objets partagés personnalisés (ou DLL)
    </para>
 
    <para>
     Install any custom shared object files (or DLLs) used by the old cluster
     into the new cluster, e.g. pgcrypto.so, whether they are from /contrib
     or some other source. Do not install the schema definitions, e.g.
     pgcrypto.sql --- these will be migrated from the old cluster.
    </para>
   </listitem>
 
   <listitem>
    <para>
     Adjustez l'authentification
    </para>
 
    <para>
     pg_upgrade se connectera à l'ancien et au nouveau serveurs plusieurs fois.
     Vous devez donc configurer l'authentification à <literal>trust</literal>
     dans <filename>pg_hba.conf</filename> ou, si vous utilisez
     l'authentification <literal>md5</literal>, configurer un fichier
     <filename>~/.pgpass</filename> (voir <xref linkend="libpq-pgpass"/> pour
     les détails) pour éviter d'avoir à saisir de façon répétée le mot de
     passe.
    </para>
   </listitem>
 
   <listitem>
    <para>
     Arrêtez les deux serveurs
    </para>
 
    <para>
     Assurez-vous que les deux serveurs de bases de données sont stoppés. Pour
     cela, vous pouvez utiliser la commande suivante sous Unix&nbsp;:
 
<programlisting>
pg_ctl --pgdata /opt/PostgreSQL/8.4 stop
pg_ctl --pgdata /opt/PostgreSQL/9.0 stop
</programlisting>
 
     et la commande suivant sous Windows&nbsp;:
 
<programlisting>
NET STOP postgresql-8.4
NET STOP postgresql-9.0
</programlisting>
 
     ou encore&nbsp;:
 
<programlisting>
NET STOP pgsql-8.3  (<productname>PostgreSQL</productname> 8.3 et antérieurs
utilisent un autre nom de service)
</programlisting>
    </para>
   </listitem>
 
   <listitem>
    <para>
     Run <application>pg_upgrade</application>
    </para>
 
    <para>
     Always run the <application>pg_upgrade</application> binary in the new server, not the old one.
     <application>pg_upgrade</application> requires the specification of the old and new cluster's
     <varname>PGDATA</varname> and executable (/bin) directories. You can also specify separate
     user and port values, and whether you want the data linked instead of
     copied (the default). If you use linking, the migration will be much
     faster (no data copying), but you will no longer be able to access your
     old cluster once you start the new cluster after the upgrade. See
     pg_upgrade --help for a full list of options.
    </para>
 
    <para>
     For Windows users, you must be logged into an administrative account, and
     then start a shell as the 'postgres' user and set the proper path:
 
<programlisting>
RUNAS /USER:postgres "CMD.EXE"
SET PATH=%PATH%;C:\Program Files\PostgreSQL\9.0\bin;
</programlisting>
 
     and then run <application>pg_upgrade</application> with quoted directories, e.g.:
 
<programlisting>
pg_upgrade.exe
        --old-datadir "C:/Program Files/PostgreSQL/8.4/data"
        --new-datadir "C:/Program Files/PostgreSQL/9.0/data"
        --old-bindir "C:/Program Files/PostgreSQL/8.4/bin"
        --new-bindir "C:/Program Files/PostgreSQL/9.0/bin"
</programlisting>
 
     Once started, pg_upgrade will verify the two clusters are compatible
     and then do the migration. You can use pg_upgrade <option>--check</option>
     to perform only the checks, even if the old server is still
     running. pg_upgrade <option>--check</option> will also outline any
     manual adjustments you will need to make after the migration.
    </para>
 
    <para>
     Obviously, no one should be accessing the clusters during the migration.
    </para>
 
    <para>
     If an error occurs while restoring the database schema, pg_upgrade will
     exit and you will have to revert to the old cluster as outlined in step
     #15 below. To try pg_upgrade again, you will need to modify the old
     cluster so the pg_upgrade schema restore succeeds. If the problem is a
     /contrib module, you might need to uninstall the /contrib module from
     the old cluster and install it in the new cluster after the migration,
     assuming the module is not being used to store user data.
    </para>
   </listitem>
 
   <listitem>
    <para>
     Restore <filename>pg_hba.conf</filename>
    </para>
 
    <para>
     If you modified <filename>pg_hba.conf</filename> to use <literal>trust</literal>,
     restore its original authentication settings.
    </para>
   </listitem>
 
   <listitem>
    <para>
     Post-Migration processing
    </para>
 
    <para>
     If any post-migration processing is required, pg_upgrade will issue
     warnings as it completes. It will also generate script files that must
     be run by the administrator. The script files will connect to each
     database that needs post-migration processing. Each script should be
     run using:
 
<programlisting>
psql --username postgres --file script.sql postgres
</programlisting>
 
     The scripts can be run in any order and can be deleted once they have
     been run.
    </para>

    <caution> 
    <para>
     In general it is unsafe to access tables referenced in rebuild scripts
     until the rebuild scripts have run to completion; doing so could yield
     incorrect results or poor performance. Tables not referenced in rebuild
     scripts can be accessed immediately.
    </para>
    </caution>
   </listitem>
 
   <listitem>
    <para>
     Statistics
    </para>
    <caution> 
    <para>
     Because optimizer statistics are not transferred by pg_upgrade, you will
     be instructed to run a command to regenerate that information at the end
     of the migration.
    </para>
    </caution>
   </listitem>
 
   <listitem>
    <para>
     Delete old cluster
    </para>
 
    <para>
     Once you are satisfied with the upgrade, you can delete the old
     cluster's data directories by running the script mentioned when
     pg_upgrade completes. You will need to manually delete the old install
     directories, e.g. /bin, /share.
    </para>
   </listitem>
 
   <listitem>
    <para>
     Reverting to old cluster
    </para>
 
    <para>
     If, after running pg_upgrade, you wish to revert to the old cluster,
     there are several options.
    </para>
 
    <para>
     If you ran pg_upgrade with <option>--check</option>, no modifications
     were made to the old cluster and you can re-use it anytime.
    </para>
 
    <para>
     If you ran pg_upgrade with <option>--link</option>, the data files
     are shared between the old and new cluster. If you started
     the new cluster, the new server has written to those shared
     files and it is unsafe to use the old cluster.
    </para>
 
    <para>
     If you ran pg_upgrade <emphasis>without</emphasis>_ <option>--link</option>
     or did not start the new server, the old cluster was not
     modified except that an <literal>.old</literal> suffix was appended
     to <filename>$PGDATA/global/pg_control</filename> and perhaps tablespace
     directories. To reuse the old cluster, remove the ".old"
     suffix from <filename>$PGDATA/global/pg_control</filename>. and, if
     migrating to 8.4 or earlier, remove the tablespace directories
     created by the migration and remove the ".old" suffix from
     the tablespace directory names; then you can restart the old
     cluster.
    </para>
 
   </listitem>
  </orderedlist>
 
  </sect2>
 
  <sect2>
  <title>Limitations in migrating <emphasis>from</emphasis> PostgreSQL 8.3</title>
 
  <para>
   Upgrading from PostgreSQL 8.3 has additional restrictions not present
   when upgrading from later PostgreSQL releases.  For example,
   pg_upgrade will not work for a migration from 8.3 if a user column
   is defined as:
   <itemizedlist>
    <listitem>
     <para>
      a <type>tsquery</type> data type
     </para>
    </listitem>
    <listitem>
     <para>
      data type <type>name</type> and is not the first column
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   You must drop any such columns and migrate them manually.
  </para>
 
  <para>
   pg_upgrade will require a table rebuild if:
   <itemizedlist>
    <listitem>
     <para>
      a user column is of data type tsvector
     </para>
    </listitem>
   </itemizedlist>
  </para>
 
  <para>
   pg_upgrade will require a reindex if:
   <itemizedlist>
    <listitem>
     <para>
      an index is of type hash or gin
     </para>
    </listitem>
    <listitem>
     <para>
      an index uses <function>bpchar_pattern_ops</function>
     </para>
    </listitem>
   </itemizedlist>
  </para>
 
  <para>
   Also, the default datetime storage format changed to integer after
   <productname>PostgreSQL</productname> 8.3. pg_upgrade will check that the datetime storage format
   used by the old and new clusters match. Make sure your new cluster is
   built with the configure flag <option>--disable-integer-datetimes</option>.
  </para>
 
  <para>
   For Windows users, note that due to different integer datetimes settings
   used by the one-click installer and the MSI installer, it is only
   possible to upgrade from version 8.3 of the one-click distribution to
   version 8.4 or later of the one-click distribution. It is not
   possible to upgrade from the MSI installer to the one-click installer.
  </para>
 
  <para>  
   All failure, rebuild, and reindex cases will be reported by <application>pg_upgrade</application>
   if they affect your installation; post-migration scripts to rebuild
   tables and indexes will be automatically generated. 
  </para>
 
  <para>
   For deployment testing, create a schema-only copy of the old cluster,
   insert dummy data, and migrate that. 
  </para>
 
  <para>  
   If you want to use link mode and you don't want your old cluster
   to be modified when the new cluster is started, make a copy of the
   old cluster and migrate that with link mode. To make a valid copy
   of the old cluster, use <application>rsync</application> to create a dirty
   copy of the old cluster while the server is running, then shut down
   the old server and run rsync again to update the copy with any
   changes to make it consistent.
  </para>
 
 </sect2>
 
</sect1>
 
