<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="pgstandby">
 <title>pg_standby</title>

 <indexterm zone="pgstandby">
  <primary>pg_standby</primary>
 </indexterm>

 <para>
  <application>pg_standby</application> facilite la création d'un serveur en
  attente (<quote>warm standby server</quote>). Il est conçu pour être
  immédiatement utilisable, mais peut aussi être facilement personnalisé si
  vous en avez le besoin.
 </para>

 <para>
  <application>pg_standby</application> s'utilise au niveau du paramètre
  <literal>restore_command</literal>. IL est utile pour transformer une
  récupération d'archives ordinaire en restauration en attente. Une autre
  configuration est nécessaire, elle est décrite dans le manuel du serveur
  (voir <xref linkend="warm-standby"/>).
 </para>

 <para>
  Les fonctionnalités de <application>pg_standby</application> incluent&nbsp;:
 </para>
 <itemizedlist>
  <listitem>
   <para>
    Écrit en C, donc très portable et facile à installer
   </para>
  </listitem>
  <listitem>
   <para>
    Code source facile à modifier, avec des sections spécialement conçues
    pour modifier selon vos besoins
   </para>
  </listitem>
  <listitem>
   <para>
    Déjà testé sur Linux et Windows
   </para>
  </listitem>
 </itemizedlist>

 <sect2>
  <title>Utilisation</title>

  <para>
   Pour configurer un serveur en attente à utiliser
   <application>pg_standby</application>, placez ceci dans le fichier de
   configuration <filename>recovery.conf</filename>&nbsp;:
  </para>
  <programlisting>
restore_command = 'pg_standby <replaceable>archiveDir</replaceable> %f %p %r'
  </programlisting>
  <para>
   où <replaceable>archiveDir</replaceable> est le répertoire à partir duquel
   les journaux de transaction seront restaurés.
  </para>
  <para>
   La syntaxe complète de la ligne de commande de
   <application>pg_standby</application> est&nbsp;:
  </para>
  <synopsis>
pg_standby <optional> <replaceable>option</replaceable> ... </optional> <replaceable>archivelocation</replaceable> <replaceable>nextwalfile</replaceable> <replaceable>xlogfilepath</replaceable> <optional> <replaceable>restartwalfile</replaceable> </optional>
  </synopsis>
  <para>
   Lorsqu'il est utilisé avec <literal>restore_command</literal>, les macros
   <literal>%f</literal> et <literal>%p</literal> doivent être spécifiées
   pour, respectivement, <replaceable>nextwalfile</replaceable> et
   <replaceable>xlogfilepath</replaceable>, ce qui fournit ainsi le fichier
   réel et le chemin requis pour la restauration.
  </para>
  <para>
   Si <replaceable>restartwalfile</replaceable> est spécifié, normalement en
   utilisant la macro <literal>%r</literal>, alors tous les journaux de
   transactions précédant logiquement ce fichier seront supprimés de
   <replaceable>archivelocation</replaceable>. Ceci minimise le nombre de
   fichiers à conserver tout en préservant la possibilité de redémarrer après
   un crash. L'utilisation de ce paramètre est appropriée si
   <replaceable>archivelocation</replaceable> est une aire pour ce serveur en
   attente particulier mais ne convient <emphasis>pas</emphasis> quand
   <replaceable>archivelocation</replaceable> est prévu pour un archivage à
   long terme des journaux de transaction.
  </para>
  <para>
   <application>pg_standby</application> suppose que
   <replaceable>archivelocation</replaceable> est un répertoire lisible par
   l'utilisateur qui exécute le serveur. Si
   <replaceable>restartwalfile</replaceable> (ou l'option <literal>-k</literal>)
   est spécifié, le répertoire <replaceable>archivelocation</replaceable>
   doit être accessible aussi en écriture.
  </para>

  <para>
   Il existe deux façons de basculer un serveur <quote>en attente</quote> quand
   le maître échoue&nbsp;:

   <variablelist>
    <varlistentry>
     <term>Bascule intelligente</term>
     <listitem>
      <para>
       Dans une bascule intelligente, le serveur est disponible après avoir
       appliqué tous les fichiers des journaux de transactions dans l'archive.
       Cela résulte en une perte nulle, même si le serveur en attente n'était
       pas complètement à jour. Du coup, s'il restait beaucoup de journaux à
       ré-exécuter, cela peut prendre un long moment avant que le serveur en
       attente devienne disponible. Pour déclencher une bascule intelligente,
       créez un fichier trigger contenant le mot <literal>smart</literal>,
       ou créez-le en le laissant vide.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Bascule rapide</term>
     <listitem>
      <para>
       Lors d'une bascule rapide, le serveur est disponible immédiatement. Tout
       journal de transaction non rejoué sera ignoré. Du coup, toutes les
       transactions contenues dans ces fichiers seront perdues. Pour déclencher
       une bascule rapide, créez un fichier trigger contenant le mot
       <literal>fast</literal>. <application>pg_standby</application> peut aussi
       être configuré pour basculer automatiquement si aucun nouveau journal de
       transactions n'apparaît dans un certain laps de temps.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  
 </sect2>

 <sect2>
  <title><application>pg_standby</application> Options</title>

   <para>
    <application>pg_standby</application> accepts the following command-line arguments:

    <variablelist>

     <varlistentry>
      <term><option>-c</option></term>
      <listitem>
       <para>
        Use <literal>cp</literal> or <literal>copy</literal> command to restore WAL files
        from archive.  This is the only supported behavior so this option is useless.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option></term>
      <listitem>
       <para>
        Print lots of debug logging output on <filename>stderr</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-k</option></term>
      <listitem>
       <para>
        Remove files from <replaceable>archivelocation</replaceable> so that
        no more than this many WAL files before the current one are kept in the
        archive.  Zero (the default) means not to remove any files from
        <replaceable>archivelocation</replaceable>.
        This parameter will be silently ignored if
        <replaceable>restartwalfile</replaceable> is specified, since that
        specification method is more accurate in determining the correct
        archive cut-off point.
        Use of this parameter is <emphasis>deprecated</emphasis> as of
        <productname>PostgreSQL</productname> 8.3; it is safer and more efficient to
        specify a <replaceable>restartwalfile</replaceable> parameter.  A too
        small setting could result in removal of files that are still needed
        for a restart of the standby server, while a too large setting wastes
        archive space.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-r</option> <replaceable>maxretries</replaceable></term>
      <listitem>
       <para>
        Set the maximum number of times to retry the copy command if
        it fails (default 3). After each failure, we wait for
        <replaceable>sleeptime</replaceable> * <replaceable>num_retries</replaceable>
        so that the wait time increases progressively.  So by default,
        we will wait 5 secs, 10 secs, then 15 secs before reporting
        the failure back to the standby server. This will be
        interpreted as end of recovery and the standby will come
        up fully as a result.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>sleeptime</replaceable></term>
      <listitem>
       <para>
        Set the number of seconds (up to 60, default 5) to sleep between
        tests to see if the WAL file to be restored is available in
        the archive yet.  The default setting is not necessarily
        recommended; consult <xref linkend="warm-standby"/> for discussion.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-t</option> <replaceable>triggerfile</replaceable></term>
      <listitem>
       <para>
        Specify a trigger file whose presence should cause failover.
        It is recommended that you use a structured filename to
        avoid confusion as to which server is being triggered
        when multiple servers exist on the same system; for example
        <filename>/tmp/pgsql.trigger.5432</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-w</option> <replaceable>maxwaittime</replaceable></term>
      <listitem>
       <para>
        Set the maximum number of seconds to wait for the next WAL file,
        after which a fast failover will be performed.
        A setting of zero (the default) means wait forever.
        The default setting is not necessarily recommended;
        consult <xref linkend="warm-standby"/> for discussion.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </sect2>

 <sect2>
  <title>Exemples</title>

  <para>
    Sur des systèmes Linux ou Unix, vous pouvez utiliser (le premier
    paramètre concerne le maître, le second concerne l'esclave)&nbsp;:
  </para>

  <programlisting>
archive_command = 'cp %p .../archive/%f'

restore_command = 'pg_standby -d -s 2 -t /tmp/pgsql.trigger.5442 .../archive %f %p %r 2>>standby.log'

recovery_end_command = 'rm -f /tmp/pgsql.trigger.5442'
  </programlisting>
  <para>
   alors que le répertoire d'archive est situé physiquement sur le serveur
   en attente, de façon à ce que <literal>archive_command</literal> y
   accède via un montage NFS, mais les fichiers sont en local pour le serveur
   en attente (ce qui permet l'utilisation de <literal>ln</literal>).
  </para>
  <itemizedlist>
   <listitem>
    <para>
     produit une sortie de débogage dans <filename>standby.log</filename>
    </para>
   </listitem>
   <listitem>
    <para>
     s'endort pour deux secondes entre les vérifications de disponibilité
     du prochain journal de transaction
    </para>
   </listitem>
   <listitem>
    <para>
     arrête l'attente seulement quand un fichier trigger nommé
     <filename>/tmp/pgsql.trigger.5442</filename> apparaît,
     et exécute la bascule suivant son contenu
    </para>
   </listitem>
   <listitem>
    <para>
     supprime le fichier trigger quand la restauration se termine
   </para>
   </listitem>
   <listitem>
    <para>
     supprime les fichiers inutiles du répertoire des archives
    </para>
   </listitem>
  </itemizedlist>

  <para>Sur Windows, vous pouvez utiliser&nbsp;:</para>

  <programlisting>
archive_command = 'copy %p ...\\archive\\%f'

restore_command = 'pg_standby -d -s 5 -t C:\pgsql.trigger.5442 ...\archive %f %p %r 2>>standby.log'

recovery_end_command = 'del C:\pgsql.trigger.5442'
  </programlisting>
  <para>
   Notez que les antislashs doivent être doublés dans
   <literal>archive_command</literal>, mais <emphasis>pas</emphasis> dans
   <literal>restore_command</literal> ou <literal>recovery_end_command</literal>.
   Cela va&nbsp;:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     utiliser la commande <literal>copy</literal> pour restaurer les journaux
     de transaction à partir de l'archive
    </para>
   </listitem>
   <listitem>
    <para>
     produire une sortie de débogage dans <filename>standby.log</filename>
    </para>
   </listitem>
   <listitem>
    <para>
     l'endormir pendant cinq secondes entre les vérifications de disponibilité
     du prochain journal de transaction
    </para>
   </listitem>
   <listitem>
    <para>
     arrêter l'attente seulement quand un fichier trigger nommé
     <filename>C:\pgsql.trigger.5442</filename> apparaît,
     et exécuter la bascule suivant son contenu
    </para>
   </listitem>
   <listitem>
    <para>
     supprimer le fichier trigger quand la restauration se termine
    </para>
   </listitem>
   <listitem>
    <para>
     supprimer les fichiers inutiles du répertoire des archives
    </para>
   </listitem>
  </itemizedlist>

  <para>
   La commande <literal>copy</literal> sur Windows configure la taille du
   fichier final avant que le fichier ne soit entièrement copié, ce qui pourrait
   gêner <application>pg_standby</application>. Du coup,
   <application>pg_standby</application> attend <literal>sleeptime</literal>
   secondes une fois qu'il a remarqué que le fichier faisait la bonne taille.
   <literal>cp</literal> de GNUWin32 configure la taille du fichier seulement
   lorsque la copie du fichier est terminée.
  </para>

  <para>
   Comme l'exemple Windows utilise <literal>copy</literal> aux deux bouts,
   soit l'un soit les deux serveurs pourront accéder au répertoire d'archive
   via le réseau.
  </para>

 </sect2>

 <sect2>
  <title>Versions serveur supportées</title>

  <para>
   <application>pg_standby</application> est conçu pour fonctionner avec
   <productname>PostgreSQL</productname> 8.2 et ultérieurs.
  </para>
  <para>
   <productname>PostgreSQL</productname> 8.3 fournit la macro
   <literal>%r</literal>, qui est conçue pour indiquer à
   <application>pg_standby</application> le dernier fichier qu'il a besoin
   de conserver. Avec <productname>PostgreSQL</productname> 8.2, l'option
   <literal>-k</literal> doit être utilisée si le nettoyage de l'archive
   est démandé. Cette option reste disponible en 8.3, mais est devenue
   obsolète.
  </para>
  
  <para>
   <productname>PostgreSQL</productname> 8.4 fournit le paramètre
   <literal>recovery_end_command</literal>. Sans lui, il est possible de laisser
   un fichier trigger, ce qui comporte un risque.
  </para>
 </sect2>

 <sect2>
  <title>Auteur</title>

  <para>
   Simon Riggs <email>simon@2ndquadrant.com</email>
  </para>
 </sect2>

</sect1>
