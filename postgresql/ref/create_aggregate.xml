<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060616 : Relecture -->

<refentry id="sql-createaggregate">
 <indexterm zone="sql-createaggregate">
  <primary>CREATE AGGREGATE</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE AGGREGATE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE AGGREGATE</refname>
  <refpurpose>Définir une nouvelle fonction d'agrégat</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>+CREATE AGGREGATE <replaceable class="parameter">name</replaceable> ( [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">arg_data_type</replaceable> [ , ... ] ) (
     SFUNC = <replaceable class="PARAMETER">sfunc</replaceable>,
     STYPE = <replaceable class="PARAMETER">state_data_type</replaceable>
    [ , SSPACE = <replaceable class="PARAMETER">state_data_size</replaceable> ]
    [ , FINALFUNC = <replaceable class="PARAMETER">ffunc</replaceable> ]
    [ , FINALFUNC_EXTRA ]
    [ , INITCOND = <replaceable class="PARAMETER">initial_condition</replaceable> ]
    [ , MSFUNC = <replaceable class="PARAMETER">msfunc</replaceable> ]
    [ , MINVFUNC = <replaceable class="PARAMETER">minvfunc</replaceable> ]
    [ , MSTYPE = <replaceable class="PARAMETER">mstate_data_type</replaceable> ]
    [ , MSSPACE = <replaceable class="PARAMETER">mstate_data_size</replaceable> ]
    [ , MFINALFUNC = <replaceable class="PARAMETER">mffunc</replaceable> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MINITCOND = <replaceable class="PARAMETER">minitial_condition</replaceable> ]
    [ , SORTOP = <replaceable class="PARAMETER">sort_operator</replaceable> ]
 )

CREATE AGGREGATE <replaceable class="parameter">name</replaceable> ( [ [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">arg_data_type</replaceable> [ , ... ] ]
                        ORDER BY [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">arg_data_type</replaceable> [ , ... ] ) (
    SFUNC = <replaceable class="PARAMETER">sfunc</replaceable>,
    STYPE = <replaceable class="PARAMETER">state_data_type</replaceable>
    [ , SSPACE = <replaceable class="PARAMETER">state_data_size</replaceable> ]
    [ , FINALFUNC = <replaceable class="PARAMETER">ffunc</replaceable> ]
    [ , FINALFUNC_EXTRA ]
    [ , INITCOND = <replaceable class="PARAMETER">initial_condition</replaceable> ]
    [ , HYPOTHETICAL ]
)

<phrase>ou l'ancienne syntaxe</phrase>

CREATE AGGREGATE <replaceable class="parameter">nom</replaceable> (
    BASETYPE = <replaceable class="parameter">type_base</replaceable>,
    SFUNC = <replaceable class="parameter">sfonc</replaceable>,
    STYPE = <replaceable class="parameter">type_donnée_état</replaceable>
    [ , SSPACE = <replaceable class="PARAMETER">state_data_size</replaceable> ]
    [ , FINALFUNC = <replaceable class="parameter">ffonc</replaceable> ]
    [ , FINALFUNC_EXTRA ]
    [ , INITCOND = <replaceable class="parameter">condition_initiale</replaceable> ]
    [ , MSFUNC = <replaceable class="PARAMETER">sfunc</replaceable> ]
    [ , MINVFUNC = <replaceable class="PARAMETER">invfunc</replaceable> ]
    [ , MSTYPE = <replaceable class="PARAMETER">state_data_type</replaceable> ]
    [ , MSSPACE = <replaceable class="PARAMETER">state_data_size</replaceable> ]
    [ , MFINALFUNC = <replaceable class="PARAMETER">ffunc</replaceable> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MINITCOND = <replaceable class="PARAMETER">initial_condition</replaceable> ]
    [ , SORTOP = <replaceable class="parameter">operateur_tri</replaceable> ]
)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>CREATE AGGREGATE</command> définit une nouvelle fonction d'agrégat.
   Quelques fonctions d'agrégat basiques et largement utilisées sont fournies
   dans la distribution standard&nbsp;; elles sont documentées dans le 
   <xref linkend="functions-aggregate"/>.
   <command>CREATE AGGREGATE</command> est utilisée pour ajouter des 
   fonctionnalités lors de la définition de nouveaux
   types ou si une fonction d'agrégat n'est pas fournie.
  </para>

  <para>
   Si un nom de schéma est donné (par exemple, <literal>CREATE AGGREGATE
   monschema.monagg ...</literal>), alors la fonction d'agrégat est créée dans le
   schéma précisé. Sinon, elle est créée dans le schéma courant.
   This behavior is identical to overloading of ordinary function names
   (see <xref linkend="sql-createfunction"/>).
  </para>

  <para>
   Une fonction d'agrégat simple est identifiée par son nom et son (ou ses) types de données en
   entrée. Deux agrégats dans le même schéma peuvent avoir le même nom s'ils
   opèrent sur des types différents en entrée. Le nom et le(s) type(s) de données en
   entrée d'un agrégat doivent aussi être distincts du nom et du type de données
   de toutes les fonctions ordinaires du même schéma.
  </para>

  <para>
   Une fonction d'agrégat est réalisée à partir d'une ou deux fonctions
   ordinaires&nbsp;:
   une fonction de transition d'état
   <replaceable class="parameter">sfonc</replaceable>,
   et une fonction de traitement final optionnelle
   <replaceable class="parameter">ffonc</replaceable>.
   Elles sont utilisées ainsi&nbsp;:
<programlisting><replaceable class="parameter">sfonc</replaceable>( état-interne, nouvelle-valeur-données ) ---> prochain-état-interne
<replaceable class="parameter">ffonc</replaceable>( état-interne ) ---> valeur-agrégat
</programlisting>
  </para>

  <para>
   <productname>PostgreSQL</productname> crée une variable temporaire de type
   <replaceable class="parameter">stype</replaceable> pour contenir l'état
   interne courant de l'agrégat. À chaque ligne en entrée,
   la valeur de l'argument de l'agrégat est calculéeet la fonction
   de transition d'état est appelé avec la valeur d'état courante et la valeur
   du nouvel argument pour calculer une nouvelle valeur d'état interne.
   Une fois que toutes les lignes sont traitées, la fonction
   finale est appelée une seule fois pour calculer la valeur de retour de l'agrégat.
   S'il n'existe pas de fonction finale, alors la valeur d'état final est
   retournée en l'état.
  </para>
  
  <para>
   Une fonction d'agrégat peut fournir une condition initiale, c'est-à-dire une
   valeur initiale pour la valeur de l'état interne. Elle est spécifiée et stockée
   en base comme une valeur de type <type>text</type> mais doit
   être une représentation externe valide d'une constante du type de donnée de
   la valeur d'état. Si elle n'est pas fournie, la valeur d'état est initialement 
   positionnée à NULL.
  </para>
  
  <para>
   Si la fonction de transition d'état est déclarée <quote>strict</quote>,
   alors elle ne peut pas être appelée avec des entrées NULL. Avec une telle
   fonction de transition, l'exécution d'agrégat se comporte comme suit. Les
   lignes avec une valeur NULL en entrée sont ignorées (la fonction n'est pas
   appelé et la valeur de l'état précédent est conservé). Si la valeur de
   l'état initial est NULL, alors, à la première ligne sans valeur NULL, la
   première valeur de l'argument remplace la valeur de l'état, et la fonction
   de transition est appelée pour chacune des lignes suivantes avec toutes les valeurs
   non NULL en entrée. Cela est pratique pour implémenter des agrégats comme
   <function>max</function>. Ce comportement n'est possible que
   quand <replaceable class="parameter">type_donnée_état</replaceable> est
   identique au premier <replaceable class="parameter">type_donnée_argument</replaceable>.
   Lorsque ces types sont différents, une condition initiale
   non NULL doit être fournie, ou une fonction de transition non stricte utilisée.
  </para>
  
  <para>
   Si la fonction de transition d'état n'est pas stricte, alors elle sera
   appelée sans condition pour chaque ligne en entrée et devra gérer les
   entrées NULL et les valeurs de transition NULL. Cela permet à l'auteur de
   l'agrégat d'avoir le contrôle complet sur la gestion des valeurs NULL par
   l'agrégat.
  </para>
  
  <para>
   Si la fonction finale est déclarée <quote>strict</quote>, alors elle ne sera
   pas appelée quand la valeur d'état finale est NULL&nbsp;; à la place, un
   résultat NULL sera retourné automatiquement. C'est le
   comportement normal de fonctions strictes. Dans tous les cas, la fonction
   finale peut retourner une valeur NULL. Par exemple, la fonction
   finale pour <function>avg</function> renvoie NULL lorsqu'elle n'a aucune
   lignes en entrée.
  </para>
  
  <para>
   Sometimes it is useful to declare the final function as taking not just
   the state value, but extra parameters corresponding to the aggregate's
   input values.  The main reason for doing this is if the final function
   is polymorphic and the state value's data type would be inadequate to
   pin down the result type.  These extra parameters are always passed as
   NULL (and so the final function must not be strict when
   the <literal>FINALFUNC_EXTRA</literal> option is used), but nonetheless they
   are valid parameters.  The final function could for example make use
   of <function>get_fn_expr_argtype</function> to identify the actual argument type
   in the current call.
  </para>

  <para>
   An aggregate can optionally support <firstterm>moving-aggregate mode</firstterm>,
   as described in <xref linkend="xaggr-moving-aggregates"/>.  This requires
   specifying the <literal>MSFUNC</literal>, <literal>MINVFUNC</literal>,
   and <literal>MSTYPE</literal> parameters, and optionally
   the <literal>MSPACE</literal>, <literal>MFINALFUNC</literal>, <literal>MFINALFUNC_EXTRA</literal>,
   and <literal>MINITCOND</literal> parameters.  Except for <literal>MINVFUNC</literal>,
   these parameters work like the corresponding simple-aggregate parameters
   without <literal>M</literal>; they define a separate implementation of the
   aggregate that includes an inverse transition function.
  </para>

  <para>
   The syntax with <literal>ORDER BY</literal> in the parameter list creates
   a special type of aggregate called an <firstterm>ordered-set
   aggregate</firstterm>; or if <literal>HYPOTHETICAL</literal> is specified, then
   a <firstterm>hypothetical-set aggregate</firstterm> is created.  These
   aggregates operate over groups of sorted values in order-dependent ways,
   so that specification of an input sort order is an essential part of a
   call.  Also, they can have <firstterm>direct</firstterm> arguments, which are
   arguments that are evaluated only once per aggregation rather than once
   per input row.  Hypothetical-set aggregates are a subclass of ordered-set
   aggregates in which some of the direct arguments are required to match,
   in number and data types, the aggregated argument columns.  This allows
   the values of those direct arguments to be added to the collection of
   aggregate-input rows as an additional <quote>hypothetical</quote> row.
  </para>

  <para>
   Les agrégats qui se comportent comme  <function>MIN</function> ou <function>MAX</function>
   peuvent parfois être optimisés en cherchant un index au lieu de parcourir
   toutes les lignes en entrée. Si un agrégat peut être optimisé, un 
   <firstterm>opérateur de tri</firstterm> est spécifié. Dans ce cas, il est nécessaire
   que l'agrégat fournisse le premier élément dans l'ordre imposé par
   l'opérateur&nbsp;; en d'autres mots&nbsp;:
<programlisting>SELECT agg(col) FROM tab;
</programlisting>
   doit être équivalent à&nbsp;:
<programlisting>SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
</programlisting>
   On suppose également que l'agrégat ignore les entrées NULL et qu'il
   fournit un résultat NULL si et seulement s'il n'y a aucune entrée NULL.
   D'ordinaire, l'opérateur <literal>&lt;</literal> d'un type de données est le bon
   opérateur de tri pour <function>MIN</function> et <literal>&gt;</literal> celui
   pour <function>MAX</function>. L'optimisation ne prend
   jamais effet sauf si l'opérateur spécifié est membre de la stratégie
   <quote>less than</quote> (NdT&nbsp;: plus petit que) ou <quote>greater
   than</quote> (NdT&nbsp;: plus grand que) d'une classe d'opérateur pour un
   index B-tree.
  </para>

  <para>
   Pour pouvoir créer une fonction d'agrégat, vous devez avoir le droit
   <literal>USAGE</literal> sur le type des arguments, le type de l'état et le
   type du code retour. Vous devez aussi voir le droit
   <literal>EXECUTE</literal> sur la fonction de transition et la fonction
   finale.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom de la fonction d'agrégat à créer (éventuellement qualifié du nom
      du schéma).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">argmode</replaceable></term>

    <listitem>
     <para>
      The mode of an argument: <literal>IN</literal> or <literal>VARIADIC</literal>.
      (Aggregate functions do not support <literal>OUT</literal> arguments.)
      If omitted, the default is <literal>IN</literal>.  Only the last argument
      can be marked <literal>VARIADIC</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">argname</replaceable></term>

    <listitem>
     <para>
      The name of an argument.  This is currently only useful for
      documentation purposes.  If omitted, the argument has no name.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">arg_data_type</replaceable></term>
    <listitem>
     <para>
      Un type de donnée en entrée sur lequel opère la fonction d'agrégat.
      Pour créer une fonction d'agrégat sans argument, placez <literal>*</literal>
      à la place de la liste des types de données en argument. (la fonction
      <function>count(*)</function> en est un bon exemple.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_base</replaceable></term>
    <listitem>
     <para>
      Dans l'ancienne syntaxe de <command>CREATE AGGREGATE</command>, le type
      de données en entrée est spécifiée par un paramètre
      <literal>type_base</literal> plutôt que d'être écrit à la suite du nom de
      l'agrégat. Notez que cette syntaxe autorise seulement un paramètre en
      entrée. Pour définir une fonction d'agrégat sans argument avec cette syntaxe, indiquez
      only one input parameter.  To define a zero-argument aggregate function,
      <literal>"ANY"</literal> (et non pas <literal>*</literal>) pour le
      <literal>type_base</literal>.
      Ordered-set aggregates cannot be defined with the old syntax.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">sfonc</replaceable></term>
    <listitem>
     <para>
      Le nom de la fonction de transition de l'état à appeler pour chaque ligne
      en entrée. Pour une fonction d'agrégat simple avec <replaceable
      class="parameter">N</replaceable> arguments, <replaceable
      class="parameter">sfonc</replaceable> doit prendre
      <replaceable class="parameter">N</replaceable>+1 arguments, le premier
      étant de type <replaceable class="parameter">type_données_état</replaceable>
      et le reste devant correspondre aux types de données en entrée déclarés
      pour l'agrégat. La fonction doit renvoyer une valeur de type
      <replaceable class="parameter">type_données_état</replaceable>. Cette
      fonction prend la valeur actuelle de l'état  et les valeurs actuelles des
      données en entrée. Elle renvoit la prochaine valeur de l'état.
     </para>

     <para>
      For ordered-set (including hypothetical-set) aggregates, the state
      transition function receives only the current state value and the
      aggregated arguments, not the direct arguments.  Otherwise it is the
      same.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_donnée_état</replaceable></term>
    <listitem>
     <para>
      Le type de donnée pour la valeur d'état de l'agrégat.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">state_data_size</replaceable></term>
    <listitem>
     <para>
      The approximate average size (in bytes) of the aggregate's state value.
      If this parameter is omitted or is zero, a default estimate is used
      based on the <replaceable>state_data_type</replaceable>.
      The planner uses this value to estimate the memory required for a
      grouped aggregate query.  The planner will consider using hash
      aggregation for such a query only if the hash table is estimated to fit
      in <xref linkend="guc-work-mem"/>; therefore, large values of this
      parameter discourage use of hash aggregation.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">ffonc</replaceable></term>
    <listitem>
     <para>
      Le nom de la fonction finale à appeler pour traiter le résultat de
      l'agrégat une fois que toutes les lignes en entrée ont été parcourues.
      Pour un agrégat normal, la fonction prend un seul argument de type <replaceable
      class="parameter">type_donnée_état</replaceable>. Le type de retour de
      l'agrégat de la fonction est défini comme le type de retour de cette
      fonction. Si <replaceable class="parameter">ffonc</replaceable> n'est pas
      spécifiée, alors la valeur d'état finale est utilisée comme résultat de
      l'agrégat et le type de retour est <replaceable
      class="parameter">type_donnée_état</replaceable>.
     </para>

     <para>
      For ordered-set (including hypothetical-set) aggregates, the
      final function receives not only the final state value,
      but also the values of all the direct arguments.
     </para>

     <para>
      If <literal>FINALFUNC_EXTRA</literal> is specified, then in addition to the
      final state value and any direct arguments, the final function
      receives extra NULL values corresponding to the aggregate's regular
      (aggregated) arguments.  This is mainly useful to allow correct
      resolution of the aggregate result type when a polymorphic aggregate
      is being defined.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition_initiale</replaceable></term>
    <listitem>
     <para>
      La configuration initiale pour la valeur de l'état. Elle doit être une
      constante de type chaîne de caractères dans la forme acceptée par le type
      de données <replaceable class="parameter">type_donnée_état</replaceable>.
      Si non spécifié, la valeur d'état est initialement positionnée à NULL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">msfunc</replaceable></term>
    <listitem>
     <para>
      The name of the forward state transition function to be called for each
      input row in moving-aggregate mode.  This is exactly like the regular
      transition function, except that its first argument and result are of
      type <replaceable>mstate_data_type</replaceable>, which might be different
      from <replaceable>state_data_type</replaceable>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">minvfunc</replaceable></term>
    <listitem>
     <para>
      The name of the inverse state transition function to be used in
      moving-aggregate mode.  This function has the same argument and
      result types as <replaceable>msfunc</replaceable>, but it is used to remove
      a value from the current aggregate state, rather than add a value to
      it.  The inverse transition function must have the same strictness
      attribute as the forward state transition function.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">mstate_data_type</replaceable></term>
    <listitem>
     <para>
      The data type for the aggregate's state value, when using
      moving-aggregate mode.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">mstate_data_size</replaceable></term>
    <listitem>
     <para>
      The approximate average size (in bytes) of the aggregate's state
      value, when using moving-aggregate mode.  This works the same as
      <replaceable>state_data_size</replaceable>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">mffunc</replaceable></term>
    <listitem>
     <para>
      The name of the final function called to compute the aggregate's
      result after all input rows have been traversed, when using
      moving-aggregate mode.  This works the same as <replaceable>ffunc</replaceable>,
      except that its first argument's type
      is <replaceable>mstate_data_type</replaceable> and extra dummy arguments are
      specified by writing <literal>MFINALFUNC_EXTRA</literal>.
      The aggregate result type determined by <replaceable>mffunc</replaceable>
      or <replaceable>mstate_data_type</replaceable> must match that determined by the
      aggregate's regular implementation.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">minitial_condition</replaceable></term>
    <listitem>
     <para>
      The initial setting for the state value, when using moving-aggregate
      mode.  This works the same as <replaceable>initial_condition</replaceable>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">sort_operator</replaceable></term>
    <listitem>
     <para>
      L'opérateur de tri associé pour un agrégat de type <function>MIN</function> ou
      <function>MAX</function>. C'est seulement le nom de l'opérateur (éventuellement qualifié
      du nom du schéma). L'opérateur est supposé avoir les mêmes
      types de données en entrée que l'agrégat (qui doit être un agrégat normal à un seul
      argument).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>HYPOTHETICAL</literal></term>
    <listitem>
     <para>
      For ordered-set aggregates only, this flag specifies that the aggregate
      arguments are to be processed according to the requirements for
      hypothetical-set aggregates: that is, the last few direct arguments must
      match the data types of the aggregated (<literal>WITHIN GROUP</literal>)
      arguments.  The <literal>HYPOTHETICAL</literal> flag has no effect on
      run-time behavior, only on parse-time resolution of the data types and
      collations of the aggregate's arguments.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les paramètres de <command>CREATE AGGREGATE</command> peuvent être écrits
   dans n'importe quel ordre, pas uniquement dans l'ordre illustré ci-dessus.
  </para>
 </refsect1>
  
 <refsect1>
  <title>Notes</title>

   <para>
    In parameters that specify support function names, you can write
    a schema name if needed, for example <literal>SFUNC = public.sum</literal>.
    Do not write argument types there, however &mdash; the argument types
    of the support functions are determined from other parameters.
   </para>

   <para>
    If an aggregate supports moving-aggregate mode, it will improve
    calculation efficiency when the aggregate is used as a window function
    for a window with moving frame start (that is, a frame start mode other
    than <literal>UNBOUNDED PRECEDING</literal>).  Conceptually, the forward
    transition function adds input values to the aggregate's state when
    they enter the window frame from the bottom, and the inverse transition
    function removes them again when they leave the frame at the top.  So,
    when values are removed, they are always removed in the same order they
    were added.  Whenever the inverse transition function is invoked, it will
    thus receive the earliest added but not yet removed argument value(s).
    The inverse transition function can assume that at least one row will
    remain in the current state after it removes the oldest row.  (When this
    would not be the case, the window function mechanism simply starts a
    fresh aggregation, rather than using the inverse transition function.)
   </para>

   <para>
    The forward transition function for moving-aggregate mode is not
    allowed to return NULL as the new state value. If the inverse
    transition function returns NULL, this is taken as an indication that
    the inverse function cannot reverse the state calculation for this
    particular input, and so the aggregate calculation will be redone from
    scratch for the current frame starting position.  This convention
    allows moving-aggregate mode to be used in situations where there are
    some infrequent cases that are impractical to reverse out of the
    running state value.
   </para>

   <para>
    If no moving-aggregate implementation is supplied,
    the aggregate can still be used with moving frames,
    but <productname>PostgreSQL</productname> will recompute the whole
    aggregation whenever the start of the frame moves.
    Note that whether or not the aggregate supports moving-aggregate
    mode, <productname>PostgreSQL</productname> can handle a moving frame
    end without recalculation; this is done by continuing to add new values
    to the aggregate's state.  It is assumed that the final function does
    not damage the aggregate's state value, so that the aggregation can be
    continued even after an aggregate result value has been obtained for
    one set of frame boundaries.
   </para>

   <para>
    The syntax for ordered-set aggregates allows <literal>VARIADIC</literal>
    to be specified for both the last direct parameter and the last
    aggregated (<literal>WITHIN GROUP</literal>) parameter.  However, the
    current implementation restricts use of <literal>VARIADIC</literal>
    in two ways.  First, ordered-set aggregates can only use
    <literal>VARIADIC "any"</literal>, not other variadic array types.
    Second, if the last direct parameter is <literal>VARIADIC "any"</literal>,
    then there can be only one aggregated parameter and it must also
    be <literal>VARIADIC "any"</literal>.  (In the representation used in the
    system catalogs, these two parameters are merged into a single
    <literal>VARIADIC "any"</literal> item, since <structname>pg_proc</structname> cannot
    represent functions with more than one <literal>VARIADIC</literal> parameter.)
    If the aggregate is a hypothetical-set aggregate, the direct arguments
    that match the <literal>VARIADIC "any"</literal> parameter are the hypothetical
    ones; any preceding parameters represent additional direct arguments
    that are not constrained to match the aggregated arguments.
   </para>

   <para>
    Currently, ordered-set aggregates do not need to support
    moving-aggregate mode, since they cannot be used as window functions.
   </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Voir <xref linkend="xaggr"/>.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   <command>CREATE AGGREGATE</command> est une extension
   <productname>PostgreSQL</productname>. Le standard SQL ne fournit pas de
   fonctions d'agrégat utilisateur.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alteraggregate"/></member>
   <member><xref linkend="sql-dropaggregate"/></member>
  </simplelist>
 </refsect1>
</refentry>
