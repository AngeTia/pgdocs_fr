<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060618 -->

<refentry id="sql-createview">
 <indexterm zone="sql-createview">
  <primary>CREATE VIEW</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE VIEW</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE VIEW</refname>
  <refpurpose>Définir une vue</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW <replaceable class="parameter">nom</replaceable> [ ( <replaceable class="parameter">nom_colonne</replaceable> [, ...] ) ]
    [ WITH ( <replaceable class="PARAMETER">nom de l'option de vue</replaceable> [= <replaceable class="PARAMETER">valeur de l'option de vue</replaceable>] [, ... ] ) ]
    AS <replaceable class="parameter">requête</replaceable>
    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]

<phrase>where <replaceable class="parameter">view_option_name</replaceable> can be one of:</phrase>

    security_barrier [ <replaceable class="parameter">boolean</replaceable> ]
    check_option [ <replaceable class="parameter">text</replaceable> (<literal>local</literal> or <literal>cascaded</literal>) ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>CREATE VIEW</command> définit une vue d'après une requête. La
   vue n'est pas matérialisée physiquement. Au lieu de cela, la requête
   est lancée chaque fois qu'une vue est utilisée dans une requête.
  </para>

  <para>
   <command>CREATE OR REPLACE VIEW</command> a la même finalité, mais
   si une vue du même nom existe déjà, elle est remplacée. La nouvelle requête
   doit générer les mêmes colonnes que celles de l'ancienne requête (c-est-à-dire
   les mêmes noms de colonnes dans le même ordre avec les mêmes types de données).
   Par contre, elle peut ajouter des colonnes supplémentaires en fin de liste.
   Les traitements qui donnent les colonnes en sortie pourraient être complètement
   différents.
  </para>

  <para>
   Si un nom de schéma est donné (par exemple
   <literal>CREATE VIEW monschema.mavue ...</literal>),
   alors la vue est créée dans ce schéma.
   Dans le cas contraire, elle est créée dans le schéma courant. Les vues
   temporaires existent dans un schéma spécial. Il n'est donc pas nécessaire
   de fournir de schéma pour les vues temporaires. Le
   nom de la vue doit être différent du nom de toute autre vue, table, séquence,
   index ou table distante du même schéma.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><literal>TEMPORARY</literal> ou <literal>TEMP</literal></term>
    <listitem>
     <para>
      La vue est temporaire. Les vues temporaires sont automatiquement supprimées
	  en fin de session. Les relations permanentes qui portent le même nom ne sont plus
      visibles pour la session tant que la vue temporaire existe, sauf
      s'il y est fait référence avec le nom du schéma.
     </para>

     <para>
      Si l'une des tables référencées par la vue est temporaire, la vue est alors elle-aussi
      temporaire (que <literal>TEMPORARY</literal> soit spécifié ou non).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RECURSIVE</literal></term>
    <listitem>
     <para>
      Crée une vue récursive. La syntaxe
<synopsis>
CREATE RECURSIVE VIEW <replaceable>nom</replaceable> (<replaceable>colonnes</replaceable>) AS SELECT <replaceable>...</replaceable>;
</synopsis>
      est équivalente à
<synopsis>
CREATE VIEW <replaceable>nom</replaceable> AS WITH RECURSIVE <replaceable>nom</replaceable> (<replaceable>colonnes</replaceable>) AS (SELECT <replaceable>...</replaceable>) SELECT <replaceable>colonnes</replaceable> FROM <replaceable>name</replaceable>;
</synopsis>
      Une liste de colonne doit être spécifiée pour la vue récursive.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
       Le nom de la vue à créer (éventuellement qualifié du nom du schéma).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom de colonne</replaceable></term>
    <listitem>
     <para>
      Une liste optionnelle de noms à utiliser pour les colonnes de la vue.
      Si elle n'est pas donnée, le nom des colonnes est déduit de la requête.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH ( <replaceable class="PARAMETER">nom de l'option de vue</replaceable> [= <replaceable class="PARAMETER">valeur de l'option</replaceable>] [, ... ] )</literal></term>
    <listitem>
     <para>
      Cette clause spécifie des paramètres optionnels pour une vue.the following
      parameters are supported:

      <variablelist>
       <varlistentry>
        <term><literal>security_barrier(boolean)</literal></term>
        <listitem>
         <para>
          This should be used if the view is intended to provide row-level
          security.  See <xref linkend="rules-privileges"/> for full details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>check_option(text)</literal></term>
        <listitem>
         <para>
          This parameter may be either <literal>local</literal> or
          <literal>cascaded</literal>, and is equivalent to specifying
          <literal>WITH [ CASCADED | LOCAL ] CHECK OPTION</literal> (see below).
          This option can be changed on existing views using <xref
          linkend="sql-alterview"/>.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">requête</replaceable></term>
    <listitem>
     <para>
      Une commande <xref linkend="sql-select"/> ou
      <xref linkend="sql-values"/> qui fournira
      les colonnes et lignes de la vue.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH [ CASCADED | LOCAL ] CHECK OPTION</literal></term>
    <listitem>
     <para>
      <indexterm zone="SQL-CREATEVIEW">
       <primary>CHECK OPTION</primary>
      </indexterm>
      <indexterm zone="SQL-CREATEVIEW">
       <primary>WITH CHECK OPTION</primary>
      </indexterm>
      This option controls the behavior of automatically updatable views.  When
      this option is specified, <command>INSERT</command> and <command>UPDATE</command>
      commands on the view will be checked to ensure that new rows satisfy the
      view-defining condition (that is, the new rows are checked to ensure that
      they are visible through the view).  If they are not, the update will be
      rejected.  If the <literal>CHECK OPTION</literal> is not specified,
      <command>INSERT</command> and <command>UPDATE</command> commands on the view are
      allowed to create rows that are not visible through the view.  The
      following check options are supported:

      <variablelist>
       <varlistentry>
        <term><literal>LOCAL</literal></term>
        <listitem>
         <para>
          New rows are only checked against the conditions defined directly in
          the view itself.  Any conditions defined on underlying base views are
          not checked (unless they also specify the <literal>CHECK OPTION</literal>).
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>CASCADED</literal></term>
        <listitem>
         <para>
          New rows are checked against the conditions of the view and all
          underlying base views.  If the <literal>CHECK OPTION</literal> is specified,
          and neither <literal>LOCAL</literal> nor <literal>CASCADED</literal> is specified,
          then <literal>CASCADED</literal> is assumed.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>

     <para>
      The <literal>CHECK OPTION</literal> may not be used with <literal>RECURSIVE</literal>
      views.
     </para>

     <para>
      Note that the <literal>CHECK OPTION</literal> is only supported on views that
      are automatically updatable, and do not have <literal>INSTEAD OF</literal>
      triggers or <literal>INSTEAD</literal> rules.  If an automatically updatable
      view is defined on top of a base view that has <literal>INSTEAD OF</literal>
      triggers, then the <literal>LOCAL CHECK OPTION</literal> may be used to check
      the conditions on the automatically updatable view, but the conditions
      on the base view with <literal>INSTEAD OF</literal> triggers will not be
      checked (a cascaded check option will not cascade down to a
      trigger-updatable view, and any check options defined directly on a
      trigger-updatable view will be ignored).  If the view or any of its base
      relations has an <literal>INSTEAD</literal> rule that causes the
      <command>INSERT</command> or <command>UPDATE</command> command to be rewritten, then
      all check options will be ignored in the rewritten query, including any
      checks from automatically updatable views defined on top of the relation
      with the <literal>INSTEAD</literal> rule.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

   <para>
    L'instruction <xref linkend="sql-dropview"/> est utilisée pour supprimer
    les vues.
   </para>

   <para>
	Il est important de s'assurer que le nom et le type des colonnes de la vue
	correspondent à ce qui est souhaité. Ainsi&nbsp;:
<programlisting>CREATE VIEW vista AS SELECT 'Hello World';
</programlisting>
    présente deux défauts majeurs&nbsp;: le nom de la colonne prend la valeur implicite
	<literal>?column?</literal> et son type de données le type implicite <type>unknown</type>.
	Pour obtenir une chaîne de caractères dans le résultat de la vue, on peut écrire&nbsp;:
<programlisting>CREATE VIEW vista AS SELECT text 'Hello World' AS hello;
</programlisting>
   </para>

   <para>
    L'accès aux tables référencées dans la vue est déterminé par les droits
    du propriétaire de la vue. Dans certains cas, cela peut être utilisé pour
    fournir un accès sécurisé. Cependant, toutes les vues ne sont pas
    sécurisables&nbsp;; voir <xref linkend="rules-privileges"/> pour des
    détails.  Les fonctions appelées dans la vue sont traitées de la même façon
    que si elles avaient été appelées directement dans la requête utilisant la
    vue. Du coup, l'utilisateur d'une vue doit avoir les droits pour appeler
    toutes les fonctions utilisées par la vue.
   </para>

   <para>
    Quand <command>CREATE OR REPLACE VIEW</command> est utilisé sur une vue
    existante, seule la règle SELECT définissant la vue est modifiée. Les
    autres propriétés, comme les droits, le propriétaire et les règles autres
    que le SELECT, ne sont pas modifiées. Vous devez être le propriétaire de
    la vue pour la remplacer (ceci incluant aussi les membres du rôle
    propriétaire).
   </para>

  <refsect2 id="sql-createview-updatable-views">
   <title id="sql-createview-updatable-views-title">Vues modifiables</title>

   <indexterm zone="sql-createview-updatable-views">
    <primary>vues modifiables</primary>
   </indexterm>

   <para>
    Les vues simples sont automatiquement modifiables&nbsp;: le système autorise
    l'utilisation des commandes <command>INSERT</command>,
    <command>UPDATE</command> et <command>DELETE</command> sur les vues comme
    sur les tables. Une vue est modifiable automatiquement si elle satisfait les
    conditions suivantes&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       La vue doit avoir exactement une entrée (une table ou une autre vue
       modifiable) dans la liste <literal>FROM</literal>.
      </para>
     </listitem>

     <listitem>
      <para>
       La défintion de la vue ne doit pas contenir de clauses
       <literal>WITH</literal>, <literal>DISTINCT</literal>, <literal>GROUP
       BY</literal>, <literal>HAVING</literal>, <literal>LIMIT</literal> ou
       <literal>OFFSET</literal> au niveau le plus haut.
      </para>
     </listitem>

     <listitem>
      <para>
       La définition de la vue ne doit pas contenir d'opérations sur des
       ensembles (<literal>UNION</literal>, <literal>INTERSECT</literal> ou
       <literal>EXCEPT</literal>) au niveau le plus haut.
      </para>
     </listitem>

     <listitem>
      <para>
       The view's select list must not contain any aggregates, window functions
       or set-returning functions.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    An automatically updatable view may contain a mix of updatable and
    non-updatable columns.  A column is updatable if it is a simple reference
    to an updatable column of the underlying base relation; otherwise the
    column is read-only, and an error will be raised if an <command>INSERT</command>
    or <command>UPDATE</command> statement attempts to assign a value to it.
   </para>

   <para>
    Si la vue est modifiable automatiquement, le système convertira automatiquement
    toute commande <command>INSERT</command>, <command>UPDATE</command> ou
    <command>DELETE</command> sur la vue dans la commande correspondante sur la
    relation sous-jacente.
   </para>

   <para>
    Si une vue modifiable automatiquement contient une condition
    <literal>WHERE</literal>, la condition restreint les lignes modifiables
    dans la relation de base par une commande <command>UPDATE</command> ou
    <command>DELETE</command>. Néanmoins, un <command>UPDATE</command> peut
    modifier une ligne qui ne satisfait plus la condition
    <literal>WHERE</literal>, et du coup qui n'est plus visible par la vue.
    De la même façon, une commande <command>INSERT</command> peut insérer des
    lignes dans la relation de base qui ne satisfont par la condition
    <literal>WHERE</literal> et qui, du coup, ne sont pas visibles via la vue.
    The <literal>CHECK OPTION</literal> may be used to
    prevent <command>INSERT</command> and <command>UPDATE</command> commands from creating
    such rows that are not visible through the view.
   </para>

   <para>
    If an automatically updatable view is marked with the
    <literal>security_barrier</literal> property then all the view's <literal>WHERE</literal>
    conditions (and any conditions using operators which are marked as <literal>LEAKPROOF</literal>)
    will always be evaluated before any conditions that a user of the view has
    added.   See <xref linkend="rules-privileges"/> for full details.  Note that,
    due to this, rows which are not ultimately returned (because they do not
    pass the user's <literal>WHERE</literal> conditions) may still end up being locked.
    <command>EXPLAIN</command> can be used to see which conditions are
    applied at the relation level (and therefore do not lock rows) and which are
    not.
   </para>

   <para>
    Une vue plus complexe qui ne satisfait par toutes les conditions ci-dessus
    est par défaut en lecture seule&nbsp;: le système ne permettra ni insertion,
    ni mise à jour, ni suppression sur la vue. Vous pouvez obtenir le même effet
    qu'une vue modifiable en créant des triggers <literal>INSTEAD OF</literal>
    sur la vue. Ces triggers doivent convertir l'insertion, ... tentée sur la
    vue par l'action appropriée sur les autres tables. Pour plus d'informations,
    voir <xref linkend="sql-createtrigger"/>. Une autre possibilité revient à
    créer des règles (voir <xref linkend="sql-createrule"/>). Cependant, en
    pratique, les triggers sont plus simples à comprendre et à utiliser
    correctement.
   </para>

   <para>
    Notez que l'utilisateur réalisant l'insertion, la mise à jour ou la
    suppression sur la vue doit avoir les droits correspondants sur la vue. De
    plus, le propriétaire de la vue doit avoir les droits correspondants sur
    les relations sous-jacentes mais l'utilisateur réalisant la mise à jour
    n'a pas besoin de droits sur les relations sous-jacentes (voir
    <xref linkend="rules-privileges"/>).
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Créer une vue composée des comédies&nbsp;:

<programlisting>CREATE VIEW comedies AS
    SELECT *
    FROM films
    WHERE genre = 'Comédie';
</programlisting>
   Cette requête crée une vue contenant les colonnes de la table
   <literal>film</literal> au moment de la création de la vue. Bien que l'étoile
   (<literal>*</literal>) soit utilisée pour créer la vue, les colonnes
   ajoutées par la suite à la table <literal>film</literal> ne feront pas
   partie de la vue.
  </para>

  <para>
   Create a view with <literal>LOCAL CHECK OPTION</literal>:

<programlisting>
CREATE VIEW universal_comedies AS
    SELECT *
    FROM comedies
    WHERE classification = 'U'
    WITH LOCAL CHECK OPTION;
</programlisting>
   This will create a view based on the <literal>comedies</literal> view, showing
   only films with <literal>kind = 'Comedy'</literal> and
   <literal>classification = 'U'</literal>. Any attempt to <command>INSERT</command> or
   <command>UPDATE</command> a row in the view will be rejected if the new row
   doesn't have <literal>classification = 'U'</literal>, but the film
   <literal>kind</literal> will not be checked.
  </para>

  <para>
   Create a view with <literal>CASCADED CHECK OPTION</literal>:

<programlisting>
CREATE VIEW pg_comedies AS
    SELECT *
    FROM comedies
    WHERE classification = 'PG'
    WITH CASCADED CHECK OPTION;
</programlisting>
   This will create a view that checks both the <literal>kind</literal> and
   <literal>classification</literal> of new rows.
  </para>

  <para>
   Create a view with a mix of updatable and non-updatable columns:

<programlisting>
CREATE VIEW comedies AS
    SELECT f.*,
           country_code_to_name(f.country_code) AS country,
           (SELECT avg(r.rating)
            FROM user_ratings r
            WHERE r.film_id = f.id) AS avg_rating
    FROM films f
    WHERE f.kind = 'Comedy';
</programlisting>
   This view will support <command>INSERT</command>, <command>UPDATE</command> and
   <command>DELETE</command>.  All the columns from the <literal>films</literal> table will
   be updatable, whereas the computed columns <literal>country</literal> and
   <literal>avg_rating</literal> will be read-only.
  </para>

  <para>
   Créer une vue récursive consistant en des nombres 1 à 100&nbsp;:
<programlisting>
CREATE RECURSIVE VIEW nums_1_100 (n) AS
    VALUES (1)
UNION ALL
    SELECT n+1 FROM nums_1_100 WHERE n &lt; 100;
</programlisting>
  </para>
 </refsect1>
 
 <refsect1>
  <title>Compatibilité</title>

  <para>
   Le standard SQL spécifie quelques possibilités supplémentaires pour
   l'instruction <command>CREATE VIEW</command>&nbsp;:
<synopsis>CREATE VIEW <replaceable class="parameter">nom</replaceable> [ ( <replaceable class="parameter">nom_colonne</replaceable> [, ...] ) ]
    AS <replaceable class="parameter">requête</replaceable>
    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
</synopsis>
  </para>

  <para>
   <command>CREATE OR REPLACE VIEW</command> est une extension
   <productname>PostgreSQL</productname>, tout comme le concept de vue temporaire.
   La clause <literal>WITH ( ... )</literal> est aussi une extension.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterview"/></member>
   <member><xref linkend="sql-dropview"/></member>
   <member><xref linkend="sql-creatematerializedview"/></member>
  </simplelist>
 </refsect1>
</refentry>
