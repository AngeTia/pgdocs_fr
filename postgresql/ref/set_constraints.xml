<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<refentry id="sql-set-constraints">
 <refmeta>
  <refentrytitle id="sql-set-constraints-title">SET CONSTRAINTS</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>SET CONSTRAINTS</refname>
  <refpurpose>initialise le moment de vérification de contrainte de la transaction en
   cours</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>SET CONSTRAINTS { ALL | <replaceable class="parameter">nom</replaceable> [, ...] } { DEFERRED | IMMEDIATE }
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-set-constraints">
   <primary>SET CONSTRAINTS</primary>
  </indexterm>


  <para>
   <command>SET CONSTRAINTS</command> initialise le comportement de la
   vérification des contraintes dans la transaction en cours.
   Les contraintes <literal>IMMEDIATE</literal> sont vérifiées à la fin de
   chaque instruction. Les contraintes <literal>DEFERRED</literal> ne sont
   vérifiées qu'à la validation de la transaction. Chaque contrainte a son
   propre mode <literal>IMMEDIATE</literal> ou <literal>DEFERRED</literal>.
  </para>

  <para>
   À la création, une contrainte se voit donnée une des trois
   caractéristiques&nbsp;: <literal>DEFERRABLE INITIALLY DEFERRED</literal>,
   <literal>DEFERRABLE INITIALLY IMMEDIATE</literal> ou
   <literal>NOT DEFERRABLE</literal>. La troisième forme est toujours
   <literal>IMMEDIATE</literal> et n'est pas affectée par la commande
   <command>SET CONSTRAINTS</command>. Les deux premières classes commencent
   chaque transaction dans le mode indiqué mais leur comportement peut changer à
   l'intérieur d'une transaction par <command>SET CONSTRAINTS</command>.
  </para>

  <para>
   <command>SET CONSTRAINTS</command> avec une liste de noms de contraintes
   modifie le mode de ces contraintes (qui doivent toutes être différables).
   Each constraint name can be schema-qualified.
   Le chemin de recherche des schémas est utilisé pour trouver le premier
   nom correspondant si aucun nom de schéma n'a été indiqué.
   <command>SET CONSTRAINTS ALL</command> modifie le mode de toutes les
   contraintes déférables.
  </para>

  <para>
   Lorsque <command>SET CONSTRAINTS</command> modifie le mode d'une contrainte
   de <literal>DEFERRED</literal> à <literal>IMMEDIATE</literal>, le nouveau
   mode prend effet rétroactivement&nbsp;: toute modification de données qui
   aurait été vérifiée à la fin de la transaction est en fait vérifiée lors de
   l'exécution de la commande <command>SET CONSTRAINTS</command>. Si une
   contrainte est violée, la commande <command>SET CONSTRAINTS</command> échoue
   (et ne change pas le mode de contrainte). Du coup, <command>SET
   CONSTRAINTS</command> peut être utilisée pour forcer la vérification de
   contraintes à un point spécifique d'une transaction.
  </para>

  <para>
   Currently, only <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>,
   <literal>REFERENCES</literal> (foreign key), and <literal>EXCLUDE</literal>
   constraints are affected by this setting.
   <literal>NOT NULL</literal> and <literal>CHECK</literal> constraints are
   always checked immediately when a row is inserted or modified
   (<emphasis>not</emphasis> at the end of the statement).
   Uniqueness and exclusion constraints that have not been declared
   <literal>DEFERRABLE</literal> are also checked immediately.
  </para>

  <para>
   The firing of triggers that are declared as <quote>constraint triggers</quote>
   is also controlled by this setting &mdash; they fire at the same time
   that the associated constraint should be checked.
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Because <productname>PostgreSQL</productname> does not require constraint
   names to be unique within a schema (but only per-table), it is possible
   that there is more than one match for a specified constraint name.
   In this case <command>SET CONSTRAINTS</command> will act on all matches.
   For a non-schema-qualified name, once a match or matches have been found in
   some schema in the search path, schemas appearing later in the path are not
   searched.
  </para>

  <para>
   Cette commande altère seulement le comportement des contraintes à l'intérieur
   de la transaction en cours. Du coup, si vous exécutez cette commande en
   dehors d'un bloc de transaction (pair
   <command>BEGIN</command>/<command>COMMIT</command>), elle ne semble pas avoir
   d'effet.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Cette commande est compatible avec le comportement défini par le 
   standard SQL à part le fait que dans
   <productname>PostgreSQL</productname>, it does not apply to
   <literal>NOT NULL</literal> and <literal>CHECK</literal> constraints.
   Also, <productname>PostgreSQL</productname> checks non-deferrable
   uniqueness constraints immediately, not at end of statement as the
   standard would suggest.
  </para>
 </refsect1>
</refentry>
