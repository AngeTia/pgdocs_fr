<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060707 : Relecture initiale -->

<refentry id="sql-notify">
 <refmeta>
  <refentrytitle>NOTIFY</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>NOTIFY</refname>
  <refpurpose>engendrer une notification</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>NOTIFY <replaceable class="parameter">canal</replaceable> [ , <replaceable class="parameter">charge</replaceable> ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-notify">
   <primary>NOTIFY</primary>
  </indexterm>

  <para>
   La commande <command>NOTIFY</command> envoie une notification together
   with an optional <quote>payload</quote> string
   à chaque application cliente qui a exécuté précédemment la commande
   <command>LISTEN <replaceable class="parameter">canal</replaceable></command>
   dans la base de données courante pour le nom du canal indiqué.
  </para>

  <para>
   <command>NOTIFY</command> fournit un mécanisme simple
   de communication interprocessus pour tout ensemble de processus accédant à
   la même base de données <productname>PostgreSQL</productname>.
   A payload string can be sent along with the notification, and Des mécanismes
   de plus haut niveau for passing structured data peuvent être construits en utilisant les tables de la base
   de données pour passer des données supplémentaires du notifieur aux écouteurs.
  </para>

  <para>
   L'information passée au client pour une notification inclut le
   nom de la notification et le <acronym>PID</acronym> du processus serveur de la session
   le notifiant. C'est au concepteur de la base de données de définir les noms
   de notification utilisés dans une base de données précise et la
   signification de chacun.
  </para>

  <para>
   It is up to the database designer to define the channel names that will
   be used in a given database and what each one means.
   Habituellement, le nom du canal correspond au nom d'une table
   dans la base de données. L'événement notify signifie
   essentiellement <quote>J'ai modifié cette table, jetez-y un &oelig;il pour
   vérifier ce qu'il y a de nouveau</quote>. Mais cette association n'est 
   pas contrôlée par les commandes <command>NOTIFY</command> et
   <command>LISTEN</command>. Un concepteur de bases de données
   peut, par exemple, utiliser plusieurs noms de canal différents pour signaler
   différentes sortes de modifications au sein d'une même table. Alternatively,
   the payload string could be used to differentiate various cases.
  </para>

  <para>
   Lorsque <command>NOTIFY</command> est utilisé pour signaler des
   modifications sur une table particulière, une technique de programmation
   utile est de placer le <command>NOTIFY</command> dans une règle 
   déclenchée par les mises à jour de la table. De cette façon, la notification
   est automatique lors d'une modification de la table et le programmeur
   de l'application ne peut accidentellement oublier de le faire.
  </para>

  <para>
   <command>NOTIFY</command> interagit fortement avec les transactions SQL.
   Primo, si un <command>NOTIFY</command> est exécuté
   à l'intérieur d'une transaction, les événements notify ne sont pas délivrés
   avant que la transaction ne soit validée, et à cette condition uniquement.
   En effet, si la transaction est annulée, les commandes qu'elle 
   contient n'ont aucun effet, y compris <command>NOTIFY</command>. 
   Cela peut toutefois s'avérer déconcertant pour quiconque s'attend à une
   délivrance immédiate des notifications.
  </para>
  <para>
   Secondo, si une session à l'écoute reçoit un signal de notification alors
   qu'une transaction y est active, la notification n'est pas délivrée au client
   connecté avant la fin de cette transaction (par validation ou annulation).
   Là encore, si une notification est délivrée à l'intérieur d'une transaction
   finalement annulée, on pourrait espérer annuler cette notification par
   quelque moyen &mdash; 
   mais le serveur ne peut pas <quote>reprendre</quote> une notification déjà
   envoyée au client. C'est pourquoi les notifications ne sont
   délivrés qu'entre les transactions. Il est, de ce fait, important que les
   applications qui utilisent <command>NOTIFY</command> pour l'envoi de signaux
   en temps réel conservent des transactions courtes.
  </para>

  <para>
   If the same channel name is signaled multiple times from the same
   transaction with identical payload strings, the
   database server can decide to deliver a single notification only.
   On the other hand, notifications with distinct payload strings will
   always be delivered as distinct notifications. Similarly, notifications from
   different transactions will never get folded into one notification.
   Except for dropping later instances of duplicate notifications,
   <command>NOTIFY</command> guarantees that notifications from the same
   transaction get delivered in the order they were sent.  It is also
   guaranteed that messages from different transactions are delivered in
   the order in which the transactions committed.
  </para>

  <para>
   Il est courant qu'un client qui exécute <command>NOTIFY</command>
   écoute lui-même des notifications de même canal. Dans ce cas, il récupère une
   notification, comme toutes les autres sessions en écoute.
   Suivant la logique de l'application, cela peut engendre un travail
   inutile, par exemple lire une table de la base de données pour trouver les
   mises à jour que cette session a elle-même écrites. Il est possible d'éviter
   ce travail supplémentaire en verifiant si le <acronym>PID</acronym> du processus
   serveur de la session notifiante (fourni dans le message d'événement de la
   notification) est le même que le <acronym>PID</acronym> de la session
   courante (disponible à partir de <application>libpq</application>).
   S'ils sont identiques, la notification est le retour du travail actuel et
   peut être ignorée.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">canal</replaceable></term>
    <listitem>
     <para>
      Nom du canal à signaler (identifiant quelconque).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><replaceable class="PARAMETER">payload</replaceable></term>
    <listitem>
     <para>
      The <quote>payload</quote> string to be communicated along with the
      notification.  This must be specified as a simple string literal.
      In the default configuration it must be shorter than 8000 bytes.
      (If binary data or large amounts of information need to be communicated,
      it's best to put it in a database table and send the key of the record.)
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   There is a queue that holds notifications that have been sent but not
   yet processed by all listening sessions.  If this queue becomes full,
   transactions calling <command>NOTIFY</command> will fail at commit.
   The queue is quite large (8GB in a standard installation) and should be
   sufficiently sized for almost every use case. However, no cleanup can take
   place if a session executes <command>LISTEN</command> and then enters a
   transaction for a very long time. Once the queue is half full you will see
   warnings in the log file pointing you to the session that is preventing
   cleanup. In this case you should make sure that this session ends its
   current transaction so that cleanup can proceed.
  </para>
  <para>
   A transaction that has executed <command>NOTIFY</command> cannot be
   prepared for two-phase commit.
  </para>

  <refsect2>
   <title>pg_notify</title>

   <indexterm>
    <primary>pg_notify</primary>
   </indexterm>

   <para>
    To send a notification you can also use the function
    <literal><function>pg_notify</function>(<type>text</type>,
    <type>text</type>)</literal>. The function takes the channel name as the
    first argument and the payload as the second. The function is much easier
    to use than the <command>NOTIFY</command> command if you need to work with
    non-constant channel names and payloads.
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Configurer et exécuter une séquence listen/notify à partir de
   <application>psql</application>&nbsp;:

<programlisting>LISTEN virtual;
NOTIFY virtual;
Asynchronous notification "virtual" received from server process with PID 8448.
NOTIFY virtual, 'This is the payload';
Asynchronous notification "virtual" with payload "This is the payload" received from server process with PID 8448.

LISTEN foo;
SELECT pg_notify('fo' || 'o', 'pay' || 'load');
Asynchronous notification "foo" with payload "payload" received from server process with PID 14728.

</programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Il n'y a pas d'instruction <command>NOTIFY</command> dans le standard SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-listen"/></member>
   <member><xref linkend="sql-unlisten"/></member>
  </simplelist>
 </refsect1>
</refentry>
