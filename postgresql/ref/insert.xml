<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060622 : Relecture initiale -->

<refentry id="sql-insert">
 <indexterm zone="sql-insert">
  <primary>INSERT</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>INSERT</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>INSERT</refname>
  <refpurpose>Insérer de nouvelles lignes dans une table</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <synopsis>[ WITH [ RECURSIVE ] <replaceable class="parameter">requête_with</replaceable> [, ...] ]
INSERT INTO <replaceable class="PARAMETER">nom_table</replaceable> [ AS <replaceable class="parameter">alias</replaceable> ] [ ( <replaceable class="PARAMETER">nom_colonne</replaceable> [, ...] ) ]
    { DEFAULT VALUES | VALUES ( { <replaceable class="PARAMETER">expression</replaceable> | DEFAULT } [, ...] ) [, ...] | <replaceable class="PARAMETER">requête</replaceable> }
    [ ON CONFLICT [ <replaceable class="parameter">cible_conflit</replaceable> ] <replaceable class="parameter">action_conflit</replaceable> ]
    [ RETURNING * | <replaceable class="parameter">expression_sortie</replaceable> [ [ AS ] <replaceable class="parameter">nom_sortie</replaceable> ] [, ...] ]

<phrase>where <replaceable class="parameter">cible_conflit</replaceable> peut valoir&nbsp;:</phrase>

    ( { <replaceable class="parameter">nom_colonne_index</replaceable> | ( <replaceable class="parameter">expression_index</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">classe_operateur</replaceable> ] [, ...] ) [ WHERE <replaceable class="PARAMETER">predicat_index</replaceable> ]
    ON CONSTRAINT <replaceable class="PARAMETER">nom_constrainte</replaceable>

<phrase>and <replaceable class="parameter">action_conflit</replaceable> peut valoir&nbsp;:</phrase>

    DO NOTHING
    DO UPDATE SET { <replaceable class="PARAMETER">nom_colonne</replaceable> = { <replaceable class="PARAMETER">expression</replaceable> | DEFAULT } |
                    ( <replaceable class="PARAMETER">nom_colonne</replaceable> [, ...] ) = ( { <replaceable class="PARAMETER">expression</replaceable> | DEFAULT } [, ...] ) |
                    ( <replaceable class="PARAMETER">nom_colonne</replaceable> [, ...] ) = ( <replaceable class="PARAMETER">sous-SELECT</replaceable> )
                  } [, ...]
              [ WHERE <replaceable class="PARAMETER">condition</replaceable> ]
  </synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>INSERT</command> insère de nouvelles lignes dans une
   table. Vous pouvez insérer une ou plusieurs lignes spécifiées
   par les expressions de valeur, ou zéro ou plusieurs lignes
   provenant d'une requête.
  </para>

  <para>
   L'ordre des noms des colonnes n'a pas d'importance. Si
   aucune liste de noms de colonnes n'est donnée,
   toutes les colonnes de la table sont utilisée dans l'ordre de leur déclaration (les
   <replaceable>N</replaceable> premiers noms de colonnes si seules <replaceable>N</replaceable>
   valeurs de colonnes sont fournies dans la clause <literal>VALUES</literal> ou dans
   la <replaceable>requête</replaceable>). Les valeurs fournies par la clause
   <literal>VALUES</literal> ou par la <replaceable>requête</replaceable> sont associées à la
   liste explicite ou implicite des colonnes de gauche à droite.
  </para>

  <para>
   Chaque colonne absente de la liste, implicite ou explicite, des colonnes se voit
   attribuer sa valeur par défaut, s'il y en a une, ou NULL dans le cas contraire.
  </para>

  <para>
   Un transtypage automatique est entrepris lorsque l'expression d'une colonne ne correspond
   pas au type de donnée déclaré.
  </para>

  <para>
   <literal>ON CONFLICT</literal> can be used to specify an alternative
   action to raising a unique constraint or exclusion constraint
   violation error. (See <xref linkend="sql-on-conflict"
   endterm="sql-on-conflict-title"/> below.)
  </para>

  <para>
   La clause <literal>RETURNING</literal> optionnelle fait que
   <command>INSERT</command> calcule et renvoie le(s) valeur(s) basée(s) sur
   chaque ligne en cours d'insertion (or updated, if an <literal>ON CONFLICT
   DO UPDATE</literal> clause was used). C'est principalement utile pour
   obtenir
   les valeurs qui ont été fournies par défaut, comme un numéro de séquence.
   Néanmoins, toute expression utilisant les colonnes de la table est autorisée.
   La syntaxe de la liste <literal>RETURNING</literal> est identique à celle de
   la commande <command>SELECT</command>. Only rows that were successfully
   inserted or updated will be returned.  For example, if a row was
   locked but not updated because an <literal>ON CONFLICT DO UPDATE
   ... WHERE</literal> clause <replaceable
   class="PARAMETER">condition</replaceable> was not satisfied, the
   row will not be returned.
  </para>

  <para>
   You must have <literal>INSERT</literal> privilege on a table in
   order to insert into it.  If <literal>ON CONFLICT DO UPDATE</literal> is
   present, <literal>UPDATE</literal> privilege on the table is also
   required.
  </para>

  <para>
   If a column list is specified, you only need
   <literal>INSERT</literal> privilege on the listed columns.
   Similarly, when <literal>ON CONFLICT DO UPDATE</literal> is specified, you
   only need <literal>UPDATE</literal> privilege on the column(s) that are
   listed to be updated.  However, <literal>ON CONFLICT DO UPDATE</literal>
   also requires <literal>SELECT</literal> privilege on any column whose
   values are read in the <literal>ON CONFLICT DO UPDATE</literal>
   expressions or <replaceable>condition</replaceable>.
  </para>

  <para>
   Use of the <literal>RETURNING</literal> clause requires <literal>SELECT</literal>
   privilege on all columns mentioned in <literal>RETURNING</literal>.
   If you use the <replaceable
   class="PARAMETER">query</replaceable> clause to insert rows from a
   query, you of course need to have <literal>SELECT</literal> privilege on
   any table or column used in the query.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <refsect2 id="SQL-INSERTING-PARAMS">
   <title id="sql-inserting-params-title">Inserting</title>

   <para>
    This section covers parameters that may be used when only
    inserting new rows.  Parameters <emphasis>exclusively</emphasis>
    used with the <literal>ON CONFLICT</literal> clause are described
    separately.
   </para>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">with_query</replaceable></term>
      <listitem>
       <para>
        The <literal>WITH</literal> clause allows you to specify one or more
        subqueries that can be referenced by name in the <command>INSERT</command>
        query. See <xref linkend="queries-with"/> and <xref linkend="sql-select"/>
        for details.
       </para>
       <para>
        It is possible for the <replaceable class="parameter">query</replaceable>
        (<command>SELECT</command> statement)
        to also contain a <literal>WITH</literal> clause.  In such a case both
        sets of <replaceable>with_query</replaceable> can be referenced within
        the <replaceable class="parameter">query</replaceable>, but the
        second one takes precedence since it is more closely nested.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">table_name</replaceable></term>
      <listitem>
       <para>
        The name (optionally schema-qualified) of an existing table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">alias</replaceable></term>
      <listitem>
       <para>
        A substitute name for <replaceable
        class="PARAMETER">table_name</replaceable>.  When an alias is
        provided, it completely hides the actual name of the table.
        This is particularly useful when <literal>ON CONFLICT DO
        UPDATE</literal> targets a table named excluded, since that's
        also the name of the special table representing rows proposed
        for insertion.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><replaceable class="PARAMETER">column_name</replaceable></term>
      <listitem>
       <para>
        The name of a column in the table named by <replaceable
        class="PARAMETER">table_name</replaceable>.  The column name
        can be qualified with a subfield name or array subscript, if
        needed.  (Inserting into only some fields of a composite
        column leaves the other fields null.)  When referencing a
        column with <literal>ON CONFLICT DO UPDATE</literal>, do not include
        the table's name in the specification of a target column.  For
        example, <literal>INSERT ... ON CONFLICT DO UPDATE tab SET
        table_name.col = 1</literal> is invalid (this follows the general
        behavior for <command>UPDATE</command>).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT VALUES</literal></term>
      <listitem>
       <para>
        All columns will be filled with their default values.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">expression</replaceable></term>
      <listitem>
       <para>
        An expression or value to assign to the corresponding column.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT</literal></term>
      <listitem>
       <para>
        The corresponding column will be filled with
        its default value.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">query</replaceable></term>
      <listitem>
       <para>
        A query (<command>SELECT</command> statement) that supplies the
        rows to be inserted.  Refer to the
        <xref linkend="sql-select"/>
        statement for a description of the syntax.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">output_expression</replaceable></term>
      <listitem>
       <para>
        An expression to be computed and returned by the
        <command>INSERT</command> command after each row is inserted or
        updated. The expression can use any column names of the table
        named by <replaceable
        class="PARAMETER">table_name</replaceable>.  Write
        <literal>*</literal> to return all columns of the inserted or updated
        row(s).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">output_name</replaceable></term>
      <listitem>
       <para>
        A name to use for a returned column.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
  </refsect2>

  <refsect2 id="sql-on-conflict">
   <title id="sql-on-conflict-title"><literal>ON CONFLICT</literal> Clause</title>
   <indexterm zone="SQL-INSERT">
    <primary>UPSERT</primary>
   </indexterm>
   <indexterm zone="SQL-INSERT">
    <primary>ON CONFLICT</primary>
   </indexterm>
   <para>
    The optional <literal>ON CONFLICT</literal> clause specifies an
    alternative action to raising a unique violation or exclusion
    constraint violation error.  For each individual row proposed for
    insertion, either the insertion proceeds, or, if an
    <emphasis>arbiter</emphasis> constraint or index specified by
    <parameter>conflict_target</parameter> is violated, the
    alternative <parameter>conflict_action</parameter> is taken.
    <literal>ON CONFLICT DO NOTHING</literal> simply avoids inserting
    a row as its alternative action.  <literal>ON CONFLICT DO
    UPDATE</literal> updates the existing row that conflicts with the
    row proposed for insertion as its alternative action.
   </para>

   <para>
    <parameter>conflict_target</parameter> can perform
    <emphasis>unique index inference</emphasis>.  When performing
    inference, it consists of one or more <replaceable
    class="PARAMETER">index_column_name</replaceable> columns and/or
    <replaceable class="PARAMETER">index_expression</replaceable>
    expressions, and an optional <replaceable class="PARAMETER">
    index_predicate</replaceable>.  All <replaceable
    class="PARAMETER">table_name</replaceable> unique indexes that,
    without regard to order, contain exactly the
    <parameter>conflict_target</parameter>-specified
    columns/expressions are inferred (chosen) as arbiter indexes.  If
    an <replaceable class="PARAMETER">index_predicate</replaceable> is
    specified, it must, as a further requirement for inference,
    satisfy arbiter indexes.  Note that this means a non-partial
    unique index (a unique index without a predicate) will be inferred
    (and thus used by <literal>ON CONFLICT</literal>) if such an index
    satisfying every other criteria is available.  If an attempt at
    inference is unsuccessful, an error is raised.
   </para>

   <para>
    <literal>ON CONFLICT DO UPDATE</literal> guarantees an atomic
    <command>INSERT</command> or <command>UPDATE</command> outcome;
    provided there is no independent error, one of those two outcomes
    is guaranteed, even under high concurrency.  This is also known as
    <firstterm>UPSERT</firstterm> &mdash; <quote>UPDATE or
    INSERT</quote>.
   </para>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">conflict_target</replaceable></term>
      <listitem>
       <para>
        Specifies which conflicts <literal>ON CONFLICT</literal> takes
        the alternative action on by choosing <firstterm>arbiter
        indexes</firstterm>.  Either performs <emphasis>unique index
        inference</emphasis>, or names a constraint explicitly.  For
        <literal>ON CONFLICT DO NOTHING</literal>, it is optional to
        specify a <parameter>conflict_target</parameter>; when
        omitted, conflicts with all usable constraints (and unique
        indexes) are handled.  For <literal>ON CONFLICT DO
        UPDATE</literal>, a <parameter>conflict_target</parameter>
        <emphasis>must</emphasis> be provided.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">conflict_action</replaceable></term>
      <listitem>
       <para>
        <parameter>conflict_action</parameter> specifies an
        alternative <literal>ON CONFLICT</literal> action.  It can be
        either <literal>DO NOTHING</literal>, or a <literal>DO
        UPDATE</literal> clause specifying the exact details of the
        <literal>UPDATE</literal> action to be performed in case of a
        conflict.  The <literal>SET</literal> and
        <literal>WHERE</literal> clauses in <literal>ON CONFLICT DO
        UPDATE</literal> have access to the existing row using the
        table's name (or an alias), and to rows proposed for insertion
        using the special <varname>excluded</varname> table.
        <literal>SELECT</literal> privilege is required on any column in the
        target table where corresponding <varname>excluded</varname>
        columns are read.
       </para>
       <para>
        Note that the effects of all per-row <literal>BEFORE
        INSERT</literal> triggers are reflected in
        <varname>excluded</varname> values, since those effects may
        have contributed to the row being excluded from insertion.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">index_column_name</replaceable></term>
      <listitem>
       <para>
        The name of a <replaceable
        class="PARAMETER">table_name</replaceable> column.  Used to
        infer arbiter indexes.  Follows <command>CREATE
        INDEX</command> format.  <literal>SELECT</literal> privilege on
        <replaceable class="PARAMETER">index_column_name</replaceable>
        is required.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">index_expression</replaceable></term>
      <listitem>
       <para>
        Similar to <replaceable
        class="PARAMETER">index_column_name</replaceable>, but used to
        infer expressions on <replaceable
        class="PARAMETER">table_name</replaceable> columns appearing
        within index definitions (not simple columns).  Follows
        <command>CREATE INDEX</command> format.  <literal>SELECT</literal>
        privilege on any column appearing within <replaceable
        class="PARAMETER">index_expression</replaceable> is required.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">collation</replaceable></term>
      <listitem>
       <para>
        When specified, mandates that corresponding <replaceable
        class="PARAMETER">index_column_name</replaceable> or
        <replaceable class="PARAMETER">index_expression</replaceable>
        use a particular collation in order to be matched during
        inference.  Typically this is omitted, as collations usually
        do not affect whether or not a constraint violation occurs.
        Follows <command>CREATE INDEX</command> format.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">opclass</replaceable></term>
      <listitem>
       <para>
        When specified, mandates that corresponding <replaceable
        class="PARAMETER">index_column_name</replaceable> or
        <replaceable class="PARAMETER">index_expression</replaceable>
        use particular operator class in order to be matched during
        inference.  Typically this is omitted,  as the
        <emphasis>equality</emphasis> semantics are often equivalent
        across a type's operator classes anyway, or because it's
        sufficient to trust that the defined unique indexes have the
        pertinent definition of equality.  Follows <command>CREATE
        INDEX</command> format.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">index_predicate</replaceable></term>
      <listitem>
       <para>
        Used to allow inference of partial unique indexes.  Any
        indexes that satisfy the predicate (which need not actually be
        partial indexes) can be inferred.  Follows <command>CREATE
        INDEX</command> format.  <literal>SELECT</literal> privilege on any
        column appearing within <replaceable
        class="PARAMETER">index_predicate</replaceable> is required.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">constraint_name</replaceable></term>
      <listitem>
       <para>
        Explicitly specifies an arbiter
        <emphasis>constraint</emphasis> by name, rather than inferring
        a constraint or index.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">condition</replaceable></term>
      <listitem>
       <para>
        An expression that returns a value of type
        <type>boolean</type>.  Only rows for which this expression
        returns <literal>true</literal> will be updated, although all
        rows will be locked when the <literal>ON CONFLICT DO UPDATE</literal>
        action is taken.  Note that
        <replaceable>condition</replaceable> is evaluated last, after
        a conflict has been identified as a candidate to update.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   <para>
    Note that exclusion constraints are not supported as arbiters with
    <literal>ON CONFLICT DO UPDATE</literal>. In all cases, only
    <literal>NOT DEFERRABLE</literal> constraints and unique indexes
    are supported as arbiters.
   </para>

   <para>
    <command>INSERT</command> with an <literal>ON CONFLICT DO UPDATE</literal>
    clause is a <quote>deterministic</quote> statement.  This means
    that the command will not be allowed to affect any single existing
    row more than once; a cardinality violation error will be raised
    when this situation arises.  Rows proposed for insertion should
    not duplicate each other in terms of attributes constrained by an
    arbiter index or constraint.
   </para>
   <tip>
    <para>
     It is often preferable to use unique index inference rather than
     naming a constraint directly using <literal>ON CONFLICT ON
     CONSTRAINT</literal> <replaceable class="PARAMETER">
     constraint_name</replaceable>.  Inference will continue to work
     correctly when the underlying index is replaced by another more
     or less equivalent index in an overlapping way, for example when
     using <literal>CREATE UNIQUE INDEX ...  CONCURRENTLY</literal>
     before dropping the index being replaced.
    </para>
   </tip>

  </refsect2>
 </refsect1>

 <refsect1>
  <title>Sorties</title>

  <para>
   En cas de succès, la commande <command>INSERT</command> renvoie un code de la forme
   <screen>INSERT <replaceable>oid</replaceable> <replaceable class="parameter">nombre</replaceable>
   </screen>
   <replaceable class="parameter">nombre</replaceable> correspond au nombre
   de lignes insérées ou mises à jour. Si <replaceable class="parameter">nombre</replaceable>
   vaut exactement un et que la table cible contient des OID, alors
   <replaceable class="parameter">oid</replaceable> est l'<acronym>OID</acronym> affecté à la
   ligne insérée. The single row must have been inserted rather than updated.
   Sinon, <replaceable class="parameter">oid</replaceable> vaut zéro.
  </para>

  <para>
   Si la commande <command>INSERT</command> contient une clause
   <literal>RETURNING</literal>, le résultat sera similaire à celui d'une
   instruction <command>SELECT</command> contenant les colonnes et les valeurs
   définies dans la liste <literal>RETURNING</literal>, à partir de la liste
   des lignes insérées ou mises à jour par la commande.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Insérer une ligne dans la table <literal>films</literal>&nbsp;:

   <programlisting>INSERT INTO films
	VALUES ('UA502', 'Bananas', 105, '1971-07-13', 'Comédie', '82 minutes');
   </programlisting>
  </para>

  <para>
   Dans l'exemple suivant, la colonne <literal>longueur</literal> est omise et
   prend donc sa valeur par défaut&nbsp;:

   <programlisting>INSERT INTO films (code, titre, did, date_prod, genre)
    VALUES ('T_601', 'Yojimbo', 106, '1961-06-16', 'Drame');
   </programlisting>
  </para>

  <para>
   L'exemple suivant utilise la clause <literal>DEFAULT</literal> pour les
   colonnes date plutôt qu'une valeur précise&nbsp;:

   <programlisting>INSERT INTO films VALUES
    ('UA502', 'Bananas', 105, DEFAULT, 'Comédie', '82 minutes');
INSERT INTO films (code, titre, did, date_prod, genre)
    VALUES ('T_601', 'Yojimbo', 106, DEFAULT, 'Drame');
   </programlisting>
  </para>

  <para>
   Insérer une ligne constituée uniquement de valeurs par défaut&nbsp;:

   <programlisting>INSERT INTO films DEFAULT VALUES;
   </programlisting>
  </para>

  <para>
   Pour insérer plusieurs lignes en utilisant la syntaxe multi-lignes
   <command>VALUES</command>&nbsp;:

   <programlisting>INSERT INTO films (code, titre, did, date_prod, genre) VALUES
    ('B6717', 'Tampopo', 110, '1985-02-10', 'Comedy'),
    ('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');
   </programlisting>
  </para>

  <para>
   Insérer dans la table <literal>films</literal> des lignes extraites de la table
   <literal>tmp_films</literal> (la disposition des colonnes est identique dans les deux tables)&nbsp;:

   <programlisting>INSERT INTO films SELECT * FROM tmp_films WHERE date_prod &lt; '2004-05-07';
   </programlisting>
  </para>

  <para>
   Insérer dans des colonnes de type tableau&nbsp;:
   <programlisting>-- Créer un jeu de 3 cases sur 3
INSERT INTO tictactoe (game, board[1:3][1:3])
    VALUES (1, '{{" "," "," "},{" "," "," "},{" "," "," "}}');
-- Les indices de l'exemple ci-dessus ne sont pas vraiment nécessaires
INSERT INTO tictactoe (game, board)
    VALUES (2, '{{X," "," "},{" ",O," "},{" ",X," "}}');
   </programlisting>
  </para>

  <para>
   Insérer une ligne simple dans la table <literal>distributeurs</literal>, en
   renvoyant le numéro de séquence généré par la clause
   <literal>DEFAULT</literal>&nbsp;:

   <programlisting>INSERT INTO distributeurs (did, dnom) VALUES (DEFAULT, 'XYZ Widgets')
   RETURNING did;
   </programlisting>
  </para>

  <para>
   Augmenter le nombre de ventes du vendeur qui gère le compte Acme
   Corporation, et enregistrer la ligne complètement mise à jour avec l'heure
   courante dans une table de traçage&nbsp;:
   <programlisting>
WITH upd AS (
  UPDATE employees SET sales_count = sales_count + 1 WHERE id =
    (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation')
    RETURNING *
)
INSERT INTO employees_log SELECT *, current_timestamp FROM upd;
</programlisting>
  </para>
  <para>
   Insert or update new distributors as appropriate.  Assumes a unique
   index has been defined that constrains values appearing in the
   <literal>did</literal> column.  Note that the special
   <varname>excluded</varname> table is used to reference values originally
   proposed for insertion:
<programlisting>
INSERT INTO distributors (did, dname)
    VALUES (5, 'Gizmo Transglobal'), (6, 'Associated Computing, Inc')
    ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED.dname;
</programlisting>
  </para>
  <para>
   Insert a distributor, or do nothing for rows proposed for insertion
   when an existing, excluded row (a row with a matching constrained
   column or columns after before row insert triggers fire) exists.
   Example assumes a unique index has been defined that constrains
   values appearing in the <literal>did</literal> column:
<programlisting>
INSERT INTO distributors (did, dname) VALUES (7, 'Redline GmbH')
    ON CONFLICT (did) DO NOTHING;
</programlisting>
  </para>
  <para>
   Insert or update new distributors as appropriate.  Example assumes
   a unique index has been defined that constrains values appearing in
   the <literal>did</literal> column.  <literal>WHERE</literal> clause is
   used to limit the rows actually updated (any existing row not
   updated will still be locked, though):
<programlisting>
-- Don't update existing distributors based in a certain ZIP code
INSERT INTO distributors AS d (did, dname) VALUES (8, 'Anvil Distribution')
    ON CONFLICT (did) DO UPDATE
    SET dname = EXCLUDED.dname || ' (formerly ' || d.dname || ')'
    WHERE d.zipcode &lt;&gt; '21201';

-- Name a constraint directly in the statement (uses associated
-- index to arbitrate taking the DO NOTHING action)
INSERT INTO distributors (did, dname) VALUES (9, 'Antwerp Design')
    ON CONFLICT ON CONSTRAINT distributors_pkey DO NOTHING;
</programlisting>
  </para>
  <para>
   Insert new distributor if possible;  otherwise
   <literal>DO NOTHING</literal>.  Example assumes a unique index has been
   defined that constrains values appearing in the
   <literal>did</literal> column on a subset of rows where the
   <literal>is_active</literal> Boolean column evaluates to
   <literal>true</literal>:
<programlisting>
-- This statement could infer a partial unique index on "did"
-- with a predicate of "WHERE is_active", but it could also
-- just use a regular unique constraint on "did"
INSERT INTO distributors (did, dname) VALUES (10, 'Conrad International')
    ON CONFLICT (did) WHERE is_active DO NOTHING;
</programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   <command>INSERT</command> est conforme au standard SQL, sauf la clause
   <literal>RETURNING</literal> qui est une extension
   <productname>PostgreSQL</productname>, comme la possibilité d'utiliser la
   clause <literal>WITH</literal> avec l'instruction <command>INSERT</command>, and the ability to
   specify an alternative action with <literal>ON CONFLICT</literal>.
   Le standard n'autorise toutefois pas l'omission de la liste des noms de colonnes alors
   qu'une valeur n'est pas affectée à chaque colonne, que ce soit à l'aide de la clause
   <literal>VALUES</literal> ou à partir de la <replaceable>requête</replaceable>.
  </para>

  <para>
   Les limitations possibles de la clause <replaceable class="parameter">requête</replaceable>
   sont documentées sous <xref linkend="sql-select"/>.
  </para>
 </refsect1>
</refentry>
