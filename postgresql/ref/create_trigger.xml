<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060618 -->

<refentry id="sql-createtrigger">
 <refmeta>
  <refentrytitle>CREATE TRIGGER</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TRIGGER</refname>
  <refpurpose>Définir un nouveau déclencheur</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE TRIGGER <replaceable class="parameter">nom</replaceable> { BEFORE | AFTER } { <replaceable class="parameter">evenement</replaceable> [ OR ... ] }
    ON <replaceable class="parameter">table</replaceable> [ FOR [ EACH ] { ROW | STATEMENT } ]
    [ WHEN ( <replaceable class="parameter">condition</replaceable> ) ]
    EXECUTE PROCEDURE <replaceable class="parameter">nom_fonction</replaceable> ( <replaceable class="parameter">arguments</replaceable> )
</synopsis>
 </refsynopsisdiv>
 
 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-createtrigger">
   <primary>CREATE TRIGGER</primary>
  </indexterm>

  <para>
   <command>CREATE TRIGGER</command> crée un nouveau déclencheur. Le
   déclencheur est associé à la table spécifiée et exécute la fonction
   <replaceable class="parameter">nom_fonction</replaceable> lorsque
   certains événements surviennent.
  </para>

  <para>
   L'appel du déclencheur peut avoir lieu avant que l'opération
   ne soit tentée sur une ligne (avant la vérification des contraintes et 
   la tentative d'<command>INSERT</command>, <command>UPDATE</command> ou
   <command>DELETE</command>) ou une fois que l'opération est
   terminée (après la vérification des contraintes et la fin de la commande
   <command>INSERT</command>, <command>UPDATE</command> ou 
   <command>DELETE</command>). Si le déclencheur est lancé avant
   l'événement, le déclencheur peut ignorer l'opération sur la ligne
   courante ou modifier la ligne en cours d'insertion (uniquement pour les
   opérations <command>INSERT</command> et <command>UPDATE</command>). Si le
   déclencheur est activé après l'événement, toute modification, dont les
   autres triggers, est <quote>visible</quote>
   par le déclencheur.
  </para>

  <para>
   Un déclencheur marqué <literal>FOR EACH ROW</literal> est appelé pour
   chaque ligne que l'opération modifie. Par exemple, un
   <command>DELETE</command> affectant dix lignes entraîne dix appels distincts
   de tout déclencheur <literal>ON DELETE</literal> sur la relation cible,
   une fois par ligne supprimée. Au contraire, un
   déclencheur marqué <literal>FOR EACH STATEMENT</literal> ne s'exécute
   qu'une fois pour une opération donnée, quelque soit le nombre de lignes
   modifiées (en particulier, une opération qui ne modifie aucune ligne résulte
   toujours en l'exécution des déclencheurs <literal>FOR EACH STATEMENT</literal> applicables).
  </para>

  <para>
   De plus, les triggers peuvent être définis pour être déclenchés suite à
   l'exécution d'un <command>TRUNCATE</command>, mais seulement dans le cas d'un
   trigger <literal>FOR EACH STATEMENT</literal>.
  </para>

  <para>
   Also, a trigger definition can specify a boolean <literal>WHEN</literal>
   condition, which will be tested to see whether the trigger should
   be fired.  In row-level triggers the <literal>WHEN</literal> condition can
   examine the old and/or new values of columns of the row.  Statement-level
   triggers can also have <literal>WHEN</literal> conditions, although the feature
   is not so useful for them since the condition cannot refer to any values
   in the table.
  </para>

  <para>
   Si plusieurs déclencheurs du même genre sont définis pour le même événement,
   ils sont déclenchés suivant l'ordre alphabétique de leur nom.
  </para>

  <para>
   <command>SELECT</command> ne modifie aucune ligne&nbsp;; la création de
   déclencheurs sur <command>SELECT</command> n'est donc pas possible.
   Les règles et vues sont plus appropriées dans ce cas.
  </para>

  <para>
   <xref linkend="triggers"/> présente de plus amples informations sur les
   déclencheurs.
  </para>
 </refsect1>
  
 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom du nouveau déclencheur. Il doit être distinct du nom de
      tout autre déclencheur sur la table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>BEFORE</literal></term>
    <term><literal>AFTER</literal></term>
    <listitem>
     <para>
      Détermine si la fonction est appelée avant ou après l'événement.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">événement</replaceable></term>
    <listitem>
     <para>
      Peut-être <command>INSERT</command>, <command>UPDATE</command> ou
      <command>DELETE</command> ou <command>TRUNCATE</command>&nbsp;;
      précise l'événement qui active le
      déclencheur. Plusieurs événements peuvent être précisés en les séparant par
      <literal>OR</literal>.
     </para>

     <para>
      For <command>UPDATE</command> triggers, it is possible to
      specify a list of columns using this syntax:
<synopsis>
UPDATE OF <replaceable>column_name1</replaceable> [, <replaceable>column_name2</replaceable> ... ]
</synopsis>
      The trigger will only fire if at least one of the listed columns
      is mentioned as a target of the update.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">table</replaceable></term>
    <listitem>
     <para>
      Le nom (éventuellement qualifié du nom du schéma) de la table à laquelle
      est rattaché le déclencheur.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FOR EACH ROW</literal></term>
    <term><literal>FOR EACH STATEMENT</literal></term>

    <listitem>
     <para>
      Précise si la procédure du déclencheur doit être lancée 
      pour chaque ligne affectée par l'événement ou
      simplement pour chaque instruction SQL. <literal>FOR EACH STATEMENT</literal>
      est la valeur par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition</replaceable></term>
    <listitem>
     <para>
      A Boolean expression that determines whether the trigger function
      will actually be executed.  If <literal>WHEN</literal> is specified, the
      function will only be called if the <replaceable
      class="parameter">condition</replaceable> returns <literal>true</literal>.
      In <literal>FOR EACH ROW</literal> triggers, the <literal>WHEN</literal>
      condition can refer to columns of the old and/or new row values
      by writing <literal>OLD.<replaceable
      class="parameter">column_name</replaceable></literal> or
      <literal>NEW.<replaceable
      class="parameter">column_name</replaceable></literal> respectively.
      Of course, <literal>INSERT</literal> triggers cannot refer to <literal>OLD</literal>
      and <literal>DELETE</literal> triggers cannot refer to <literal>NEW</literal>.
     </para>

     <para>
      Currently, <literal>WHEN</literal> expressions cannot contain
      subqueries.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_fonction</replaceable></term>
    <listitem>
     <para>
      Une fonction utilisateur, déclarée sans argument et renvoyant le type <literal>trigger</literal>, exécutée
      à l'activation du déclencheur.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">arguments</replaceable></term>
    <listitem>
     <para>
      Une liste optionnelle d'arguments séparés par des virgules à fournir à la
      fonction lors de l'activation du déclencheur. Les arguments sont des
      chaînes littérales constantes. Il est possible d'écrire ici de 
      simples noms et des constantes numériques mais ils sont tous convertis
      en chaîne. L'accès aux arguments du trigger depuis la fonction peut
      différer de l'accès aux arguments d'une fonction standard&nbsp;; la consultation
      des caractéristiques d'implantation du langage de la fonction peut alors s'avérer
      utile.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 id="sql-createtrigger-notes">
  <title>Notes</title>

  <para>
   Pour créer un déclencheur sur une table, l'utilisateur doit posséder le droit
   <literal>TRIGGER</literal> sur la table.
  </para>

  <para>
   Utiliser <xref linkend="sql-droptrigger"/>
   pour supprimer un déclencheur.
  </para>

  <para>
   A column-specific trigger (<literal>FOR UPDATE OF
   <replaceable>column_name</replaceable></literal>) will fire when any
   of its columns are listed as targets in the <command>UPDATE</command>
   command's <literal>SET</literal> list.  It is possible for a column's value
   to change even when the trigger is not fired, because changes made to the
   row's contents by <literal>BEFORE UPDATE</literal> triggers are not considered.
   Conversely, a command such as <literal>UPDATE ... SET x = x ...</literal>
   will fire a trigger on column <literal>x</literal>, even though the column's
   value did not change.
  </para>

  <para>
   In a <literal>BEFORE</literal> trigger, the <literal>WHEN</literal> condition is
   evaluated just before the function is or would be executed, so using
   <literal>WHEN</literal> is not materially different from testing the same
   condition at the beginning of the trigger function.  Note in particular
   that the <literal>NEW</literal> row seen by the condition is the current value,
   as possibly modified by earlier triggers.  Also, a <literal>BEFORE</literal>
   trigger's <literal>WHEN</literal> condition is not allowed to examine the
   system columns of the <literal>NEW</literal> row (such as <literal>oid</literal>),
   because those won't have been set yet.
  </para>

  <para>
   In an <literal>AFTER</literal> trigger, the <literal>WHEN</literal> condition is
   evaluated just after the row update occurs, and it determines whether an
   event is queued to fire the trigger at the end of statement.  So when an
   <literal>AFTER</literal> trigger's <literal>WHEN</literal> condition does not return
   true, it is not necessary to queue an event nor to re-fetch the row at end
   of statement.  This can result in significant speedups in statements that
   modify many rows, if the trigger only needs to be fired for a few of the
   rows.
  </para>

  <para>
   Dans les versions de <productname>PostgreSQL</productname> antérieures à la
   7.3, il était nécessaire de déclarer un type <type>opaque</type> de 
   retour pour les fonctions déclencheur, plutôt que <type>trigger</type>. Pour
   pouvoir charger d'anciens fichiers de sauvegarde,
   <command>CREATE TRIGGER</command> accepte qu'une fonction déclare une valeur de retour de type
   <type>opaque</type>, mais il affiche un message d'avertissement et change le
   type de retour déclaré en <type>trigger</type>.
  </para>
 </refsect1>

 <refsect1 id="r1-sql-createtrigger-examples">
  <title>Exemples</title>

  <para>
   Execute the function <function>check_account_update</function> whenever
   a row of the table <literal>accounts</literal> is about to be updated:

<programlisting>
CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    EXECUTE PROCEDURE check_account_update();
</programlisting>

   The same, but only execute the function if column <literal>balance</literal>
   is specified as a target in the <command>UPDATE</command> command:

<programlisting>
CREATE TRIGGER check_update
    BEFORE UPDATE OF balance ON accounts
    FOR EACH ROW
    EXECUTE PROCEDURE check_account_update();
</programlisting>

   This form only executes the function if column <literal>balance</literal>
   has in fact changed value:

<programlisting>
CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.balance IS DISTINCT FROM NEW.balance)
    EXECUTE PROCEDURE check_account_update();
</programlisting>

   Call a function to log updates of <literal>accounts</literal>, but only if
   something changed:

<programlisting>
CREATE TRIGGER log_update
    AFTER UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.* IS DISTINCT FROM NEW.*)
    EXECUTE PROCEDURE log_account_update();
</programlisting>
  </para>

  <para>
   <xref linkend="trigger-example"/> contains a complete example of a trigger
   function written in C.
  </para>
 </refsect1>

 <refsect1 id="sql-createtrigger-compatibility">
  <title>Compatibilité</title>

  <para>
   L'instruction <command>CREATE TRIGGER</command> de
   <productname>PostgreSQL</productname> implante un sous-ensemble du standard
   <acronym>SQL</acronym>. Les fonctionnalités manquantes sont&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      SQL permet de définir des alias pour les lignes
      <quote>old</quote> et <quote>new</quote> ou pour les tables utilisée
      dans la définition des actions déclenchées (c'est-à-dire
      <literal>CREATE TRIGGER ... ON nomtable REFERENCING OLD ROW AS unnom NEW ROW AS unautrenom...</literal>).
      <productname>PostgreSQL</productname> autorise
      l'écriture de procédures de déclencheurs dans tout langage
      l'utilisateur. De ce fait, l'accès aux données est géré spécifiquement pour
      chaque langage.
     </para>
    </listitem>

    <listitem>
     <para>
      <productname>PostgreSQL</productname> n'autorise comme action déclenchée
      que l'exécution d'une fonction utilisateur. Le standard SQL, en revanche,
      autorise l'exécution d'autres commandes SQL, telles que
      <command>CREATE TABLE</command>. Cette limitation de <productname>PostgreSQL</productname>
      peut être facilement contournée par la création d'une fonction
      utilisateur qui exécute les commandes désirées.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Le standard SQL définit l'ordre de création comme ordre de lancement
   des déclencheurs multiples. <productname>PostgreSQL</productname> utilise
   l'ordre alphabétique de leur nom, jugé plus pratique.
  </para>

  <para>
   Le standard SQL précise que les déclencheurs <literal>BEFORE DELETE</literal> sur des
   suppressions en cascade se déclenchent <emphasis>après</emphasis> la fin du
   <literal>DELETE</literal> en cascade. 
   <productname>PostgreSQL</productname> définit que <literal>BEFORE DELETE</literal>
   se déclenche toujours avant l'action de suppression, même lors
   d'une action en cascade. Cela semble plus cohérent.
   There is also unpredictable
   behavior when <literal>BEFORE</literal> triggers modify rows or prevent
   updates during an update that is caused by a referential action.  This can
   lead to constraint violations or stored data that does not honor the
   referential constraint.
  </para>

  <para>
   La capacité à préciser plusieurs actions pour un seul déclencheur avec
   <literal>OR</literal> est une extension <productname>PostgreSQL</productname>.
  </para>

  <para>
   La possibilité d'exécuter un trigger suite à une commande
   <command>TRUNCATE</command> est une extension
   <productname>PostgreSQL</productname> du standard SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createfunction"/></member>
   <member><xref linkend="sql-altertrigger"/></member>
   <member><xref linkend="sql-droptrigger"/></member>
  </simplelist>
 </refsect1>
</refentry>
