<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060618 -->

<refentry id="sql-createtrigger">
 <refmeta>
  <refentrytitle>CREATE TRIGGER</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TRIGGER</refname>
  <refpurpose>Définir un nouveau déclencheur</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE TRIGGER <replaceable class="parameter">nom</replaceable> { BEFORE | AFTER } { <replaceable class="parameter">evenement</replaceable> [ OR ... ] }
    ON <replaceable class="parameter">table</replaceable> [ FOR [ EACH ] { ROW | STATEMENT } ]
    [ WHEN ( <replaceable class="parameter">condition</replaceable> ) ]
    EXECUTE PROCEDURE <replaceable class="parameter">nom_fonction</replaceable> ( <replaceable class="parameter">arguments</replaceable> )
</synopsis>
 </refsynopsisdiv>
 
 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-createtrigger">
   <primary>CREATE TRIGGER</primary>
  </indexterm>

  <para>
   <command>CREATE TRIGGER</command> crée un nouveau déclencheur. Le
   déclencheur est associé à la table spécifiée et exécute la fonction
   <replaceable class="parameter">nom_fonction</replaceable> lorsque
   certains événements surviennent.
  </para>

  <para>
   L'appel du déclencheur peut avoir lieu avant que l'opération
   ne soit tentée sur une ligne (avant la vérification des contraintes et 
   la tentative d'<command>INSERT</command>, <command>UPDATE</command> ou
   <command>DELETE</command>) ou une fois que l'opération est
   terminée (après la vérification des contraintes et la fin de la commande
   <command>INSERT</command>, <command>UPDATE</command> ou 
   <command>DELETE</command>). Si le déclencheur est lancé avant
   l'événement, le déclencheur peut ignorer l'opération sur la ligne
   courante ou modifier la ligne en cours d'insertion (uniquement pour les
   opérations <command>INSERT</command> et <command>UPDATE</command>). Si le
   déclencheur est activé après l'événement, toute modification, dont les
   autres triggers, est <quote>visible</quote>
   par le déclencheur.
  </para>

  <para>
   Un déclencheur marqué <literal>FOR EACH ROW</literal> est appelé pour
   chaque ligne que l'opération modifie. Par exemple, un
   <command>DELETE</command> affectant dix lignes entraîne dix appels distincts
   de tout déclencheur <literal>ON DELETE</literal> sur la relation cible,
   une fois par ligne supprimée. Au contraire, un
   déclencheur marqué <literal>FOR EACH STATEMENT</literal> ne s'exécute
   qu'une fois pour une opération donnée, quelque soit le nombre de lignes
   modifiées (en particulier, une opération qui ne modifie aucune ligne résulte
   toujours en l'exécution des déclencheurs <literal>FOR EACH STATEMENT</literal> applicables).
  </para>

  <para>
   De plus, les triggers peuvent être définis pour être déclenchés suite à
   l'exécution d'un <command>TRUNCATE</command>, mais seulement dans le cas d'un
   trigger <literal>FOR EACH STATEMENT</literal>.
  </para>

  <para>
   De plus, la définition d'un trigger peut spécifier une condition
   <literal>WHEN</literal> qui sera testée pour voir si le trigger doit
   réellement être déclenché. Dans les triggers au niveau ligne, la condition
   <literal>WHEN</literal> peut examiner l'ancienne et/ou la nouvelle valeurs
   des colonnes de la ligne. Les triggers au niveau instruction peuvent aussi
   avoir des conditions <literal>WHEN</literal>, bien que la fonctionnalité
   n'est pas aussi utile pour elles car la condition ne peut pas faire
   référence aux valeurs de la table.
  </para>

  <para>
   Si plusieurs déclencheurs du même genre sont définis pour le même événement,
   ils sont déclenchés suivant l'ordre alphabétique de leur nom.
  </para>

  <para>
   <command>SELECT</command> ne modifie aucune ligne&nbsp;; la création de
   déclencheurs sur <command>SELECT</command> n'est donc pas possible.
   Les règles et vues sont plus appropriées dans ce cas.
  </para>

  <para>
   <xref linkend="triggers"/> présente de plus amples informations sur les
   déclencheurs.
  </para>
 </refsect1>
  
 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom du nouveau déclencheur. Il doit être distinct du nom de
      tout autre déclencheur sur la table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>BEFORE</literal></term>
    <term><literal>AFTER</literal></term>
    <listitem>
     <para>
      Détermine si la fonction est appelée avant ou après l'événement.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">événement</replaceable></term>
    <listitem>
     <para>
      Peut-être <command>INSERT</command>, <command>UPDATE</command> ou
      <command>DELETE</command> ou <command>TRUNCATE</command>&nbsp;;
      précise l'événement qui active le
      déclencheur. Plusieurs événements peuvent être précisés en les séparant par
      <literal>OR</literal>.
     </para>

     <para>
      Pour les triggers se déclenchant suite à un <command>UPDATE</command>,
      il est possible de spécifier une liste de colonnes utilisant cette
      syntaxe&nbsp;:
<synopsis>
UPDATE OF <replaceable>nom_colonne_1</replaceable> [, <replaceable>nom_colonne_2</replaceable> ... ]
</synopsis>
      Le trigger se déclenchera seulement si au moins une des colonnes listées
      est mentionnée comme cible de la mise à jour.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">table</replaceable></term>
    <listitem>
     <para>
      Le nom (éventuellement qualifié du nom du schéma) de la table à laquelle
      est rattaché le déclencheur.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FOR EACH ROW</literal></term>
    <term><literal>FOR EACH STATEMENT</literal></term>

    <listitem>
     <para>
      Précise si la procédure du déclencheur doit être lancée 
      pour chaque ligne affectée par l'événement ou
      simplement pour chaque instruction SQL. <literal>FOR EACH STATEMENT</literal>
      est la valeur par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition</replaceable></term>
    <listitem>
     <para>
      Une expression booléenne qui détermine si la fonction trigger sera
      réellement exécutée. Si <literal>WHEN</literal> est indiqué, la fonction
      sera seulement appelée si la <replaceable
      class="parameter">condition</replaceable> renvoie <literal>true</literal>.
      Pour les triggers <literal>FOR EACH ROW</literal>, la condition
      <literal>WHEN</literal> peut faire référence aux valeurs des colonnes
      des ancienne et nouvelle lignes en utilisant la notation
      <literal>OLD.<replaceable
      class="parameter">nom_colonne</replaceable></literal> ou
      <literal>NEW.<replaceable
      class="parameter">nom_colonne</replaceable></literal>, respectivement.
      Bien sûr, le triggers sur <literal>INSERT</literal> ne peuvent pas
      faire référence à <literal>OLD</literal> et ceux sur
      <literal>DELETE</literal> ne peuvent pas faire référence à
      <literal>NEW</literal>.
     </para>

     <para>
      Actuellement, les expressions <literal>WHEN</literal> ne peuvent pas
      contenir de sous-requêtes.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_fonction</replaceable></term>
    <listitem>
     <para>
      Une fonction utilisateur, déclarée sans argument et renvoyant le type <literal>trigger</literal>, exécutée
      à l'activation du déclencheur.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">arguments</replaceable></term>
    <listitem>
     <para>
      Une liste optionnelle d'arguments séparés par des virgules à fournir à la
      fonction lors de l'activation du déclencheur. Les arguments sont des
      chaînes littérales constantes. Il est possible d'écrire ici de 
      simples noms et des constantes numériques mais ils sont tous convertis
      en chaîne. L'accès aux arguments du trigger depuis la fonction peut
      différer de l'accès aux arguments d'une fonction standard&nbsp;; la consultation
      des caractéristiques d'implantation du langage de la fonction peut alors s'avérer
      utile.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 id="sql-createtrigger-notes">
  <title>Notes</title>

  <para>
   Pour créer un déclencheur sur une table, l'utilisateur doit posséder le droit
   <literal>TRIGGER</literal> sur la table.
  </para>

  <para>
   Utiliser <xref linkend="sql-droptrigger"/>
   pour supprimer un déclencheur.
  </para>

  <para>
   Un trigger sur colonne spécifique (<literal>FOR UPDATE OF
   <replaceable>nom_colonne</replaceable></literal>) se déclenchera quand
   une des colonnes indiquées est listée comme cible de la liste
   <literal>SET</literal> pour la commande <command>UPDATE</command>. Il est
   possible qu'une valeur de colonne change même si le trigger n'est pas
   déclenché parceque les modifications au contenu de la ligne par les triggers
   <literal>BEFORE UPDATE</literal> ne sont pas pris en compte. De même, une
   commande comme <literal>UPDATE ... SET x = x ...</literal> déclenchera le
   trigger sur la colonne <literal>x</literal>, bien que la valeur de cette
   colonne ne changera pas.
  </para>

  <para>
   Dans un trigger <literal>BEFORE</literal>, la condition
   <literal>WHEN</literal> est évaluée juste avant l'exécution de la fonction,
   donc utiliser <literal>WHEN</literal> n'est pas matériellement différent
   de tester la même condition au début de la fonction trigger. Notez en
   particulier que la ligne <literal>NEW</literal> vu par la condition est sa
   valeur courante et possiblement modifiée par des triggers précédents. De
   plus, la condition <literal>WHEN</literal> d'un trigger
   <literal>BEFORE</literal> n'est pas autorisé à examiner les colonnes
   système de la ligne <literal>NEW</literal> (comme l'<literal>oid</literal>),
   car elles n'auront pas encore été initialisées.
  </para>

  <para>
   Dans un trigger <literal>AFTER</literal>, la condition
   <literal>WHEN</literal> est évaluée juste après la mise à jour de la ligne
   et elle détermine si un événement doit déclencher le trigger à la fin de
   l'instruction. Donc, quand la condition <literal>WHEN</literal> d'un
   trigger <literal>AFTER</literal> ne renvoie pas true, il n'est pas
   nécessaire de préparer un événement ou de relire la ligne à la fin de
   l'instruction. Cela peut apporter une amélioration significative des
   performances dans les instructions qui modifient de nombreuses lignes, si
   le trigger a besoin d'être déclencher pour quelques lignes.
  </para>

  <para>
   Dans les versions de <productname>PostgreSQL</productname> antérieures à la
   7.3, il était nécessaire de déclarer un type <type>opaque</type> de 
   retour pour les fonctions déclencheur, plutôt que <type>trigger</type>. Pour
   pouvoir charger d'anciens fichiers de sauvegarde,
   <command>CREATE TRIGGER</command> accepte qu'une fonction déclare une valeur de retour de type
   <type>opaque</type>, mais il affiche un message d'avertissement et change le
   type de retour déclaré en <type>trigger</type>.
  </para>
 </refsect1>

 <refsect1 id="r1-sql-createtrigger-examples">
  <title>Exemples</title>

  <para>
   Exécutez la fonction <function>check_account_update</function> quand une
   ligne de la table <literal>accounts</literal> est sur le point d'être mise
   à jour&nbsp;:

<programlisting>
CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    EXECUTE PROCEDURE check_account_update();
</programlisting>

   Idem, mais avec une exécution de la fonction seulement si la colonne
   <literal>balance</literal> est spécifiée comme cible de la commande
   <command>UPDATE</command>&nbsp;:

<programlisting>
CREATE TRIGGER check_update
    BEFORE UPDATE OF balance ON accounts
    FOR EACH ROW
    EXECUTE PROCEDURE check_account_update();
</programlisting>

   Cette forme exécute la fonction seulement si la colonne
   <literal>balance</literal> a réellement changé de valeur&nbsp;:

<programlisting>
CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.balance IS DISTINCT FROM NEW.balance)
    EXECUTE PROCEDURE check_account_update();
</programlisting>

   Appelle une fonction pour tracer les mises à jour de la table
   <literal>accounts</literal>, mais seulement si quelque chose a changé&nbsp;:

<programlisting>
CREATE TRIGGER log_update
    AFTER UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.* IS DISTINCT FROM NEW.*)
    EXECUTE PROCEDURE log_account_update();
</programlisting>
  </para>

  <para>
   <xref linkend="trigger-example"/> contient un exemple complet d'une
   fonction trigger écrit en C.
  </para>
 </refsect1>

 <refsect1 id="sql-createtrigger-compatibility">
  <title>Compatibilité</title>

  <para>
   L'instruction <command>CREATE TRIGGER</command> de
   <productname>PostgreSQL</productname> implante un sous-ensemble du standard
   <acronym>SQL</acronym>. Les fonctionnalités manquantes sont&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      SQL permet de définir des alias pour les lignes
      <quote>old</quote> et <quote>new</quote> ou pour les tables utilisée
      dans la définition des actions déclenchées (c'est-à-dire
      <literal>CREATE TRIGGER ... ON nomtable REFERENCING OLD ROW AS unnom NEW ROW AS unautrenom...</literal>).
      <productname>PostgreSQL</productname> autorise
      l'écriture de procédures de déclencheurs dans tout langage
      l'utilisateur. De ce fait, l'accès aux données est géré spécifiquement pour
      chaque langage.
     </para>
    </listitem>

    <listitem>
     <para>
      <productname>PostgreSQL</productname> n'autorise comme action déclenchée
      que l'exécution d'une fonction utilisateur. Le standard SQL, en revanche,
      autorise l'exécution d'autres commandes SQL, telles que
      <command>CREATE TABLE</command>. Cette limitation de <productname>PostgreSQL</productname>
      peut être facilement contournée par la création d'une fonction
      utilisateur qui exécute les commandes désirées.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Le standard SQL définit l'ordre de création comme ordre de lancement
   des déclencheurs multiples. <productname>PostgreSQL</productname> utilise
   l'ordre alphabétique de leur nom, jugé plus pratique.
  </para>

  <para>
   Le standard SQL précise que les déclencheurs <literal>BEFORE DELETE</literal> sur des
   suppressions en cascade se déclenchent <emphasis>après</emphasis> la fin du
   <literal>DELETE</literal> en cascade. 
   <productname>PostgreSQL</productname> définit que <literal>BEFORE DELETE</literal>
   se déclenche toujours avant l'action de suppression, même lors
   d'une action en cascade. Cela semble plus cohérent. Il existe aussi un
   comportement non prévisible quand les triggers <literal>BEFORE</literal>
   modifient les lignes ou empêchent les mises à jour causées par une action
   référente. Ceci peut amener à des violations de contraintes ou au stockage
   de données qui n'honorent pas la contrainte référentielle.
  </para>

  <para>
   La capacité à préciser plusieurs actions pour un seul déclencheur avec
   <literal>OR</literal> est une extension <productname>PostgreSQL</productname>.
  </para>

  <para>
   La possibilité d'exécuter un trigger suite à une commande
   <command>TRUNCATE</command> est une extension
   <productname>PostgreSQL</productname> du standard SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createfunction"/></member>
   <member><xref linkend="sql-altertrigger"/></member>
   <member><xref linkend="sql-droptrigger"/></member>
  </simplelist>
 </refsect1>
</refentry>
