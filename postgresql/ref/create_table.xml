<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060618 : Relecture -->

<refentry id="sql-createtable">
 <refmeta>
  <refentrytitle>CREATE TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TABLE</refname>
  <refpurpose>Définir une nouvelle table</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE <replaceable class="parameter">nom_table</replaceable> ( [
  { <replaceable class="parameter">nom_colonne</replaceable> <replaceable class="parameter">type_donnees</replaceable> [ DEFAULT <replaceable>default_expr</replaceable> ] [ <replaceable class="parameter">contrainte_colonne</replaceable> [ ... ] ]
    | <replaceable>contrainte_table</replaceable>
    | LIKE <replaceable>table_parent</replaceable> [ <replaceable>option_like</replaceable> ... ] }
    [, ... ]
] )
[ INHERITS ( <replaceable>table_parent</replaceable> [, ... ] ) ]
[ WITH ( <replaceable class="parameter">parametre_stockage</replaceable> [= <replaceable class="parameter">valeur</replaceable>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="parameter">tablespace</replaceable> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE <replaceable class="PARAMETER">nom_table</replaceable>
    OF <replaceable class="PARAMETER">nom_type</replaceable> [ (
  { <replaceable class="PARAMETER">nom_colonne</replaceable> WITH OPTIONS [ DEFAULT <replaceable>default_expr</replaceable> ] [ <replaceable class="PARAMETER">contrainte_colonne</replaceable> [ ... ] ]
    | <replaceable>contrainte_table</replaceable> }
    [, ... ]
) ]
[ WITH ( <replaceable class="PARAMETER">parametre_stockage</replaceable> [= <replaceable class="PARAMETER">valeur</replaceable>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="PARAMETER">tablespace</replaceable> ]

<phrase>où <replaceable class="parameter">contrainte_colonne</replaceable>
peut être&nbsp;:</phrase>

[ CONSTRAINT <replaceable class="parameter">nom_contrainte</replaceable> ]
{ NOT NULL | NULL |
  CHECK ( <replaceable class="PARAMETER">expression</replaceable> ) |
  UNIQUE <replaceable class="parameter">parametres_index</replaceable> |
  PRIMARY KEY <replaceable class="parameter">parametres_index</replaceable> |
  EXCLUDE [ USING <replaceable class="parameter">methode_index</replaceable> ] ( <replaceable class="parameter">élément_exclude</replaceable> WITH <replaceable class="parameter">opérateur</replaceable> [, ... ] ) <replaceable class="parameter">paramètres_index</replaceable> [ WHERE ( <replaceable class="parameter">prédicat</replaceable> ) ] |
  REFERENCES <replaceable class="parameter">table_reference</replaceable> [ ( <replaceable class="parameter">colonne_reference</replaceable> ) ] [ MATCH FULL
| MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>et <replaceable class="PARAMETER">option_like</replaceable> is:</phrase>

{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | INDEXES | STORAGE | COMMENTS | ALL }

<phrase>et <replaceable class="parameter">contrainte_table</replaceable>&nbsp;:</phrase>

[ CONSTRAINT <replaceable class="parameter">nom_contrainte</replaceable> ]
{ UNIQUE ( <replaceable class="parameter">nom_colonne</replaceable> [, ... ] ) <replaceable class="parameter">parametres_index</replaceable> |
  PRIMARY KEY ( <replaceable class="parameter">nom_colonne</replaceable> [, ... ] ) <replaceable class="parameter">parametres_index</replaceable> |
  CHECK ( <replaceable class="parameter">expression</replaceable> ) |
  FOREIGN KEY ( <replaceable class="parameter">nom_colonne</replaceable> [, ...
] ) REFERENCES <replaceable class="parameter">table_reference</replaceable> [ (
<replaceable class="parameter">colonne_reference</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

Les <replaceable class="parameter">paramètres_index</replaceable> dans les
contraintes <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal> et
<literal>EXCLUDE</literal> sont&nbsp;:

[ WITH ( <replaceable class="parameter">paramètre_stockage</replaceable> [= <replaceable class="parameter">valeur</replaceable>] [, ... ] ) ]
[ USING INDEX TABLESPACE <replaceable class="parameter">tablespace</replaceable> ]

<phrase><replaceable class="PARAMETER">exclude_element</replaceable> in an <literal>EXCLUDE</literal> constraint is:</phrase>

{ <replaceable class="parameter">column</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">opclass</replaceable> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]
</synopsis>

 </refsynopsisdiv>

 <refsect1 id="sql-createtable-description">
  <title>Description</title>
  <indexterm zone="sql-createtable">
   <primary>CREATE TABLE</primary>
  </indexterm>

  <para>
   <command>CREATE TABLE</command> crée une nouvelle table initialement vide
   dans la base de données courante. La table appartient à 
   l'utilisateur qui exécute cette commande.
  </para>

  <para>
   Si un nom de schéma est donné (par exemple, <literal>CREATE TABLE monschema.matable ...</literal>),
   alors la table est créée dans le schéma spécifié.
   Dans le cas contraire, elle est créée dans le schéma courant. Les tables temporaires existent
   dans un schéma spécial, il n'est donc pas nécessaire de fournir un nom de schéma 
   lors de la création d'une table temporaire. Le nom de la table doit être distinct
   du nom des autres tables, séquences, index ou vues dans le même schéma.
  </para>

  <para>
   <command>CREATE TABLE</command> crée aussi automatiquement un type de 
   données qui représente le type composé correspondant à une ligne de la
   table. Ainsi, les tables doivent avoir un nom distinct de tout type de
   données du même schéma.
  </para>

  <para>
   Les clauses de contrainte optionnelles spécifient les contraintes (ou 
   tests) que les nouvelles lignes ou les lignes mises à jour doivent satisfaire
   pour qu'une opération d'insertion ou de mise à jour réussisse. Une contrainte
   est un objet SQL qui aide à définir l'ensemble des valeurs valides de
   différentes façons.
  </para>

  <para>
   Il existe deux façons de définir des contraintes&nbsp;: celles
   de table et celles de colonnes. Une contrainte de colonne fait partie
   de la définition de la colonne. Une définition de contrainte
   de tables n'est pas liée à une colonne particulière et peut englober plusieurs
   colonnes. Chaque contrainte de colonne peut être écrite comme une
   contrainte de table&nbsp;; une contrainte de colonne n'est qu'un outil
   de notation utilisé lorsque la contrainte n'affecte qu'une colonne.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>

   <varlistentry>
    <term><literal>TEMPORARY</literal> ou <literal>TEMP</literal></term>
    <listitem>
     <para>
      La table est temporaire. Les tables
      temporaires sont automatiquement supprimées à la fin d'une session ou,
      optionnellement, à la fin de la transaction en cours (voir <command>ON COMMIT</command>
      ci-dessous). Les tables permanentes qui portent le même nom ne sont
      pas visibles dans la session courante tant que la table temporaire existe
      sauf s'il y est fait référence par leur nom qualifié du schéma. Tous les
      index créés sur une table temporaire sont automatiquement temporaires.
     </para>

     <para>
      The <link linkend="autovacuum">autovacuum daemon</link> cannot
      access and therefore cannot vacuum or analyze temporary tables.
      For this reason, appropriate vacuum and analyze operations should be
      performed via session SQL commands.  For example, if a temporary
      table is going to be used in complex queries, it is wise to run
      <command>ANALYZE</command> on the temporary table after it is populated.
     </para>

     <para>
      On peut éventuellement écrire <literal>GLOBAL</literal> ou <literal>LOCAL</literal>
      avant <literal>TEMPORARY</literal> ou <literal>TEMP</literal>. Cela
      ne fait pas de différence dans <productname>PostgreSQL</productname> (cf.
      <xref linkend="sql-createtable-compatibility"/>).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_table</replaceable></term>
    <listitem>
     <para>
      Le nom (éventuellement qualifié du nom du schéma) de la table à créer.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OF <replaceable class="PARAMETER">type_name</replaceable></literal></term>
    <listitem>
     <para>
      Creates a <firstterm>typed table</firstterm>, which takes its
      structure from the specified composite type (name optionally
      schema-qualified).  A typed table is tied to its type; for
      example the table will be dropped if the type is dropped
      (with <literal>DROP TYPE ... CASCADE</literal>).
     </para>

     <para>
      When a typed table is created, then the data types of the
      columns are determined by the underlying composite type and are
      not specified by the <literal>CREATE TABLE</literal> command.
      But the <literal>CREATE TABLE</literal> command can add defaults
      and constraints to the table and can specify storage parameters.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_colonne</replaceable></term>
    <listitem>
     <para>
      Le nom d'une colonne de la nouvelle table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_données</replaceable></term>
    <listitem>
     <para>
      Le type de données de la colonne. Cela peut inclure des
      spécificateurs de tableaux. Pour plus d'informations sur les types de
      données supportés par <productname>PostgreSQL</productname>, on se référera 
      à <xref linkend="datatype"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT
    <replaceable>default_expr</replaceable></literal></term>
    <listitem>
     <para>
      La clause <literal>DEFAULT</literal>, apparaissant dans la définition
      d'une colonne, permet de lui affecter une valeur par défaut. La valeur est une
      expression libre de variable (les sous-requêtes et références croisées aux
      autres colonnes de la table courante ne sont pas autorisées). Le type de
      données de l'expression par défaut doit correspondre au type de données de
      la colonne.
     </para>

     <para>
      L'expression par défaut est utilisée dans les opérations d'insertion 
      qui ne spécifient pas de valeur pour la colonne. S'il n'y a pas de valeur
      par défaut pour une colonne, elle est NULL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERITS ( <replaceable>table_parent</replaceable> [, ... ])</literal></term>
    <listitem>
     <para>
      La clause optionnelle <literal>INHERITS</literal> spécifie une liste de tables
      dont les colonnes sont automatiquement héritées par la nouvelle table.
     </para>

     <para>
      L'utilisation d'<literal>INHERITS</literal> crée une relation persistante entre
      la nouvelle table enfant et sa table parent. Les modifications de schéma
      du(des) parent(s) se propagent normalement aux enfants et, par défaut,
      les données de la table enfant sont incluses dans les parcours de(s)
      parent(s).
     </para>

     <para>
      Si un même nom de colonne existe dans plusieurs tables parentes,
      une erreur est rapportée, à moins que les types de données des colonnes
      ne correspondent dans toutes les tables parentes. S'il n'y a pas de conflit,
      alors les colonnes dupliquées sont assemblées pour former une seule
      colonne dans la nouvelle table. Si la liste des noms de colonnes de la
      nouvelle table contient un nom de colonne hérité, le type
      de données doit correspondre à celui des colonnes héritées et les définitions des
      colonnes sont fusionnées. Si la nouvelle table spécifie explicitement une valeur par défaut
      pour la colonne, cette valeur surcharge toute valeur par défaut héritée.
      Dans le cas contraire, les parents qui spécifient une valeur par défaut doivent
      tous spécifier la même, sans quoi une erreur est rapportée.
     </para>

     <para>
      Les contraintes <literal>CHECK</literal> sont fusionnées, dans les grandes lignes,
      de la même façon que les colonnes&nbsp;: si des tables parentes multiples et/ou la nouvelle
      définition de table contient des contraintes <literal>CHECK</literal> de même nom,
      ces contraintes doivent toutes avoir la même expression de vérification, ou
      une erreur sera retournée. Les contraintes qui ont le même nom et la même expression
      seront fusionnées en une seule. Notez qu'une contrainte <literal>CHECK</literal>
      non nommée dans la nouvelle table ne sera jamais fusionnée puisqu'un
      nom unique lui sera toujours affecté.
     </para>
     
     <para>
      Column <literal>STORAGE</literal> settings are also copied from parent tables.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
     <term><literal>LIKE <replaceable>table_parent</replaceable> [ <replaceable>option_like</replaceable> ... ]</literal></term>
     <listitem>
       <para>
         La clause <literal>LIKE</literal> spécifie une table à partir de laquelle
         la nouvelle table copie automatiquement tous les noms de colonnes, leur
         types de données et les contraintes non NULL.
       </para>
       <para>
         Contrairement à <literal>INHERITS</literal>, la nouvelle table et la
         table originale sont complètement découplées à la fin de la création.
         Les modifications sur la table originale ne sont pas appliquées à la
	 nouvelle table et les données de la
	 nouvelle table sont pas prises en compte lors du parcours de l'ancienne table.
       </para>
       <para>
         Les expressions par défaut des définitions de colonnes
         ne seront copiées que si <literal>INCLUDING DEFAULTS</literal> est
         spécifié. Le comportement par défaut les exclut, ce qui conduit à
	 des valeurs par défaut NULL pour les colonnes copiées de la nouvelle table.
       </para>
     <para>
      Les contraintes NOT NULL sont toujours copiées sur la nouvelle table.
      Les contraintes <literal>CHECK</literal> seront seulement copiées si
      <literal>INCLUDING CONSTRAINTS</literal> est indiqué&nbsp;; les autres
      types de contraintes ne sont jamais copiées. De plus, aucune
      distinction n'est faite entre les contraintes de colonnes et les
      contraintes de tables &mdash; quand les contraintes sont demandées,
      toutes les contraintes de vérification sont copiées.
     </para>
     <para>
      Tout index sur la table originale ne sera pas créé sur la nouvelle table
      sauf si la clause <literal>INCLUDING INDEXES</literal> est précisée.
     </para>
     <para>
      <literal>STORAGE</literal> settings for the copied column definitions will only
      be copied if <literal>INCLUDING STORAGE</literal> is specified.  The
      default behavior is to exclude <literal>STORAGE</literal> settings, resulting
      in the copied columns in the new table having type-specific default
      settings.  For more on <literal>STORAGE</literal> settings, see
      <xref linkend="storage-toast"/>.
     </para>
     <para>
      Comments for the copied columns, constraints, and indexes
      will only be copied if <literal>INCLUDING COMMENTS</literal>
      is specified. The default behavior is to exclude comments, resulting in
      the copied columns and constraints in the new table having no comments.
     </para>
     <para>
      <literal>INCLUDING ALL</literal> is an abbreviated form of
      <literal>INCLUDING DEFAULTS INCLUDING CONSTRAINTS INCLUDING INDEXES INCLUDING STORAGE INCLUDING COMMENTS</literal>.
     </para>
     <para>
      Note also that unlike <literal>INHERITS</literal>, columns and
      constraints copied by <literal>LIKE</literal> are not merged with similarly
      named columns and constraints. Si le même nom est indiqué
      explicitement ou dans une autre clause <literal>LIKE</literal>, une erreur
      est rapportée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CONSTRAINT <replaceable class="parameter">nom_contrainte</replaceable></literal></term>
    <listitem>
     <para>
      Le nom optionnel d'une contrainte de colonne ou de table. Si la contrainte
      est violée, le nom de la contrainte est présente dans les messages d'erreur.
      Donc les noms de contraintes comme <literal>col doit être positive</literal>
      peut être utilisés pour communiquer des informations utiles aux applications
      clients. (Des doubles guillemets sont nécessaires pour indiquer les noms des
      contraintes qui contiennent des espaces.) Si un nom de contrainte n'est pas
      donné, le système en génère un.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOT NULL</literal></term>
    <listitem>
     <para>
      Interdiction des valeurs NULL dans la colonne.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NULL</literal></term>
    <listitem>
     <para>
      Les valeurs NULL sont autorisées pour la colonne. Comportement par défaut.
     </para>

     <para>
      Cette clause n'est fournie que pour des raisons de compatibilité avec les
      bases de données SQL non standard. Son utilisation n'est pas encouragée
      dans les nouvelles applications.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CHECK ( <replaceable class="parameter">expression</replaceable> )</literal></term>
    <listitem>
     <para>
      La clause <literal>CHECK</literal> spécifie une expression de
      résultat booléen que les nouvelles lignes ou celles mises à jour
      doivent satisfaire pour qu'une opération d'insertion ou de mise à jour
      réussisse. Les expressions de résultat TRUE ou UNKNOWN réussissent. 
      Si une des lignes de l'opération d'insertion ou de mise à jour produit un résultat
      FALSE, une exception est levée et la base de données n'est pas modifiée. 
      Une contrainte de vérification sur une colonne ne fait référence qu'à la valeur de la colonne
      tandis qu'une contrainte sur la table fait référence à plusieurs colonnes.
     </para>

     <para>
      Actuellement, les expressions <literal>CHECK</literal> ne peuvent ni
      contenir des sous-requêtes ni faire référence à des variables autres que les
      colonnes de la ligne courante.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>UNIQUE</literal> (column constraint)</term>
    <term><literal>UNIQUE ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] )</literal> (table constraint)</term>

    <listitem>
     <para>
      The <literal>UNIQUE</literal> constraint specifies that a
      group of one or more columns of a table can contain
      only unique values. The behavior of the unique table constraint
      is the same as that for column constraints, with the additional
      capability to span multiple columns.
     </para>

     <para>
      For the purpose of a unique constraint, null values are not
      considered equal.
     </para>

     <para>
      Each unique table constraint must name a set of columns that is
      different from the set of columns named by any other unique or
      primary key constraint defined for the table.  (Otherwise it
      would just be the same constraint listed twice.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PRIMARY KEY</literal> (column constraint)</term>
    <term><literal>PRIMARY KEY ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] )</literal> (table constraint)</term>
    <listitem>
     <para>
      The primary key constraint specifies that a column or columns of a table
      can contain only unique (non-duplicate), nonnull values.
      Technically, <literal>PRIMARY KEY</literal> is merely a
      combination of <literal>UNIQUE</literal> and <literal>NOT NULL</literal>, but
      identifying a set of columns as primary key also provides
      metadata about the design of the schema, as a primary key
      implies that other tables
      can rely on this set of columns as a unique identifier for rows.
     </para>

     <para>
      Only one primary key can be specified for a table, whether as a
      column constraint or a table constraint.
     </para>

     <para>
      The primary key constraint should name a set of columns that is
      different from other sets of columns named by any unique
      constraint defined for the same table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="SQL-CREATETABLE-EXCLUDE">
    <term><literal>EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ]</literal></term>
    <listitem>
     <para>
      The <literal>EXCLUDE</literal> clause defines an exclusion
      constraint, which guarantees that if
      any two rows are compared on the specified column(s) or
      expression(s) using the specified operator(s), not all of these
      comparisons will return <literal>TRUE</literal>.  If all of the
      specified operators test for equality, this is equivalent to a
      <literal>UNIQUE</literal> constraint, although an ordinary unique constraint
      will be faster.  However, exclusion constraints can specify
      constraints that are more general than simple equality.
      For example, you can specify a constraint that
      no two rows in the table contain overlapping circles
      (see <xref linkend="datatype-geometric"/>) by using the
      <literal>&amp;&amp;</literal> operator.
     </para>

     <para>
      Exclusion constraints are implemented using
      an index, so each specified operator must be associated with an
      appropriate operator class
      (see <xref linkend="indexes-opclass"/>) for the index access
      method <replaceable>index_method</replaceable>.
      The operators are required to be commutative.
      Each <replaceable class="parameter">exclude_element</replaceable>
      can optionally specify an operator class and/or ordering options;
      these are described fully under
      <xref linkend="sql-createindex"/>.
     </para>

     <para>
      The access method must support <literal>amgettuple</literal> (see <xref
      linkend="indexam"/>); at present this means <acronym>GIN</acronym>
      cannot be used.  Although it's allowed, there is little point in using
      btree or hash indexes with an exclusion constraint, because this
      does nothing that an ordinary unique constraint doesn't do better.
      So in practice the access method will always be <acronym>GiST</acronym>.
     </para>

     <para>
      The <replaceable class="parameter">predicate</replaceable> allows you to specify an
      exclusion constraint on a subset of the table; internally this creates a
      partial index. Note that parentheses are required around the predicate.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>REFERENCES <replaceable class="parameter">table_reference</replaceable> [ ( <replaceable class="parameter">colonne_reference</replaceable> ) ] 
     [ MATCH <replaceable class="parameter">matchtype</replaceable> ]
     [ ON DELETE <replaceable class="parameter">action</replaceable> ]
     [ ON UPDATE <replaceable class="parameter">action</replaceable> ]</literal> (contrainte de colonne)</term>

   <term><literal>FOREIGN KEY ( <replaceable
class="parameter">colonne</replaceable> [, ... ] )
    REFERENCES <replaceable class="parameter">table_reference</replaceable> [ (
<replaceable class="parameter">colonne_reference</replaceable> [, ... ] ) ] 
    [ MATCH <replaceable class="parameter">matchtype</replaceable> ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ] 
    [ ON UPDATE <replaceable class="parameter">action</replaceable> ]</literal>
    (contrainte de colonne)</term>

    <listitem>
     <para>
      Ces clauses spécifient une contrainte de clé étrangère. Cela signifie
      qu'un groupe de colonnes de la nouvelle table ne peut contenir que 
      des valeurs correspondant à celles des colonnes de référence de la table
      de référence. Si
      <replaceable class="parameter">colonne_reference</replaceable> est omis,
      la clé primaire de la <replaceable class="parameter">table_reference</replaceable>
      est utilisée. Les colonnes
      référencées doivent être celles d'une contrainte d'unicité ou de clé
      primaire, non déferrable, dans la table référencée. Les contraintes de type clé
      étrangère ne peuvent pas être définies entre des tables temporaires et des
      tables permanentes.
     </para>

     <para>
      Une valeur insérée dans les colonnes de la nouvelle table est comparée aux valeurs
      des colonnes de référence dans la table de référence à l'aide du type de concordance
      fourni. Il existe trois types de correspondance&nbsp;:
      <literal>MATCH FULL</literal> (NDT&nbsp;: correspondance totale),
      <literal>MATCH PARTIAL</literal> (NDT&nbsp;: correspondance partielle) et
      <literal>MATCH SIMPLE</literal> (NDT&nbsp;: correspondance simple), qui est aussi la valeur par défaut.
      <literal>MATCH FULL</literal> n'autorise une colonne d'une clé étrangère composite à être NULL
      que si l'ensemble des colonnes de la clé étrangère sont NULL.
      <literal>MATCH SIMPLE</literal> autorise une colonne de clé étrangère
      à être NULL même si les autres parties de la clé étrangère ne sont pas nulles.
      <literal>MATCH PARTIAL</literal> n'est pas encore implanté.
     </para>

     <para>
      Lorsque les données des colonnes référencées sont modifiées,
      des actions sont réalisées sur les données de la table référençant.
      La clause <literal>ON DELETE</literal> spécifie l'action à
      réaliser lorsqu'une ligne référencée de la table de référence est supprimée.
      De la même façon, la clause <literal>ON UPDATE</literal>
      spécifie l'action à réaliser lorsqu'une colonne référencée est mise à jour.
      Si la ligne est mise à jour sans que la valeur de la colonne référencée ne soit
      modifiée, aucune action n'est réalisée. Les actions référentielles autres
      que la vérification <literal>NO ACTION</literal> ne peuvent
      pas être différées même si la contrainte est déclarée retardable.
      Les actions suivantes sont possibles pour chaque clause&nbsp;:

      <variablelist>
       <varlistentry>
        <term><literal>NO ACTION</literal></term>
        <listitem>
         <para>
	  Une erreur est produite pour indiquer que la suppression ou la mise à jour 
	  entraîne une violation de la contrainte de clé étrangère. Si la
	  contrainte est différée, cette erreur est produite au moment
	  de la vérification, si toutefois il existe encore des lignes
	  de référence. C'est le comportement par défaut.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>RESTRICT</literal></term>
        <listitem>
         <para>
	  Une erreur est produite pour indiquer que la suppression ou la mise à jour
	  entraîne une violation de la contrainte de clé étrangère. Ce comportement
	  est identique à <literal>NO ACTION</literal>, si ce n'est que la vérification
	  n'est pas décalable dans le temps.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>CASCADE</literal></term>
        <listitem>
         <para>
	  La mise à jour ou la suppression de la ligne de référence est propagée
	  à l'ensemble des lignes qui la référencent, qui sont, respectivement,
	  mises à jour ou supprimées.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET NULL</literal></term>
        <listitem>
         <para>
          La valeur de la colonne qui référence est positionnée à NULL.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET DEFAULT</literal></term>
        <listitem>
         <para>
	  La valeur de la colonne qui référence est positionnée à 
	  celle par défaut.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>

     <para>
      Si les colonnes référencées sont modifiées fréquemment, il est 
      conseillé d'ajouter un index sur la colonne de clé étrangère de façon à
      accélérer les actions référentielles associées à la colonne de clé étrangère.
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
    <term><literal>DEFERRABLE</literal></term>
    <term><literal>NOT DEFERRABLE</literal></term>
    <listitem>
     <para>
      Ces clauses contrôlent la possibilité de différer la contrainte. Une contrainte qui
      n'est pas décalable dans le temps est vérifiée immédiatement après chaque commande. La
      vérification des contraintes décalables est repoussée à la
      fin de la transaction (à l'aide de la commande
      <xref linkend="sql-set-constraints"/>).
      <literal>NOT DEFERRABLE</literal> est la valeur par défaut.
      Currently, only <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>,
      <literal>EXCLUDE</literal>, and
      <literal>REFERENCES</literal> (foreign key) constraints accept this
      clause.  <literal>NOT NULL</literal> and <literal>CHECK</literal> constraints are not
      deferrable.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INITIALLY IMMEDIATE</literal></term>
    <term><literal>INITIALLY DEFERRED</literal></term>
    <listitem>
     <para>
      Si une contrainte est décalable dans le temps, cette clause précise le
      moment de la vérification. Si la contrainte est
      <literal>INITIALLY IMMEDIATE</literal>, elle est vérifiée après chaque
      instruction. Si la contrainte est <literal>INITIALLY DEFERRED</literal>,
      elle n'est vérifiée qu'à la fin de la transaction. Le moment de
      vérification de la contrainte peut être modifié avec la commande <xref
      linkend="sql-set-constraints"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH ( <replaceable class="parameter">paramètre_stockage</replaceable> [= <replaceable class="parameter">valeur</replaceable>] [, ... ] )</literal></term>
    <listitem>
     <para>
      Cette clause spécifie les paramètres de stockage optionnels pour une
      table ou un index&nbsp;; voir <xref linkend="sql-createtable-storage-parameters"
     /> pour plus
      d'informations. La clause <literal>WITH</literal> peut aussi inclure pour
      une table <literal>OIDS=TRUE</literal> (ou simplement <literal>OIDS</literal>)
      pour indiquer que les lignes de la nouvelle table doivent se voir affecter
      des OID (identifiants d'objets) ou <literal>OIDS=FALSE</literal> pour
      indiquer que les lignes ne doivent pas avoir d'OID. Si <literal>OIDS</literal>
      n'est pas indiqué, la valeur par défaut dépend du paramètre de configuration
      <xref linkend="guc-default-with-oids"/>. (Si la nouvelle table hérite d'une
      table qui a des OID, alors<literal>OIDS=TRUE</literal> est forcé même si la
      commande précise <literal>OIDS=FALSE</literal>.)
     </para>

     <para>
      Si <literal>OIDS=FALSE</literal> est indiqué ou implicite, la nouvelle
      table ne stocke pas les OID et aucun OID n'est affecté pour une ligne
      insérée dans cette table. Ceci est généralement bien considéré car
      cela réduit la consommation des OID et retarde du coup le retour à
      zéro du compteur sur 32 bits. Une fois que le compteur est revenu
      à zéro, les OID ne sont plus considérés uniques ce qui les rend
      beaucoup moins utiles. De plus, exclure les OID d'une table réduit
      l'espace requis pour stocker la table sur le disque de quatre octets
      par ligne (la plupart des machines), améliorant légèrement les
      performances.
     </para>

     <para>
      Pour supprimer les OID d'une table une fois qu'elle est créée, utilisez
      <xref linkend="sql-altertable"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH OIDS</literal></term>
    <term><literal>WITHOUT OIDS</literal></term>
    <listitem>
     <para>
      Ce sont les syntaxes obsolètes mais équivalentes, respectivement de
      <literal>WITH (OIDS)</literal> et <literal>WITH (OIDS=FALSE)</literal>. Si
      vous souhaitez indiquer à la fois l'option <literal>OIDS</literal> et les
      paramètres de stockage, vous devez utiliser la syntaxe
      <literal>WITH ( ... )</literal>&nbsp;; voir ci-dessus.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ON COMMIT</literal></term>
    <listitem>
     <para>
      Le comportement des tables temporaires à la fin d'un bloc de transactions
      est contrôlé à l'aide de la clause <literal>ON COMMIT</literal>. Les trois
      options sont&nbsp;:

      <variablelist>
       <varlistentry>
        <term><literal>PRESERVE ROWS</literal></term>
        <listitem>
         <para>
	  Aucune action n'est entreprise à la fin des transactions. Comportement par défaut.
         </para>
     	</listitem>
       </varlistentry>
           
       <varlistentry>
        <term><literal>DELETE ROWS</literal></term>
        <listitem>
         <para>
          Toutes les lignes de la table temporaire sont détruites à la
	  fin de chaque bloc de transactions. En fait, un <xref
          linkend="sql-truncate"/>
	  automatique est réalisé à chaque validation.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DROP</literal></term>
        <listitem>
         <para>
          La table temporaire est supprimée à la fin du bloc de transactions.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
     <term><literal>TABLESPACE <replaceable class="parameter">tablespace</replaceable></literal></term>
     <listitem>
       <para>
         <replaceable class="parameter">tablespace</replaceable> est le
	 nom du tablespace dans lequel est créée la nouvelle table. S'il
	 n'est pas spécifié, <xref linkend="guc-default-tablespace"/> est consulté, sauf
      si la table est temporaire auquel cas <xref linkend="guc-temp-tablespaces"/>
      est utilisé.

       </para>
     </listitem>
   </varlistentry>

   <varlistentry>
     <term><literal>USING INDEX TABLESPACE <replaceable class="parameter">tablespace</replaceable></literal></term>
     <listitem>
       <para>
        Les index associés à une contrainte <literal>UNIQUE</literal>,
	    <literal>PRIMARY KEY</literal>, or <literal>EXCLUDE</literal> sont créés dans le tablespace 
	nommé <replaceable class="parameter">tablespace</replaceable>.
	S'il n'est pas spécifié, <xref linkend="guc-default-tablespace"/> est consulté, sauf
      si la table est temporaire auquel cas <xref linkend="guc-temp-tablespaces"/>
      est utilisé.

       </para>
     </listitem>
   </varlistentry>
  </variablelist>

  <refsect2 id="sql-createtable-storage-parameters">
   <title id="sql-createtable-storage-parameters-title">Paramètres de stockage</title>

 <indexterm zone="sql-createtable-storage-parameters">
  <primary>paramètres de stockage</primary>
 </indexterm>

   <para>
    La clause <literal>WITH</literal> spécifie des <firstterm>paramètres de
    stockage</firstterm> pour les tables ainsi que pour les index associés
    avec une contrainte <literal>UNIQUE</literal>, <literal>PRIMARY
    KEY</literal>, or <literal>EXCLUDE</literal>. Les paramètres de stockage des index sont documentés dans
    <xref linkend="sql-createindex"/>. 
    Les paramètres de stockage actuellement disponibles pour les tables sont
    listés ci-dessous. Pour chaque paramètre, sauf contre-indication, il y a un
    paramètre additionnel, de même nom mais préfixé par
    <literal>toast.</literal>, qui peut être utilisé pour contrôler le
    le comportement de la table <acronym>TOAST</acronym> (stockage
    supplémentaire), si elle existe (voir <xref linkend="storage-toast"/> pour
    plus d'informations sur TOAST). Notez que la table TOAST hérite ses valeurs
    <literal>autovacuum</literal> de sa table parente s'il n'y a pas de paramètre
    <literal>toast.autovacuum_*</literal> positionné.
   </para>

   <variablelist>

   <varlistentry>
    <term><literal>fillfactor</literal> (<type>integer</type>)</term>
    <listitem>
     <para>
      Le facteur de remplissage d'une table est un pourcentage entre 10 et 100.
      100 (paquet complet) est la valeur par défaut. Quand un facteur de remplissage
      plus petit est indiqué, les opérations <command>INSERT</command> remplissent
      les pages de table d'au maximum ce pourcentage&nbsp;; l'espace restant sur
      chaque page est réservé à la mise à jour des lignes sur cette page. Cela
      donne à <command>UPDATE</command> une chance de placer la copie d'une ligne
      mise à jour sur la même page que l'original, ce qui est plus efficace que de
      la placer sur une page différente. Pour une table dont les entrées ne sont
      jamais mises à jour, la valeur par défaut est le meilleur choix, mais pour
      des tables mises à jour fréquemment, des facteurs de remplissage plus petits
      sont mieux appropriés. Ce paramètre n'est pas disponible pour la table
      TOAST.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_enabled</literal>,
      <literal>toast.autovacuum_enabled</literal> (<type>boolean</type>)</term>
    <listitem>
     <para>
     Active ou désactive le processus d'autovacuum sur une table particulière.
     Si à true, le processus d'autovacuum démarrera une opération <command>VACUUM</command>
     sur une table particulière quand le nombre d'enregistrements mis à jour ou supprimés
     dépassera <literal>autovacuum_vacuum_threshold</literal> plus 
     <literal>autovacuum_vacuum_scale_factor</literal> multiplié par le nombre
     d'enregistrements estimés actifs dans la relation.
     De façon similaire, il démarrera une opération <command>ANALYZE</command> quand
     le nombre d'enregistrements insérés, mis à jour ou supprimés dépassera
     <literal>autovacuum_analyze_threshold</literal> plus 
     <literal>autovacuum_analyze_scale_factor</literal> multiplié par le nombre
     d'enregistrements estimés actifs dans la relation.
     Si à false, la table ne sera pas traitée par autovacuum, sauf pour prévenir
     le bouclage des identifiants de transaction. Voir <xref linkend="vacuum-for-wraparound"/>
     pour plus d'information sur la prévention de ce bouclage.
     Notez que cette variable hérite sa valeur du paramètre <xref
     linkend="guc-autovacuum"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_vacuum_threshold</literal>,
      <literal>toast.autovacuum_vacuum_threshold</literal> (<type>integer</type>)</term>
    <listitem>
     <para>
     Nombre minimum d'enregistrements mis à jour ou supprimés avant
     de démarrer une opération <command>VACUUM</command> sur une table
     particulière.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_vacuum_scale_factor</literal>,
     <literal>toast.autovacuum_vacuum_scale_factor</literal> (<type>float4</type>)</term>
    <listitem>
     <para>
     Coefficient multiplicateur pour <structfield>reltuples</structfield> (nombre estimé 
     d'enregistrements d'une relation) à ajouter à <literal>autovacuum_vacuum_threshold</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_analyze_threshold</literal>,
     <literal>toast.autovacuum_analyze_threshold</literal> (<type>integer</type>)</term>
    <listitem>
     <para>
     Nombre minimum d'enregistrements insérés, mis à jour ou supprimés avant de
     démarrer une opération <command>ANALYZE</command> sur une table particulière.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_analyze_scale_factor</literal>,
     <literal>toast.autovacuum_analyze_scale_factor</literal> (<type>float4</type>)</term>
    <listitem>
     <para>
     Coefficient multiplicateur pour <structfield>reltuples</structfield> (nombre estimé 
     d'enregistrements d'une relation) à ajouter à <literal>autovacuum_analyze_threshold</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_vacuum_cost_delay</literal>,
     <literal>toast.autovacuum_vacuum_cost_delay</literal> (<type>integer</type>)</term>
    <listitem>
     <para>
     Paramètre <xref linkend="guc-autovacuum-vacuum-cost-delay"/> personnalisé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_vacuum_cost_limit</literal>,
     <literal>toast.autovacuum_vacuum_cost_limit</literal> (<type>integer</type>)</term>
    <listitem>
     <para>
     Paramètre <xref linkend="guc-autovacuum-vacuum-cost-limit"/> personnalisé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_freeze_min_age</literal>,
     <literal>toast.autovacuum_freeze_min_age</literal> (<type>integer</type>)</term>
    <listitem>
     <para>
     Paramètre <xref linkend="guc-vacuum-freeze-min-age"/> personnalisé. Notez que
     autovacuum rejettera les tentatives de positionner un
     <literal>autovacuum_freeze_min_age</literal> plus grand que le paramètre
     <xref linkend="guc-autovacuum-freeze-max-age"/> à la moitié de la plage système
     d'identifiants.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_freeze_max_age</literal>,
     <literal>toast.autovacuum_freeze_max_age</literal> (<type>integer</type>)</term>
    <listitem>
     <para>
     Paramètre <xref linkend="guc-autovacuum-freeze-max-age"/> personnalisé. Notez que
     autovacuum rejettera les tentatives de positionner un
     <literal>autovacuum_freeze_max_age</literal> plus grand que le paramètre système
     (il ne peut être que plus petit). Notez que même si vous pouvez positionner
     <literal>autovacuum_freeze_max_age</literal> à de très petites valeurs, voire zéro,
     c'est habituellement déconseillé parce que cela forcera des opérations VACUUM très
     fréquentes.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_freeze_table_age</literal>,
     <literal>toast.autovacuum_freeze_table_age</literal> (<type>integer</type>)</term>
    <listitem>
     <para>
      Paramètre <xref linkend="guc-vacuum-freeze-table-age"/> personnalisé.
     </para>
    </listitem>
   </varlistentry>
   </variablelist>

  </refsect2>
 </refsect1>

 <refsect1 id="sql-createtable-notes">
  <title>Notes</title>

    <para>
     Utiliser les OID dans les nouvelles applications n'est pas recommandé&nbsp;:
     dans la mesure du possible, un type <literal>SERIAL</literal> ou un autre
     générateur de séquence sera utilisé comme clé primaire de la table.
     Néanmoins, si l'application utilise les OID pour identifier des
     lignes spécifiques d'une table, il est recommandé de créer une contrainte
     unique sur la colonne <structfield>oid</structfield> de cette table afin de s'assurer
     que les OID de la table identifient les lignes de façon réellement unique
     même si le compteur est réinitialisé. Il n'est pas garanti que les OID soient
     uniques sur l'ensemble des tables. Dans le cas où un identifiant unique sur 
     l'ensemble de la base de données est nécessaire, on utilise préférentiellement une combinaison de
     <structfield>tableoid</structfield> et de l'OID de la ligne.
    </para>

    <tip>
     <para>
      L'utilisation de <literal>OIDS=FALSE</literal> est déconseillée
      pour les tables dépourvues de clé primaire. En effet, sans OID ou clé de
      données unique, il est difficile d'identifier des lignes spécifiques.
     </para>
    </tip>

    <para>
     <productname>PostgreSQL</productname> crée automatiquement un index pour
     chaque contrainte d'unicité ou clé primaire afin d'assurer l'unicité.
     Il n'est donc pas nécessaire de créer un index
     spécifiqueme pour les colonnes de clés primaires. Voir <xref
     linkend="sql-createindex"/> pour plus
     d'informations.
    </para>

    <para>
     Les contraintes d'unicité et les clés primaires ne sont pas héritées dans
     l'implantation actuelle. Cela diminue la fonctionnalité des combinaisons d'héritage
     et de contraintes d'unicité.
    </para>

    <para>
     Une table ne peut pas avoir plus de 1600 colonnes (en pratique, la limite
     réelle est habituellement plus basse du fait de contraintes sur la longueur
     des lignes).
    </para>

 </refsect1>


 <refsect1 id="sql-createtable-examples">
  <title>Exemples</title>

  <para>
   Créer une table <structname>films</structname> et une table
   <structname>distributeurs</structname>&nbsp;:

<programlisting>CREATE TABLE films (
    code        char(5) CONSTRAINT premierecle PRIMARY KEY,
    titre       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    genre       varchar(10),
    duree       interval hour to minute
);
</programlisting>

<programlisting>CREATE TABLE distributeurs (
     did    integer PRIMARY KEY DEFAULT nextval('serial'),
     nom    varchar(40) NOT NULL CHECK (nom &lt;&gt; '')
);
</programlisting>
  </para>

  <para>
   Créer une table contenant un tableau à deux dimensions&nbsp;:

<programlisting>CREATE TABLE array_int (
    vecteur  int[][]
);
</programlisting>
  </para>

  <para>
   Définir une contrainte d'unicité pour la table
   <literal>films</literal>. Les contraintes d'unicité de table peuvent être
   définies sur une ou plusieurs colonnes de la table&nbsp;:

<programlisting>CREATE TABLE films (
    code        char(5),
    titre       varchar(40),
    did         integer,
    date_prod   date,
    genre       varchar(10),
    duree       interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);
</programlisting>
  </para>
  
  <para>
   Définir une contrainte de vérification sur une colonne&nbsp;:

<programlisting>CREATE TABLE distributeurs (
    did     integer CHECK (did &gt; 100),
    nom    varchar(40)
);
</programlisting>
  </para>

  <para>
   Définir une contrainte de vérification sur la table&nbsp;:

<programlisting>CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40)
    CONSTRAINT con1 CHECK (did &gt; 100 AND nom &lt;&gt; '')
);
</programlisting>
  </para>
 
  <para>
   Définir une contrainte de clé primaire sur la table <structname>films</structname>.

<programlisting>CREATE TABLE films (
    code        char(5),
    titre       varchar(40),
    did         integer,
    date_prod   date,
    genre       varchar(10),
    duree       interval hour to minute,
    CONSTRAINT code_titre PRIMARY KEY(code,titre)
);
</programlisting>
  </para>

  <para>
   Définir une contrainte de clé primaire pour la table
   <structname>distributeurs</structname>. Les deux exemples suivants sont équivalents,
   le premier utilise la syntaxe de contrainte de table, le second la
   syntaxe de contrainte de colonne&nbsp;:

<programlisting>CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40),
    PRIMARY KEY(did)
); 
</programlisting>

<programlisting>CREATE TABLE distributeurs (
    did     integer PRIMARY KEY,
    nom     varchar(40)
);
</programlisting>
  </para>

  <para>
   Affecter une valeur par défaut à la colonne <literal>nom</literal>,
   une valeur par défaut à la colonne <literal>did</literal>,
   engendrée à l'aide d'une séquence, et une valeur par défaut à
   la colonne <literal>modtime</literal>, équivalente au moment où la ligne
   est insérée&nbsp;:

<programlisting>CREATE TABLE distributeurs (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributeurs_serial'),
    modtime   timestamp DEFAULT current_timestamp
);
</programlisting>
  </para>

  <para>
   Définir deux contraintes de colonnes <literal>NOT NULL</literal> sur la table
   <classname>distributeurs</classname>, dont l'une est explicitement nommée&nbsp;:

<programlisting>CREATE TABLE distributeurs (
    did     integer CONSTRAINT no_null NOT NULL,
    nom     varchar(40) NOT NULL
);
</programlisting>
    </para>

    <para>
     Définir une contrainte d'unicité sur la colonne <literal>nom</literal>&nbsp;:

<programlisting>CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40) UNIQUE
);
</programlisting>

     La même chose en utilisant une contrainte de table&nbsp;:

<programlisting>CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40),
    UNIQUE(nom)
);
</programlisting>
  </para>

  <para>
   Créer la même table en spécifiant un facteur de remplissage de 70% pour la
   table et les index uniques&nbsp;:

<programlisting>
CREATE TABLE distributeurs (
    did     integer,
    nom     varchar(40),
    UNIQUE(nom) WITH (fillfactor=70)
)
WITH (fillfactor=70);
</programlisting>
  </para>

  <para>
   Create table <structname>circles</structname> with an exclusion
   constraint that prevents any two circles from overlapping:

<programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
  </para>

    <para>
     Créer une table <structname>cinemas</structname> dans le tablespace
     <structname>diskvol1</structname>&nbsp;:

<programlisting>CREATE TABLE cinemas (
    id serial,
    nom text,
    emplacement text
) TABLESPACE diskvol1;
</programlisting>
  </para>

  <para>
   Create a composite type and a typed table:
<programlisting>
CREATE TYPE employee_type AS (name text, salary numeric);

CREATE TABLE employees OF employee_type (
    PRIMARY KEY (name),
    salary WITH OPTIONS DEFAULT 1000
);
</programlisting>
  </para>
 </refsect1>
 
 <refsect1 id="sql-createtable-compatibility">
  <title id="sql-createtable-compatibility-title">Compatibilité</title>

  <para>
   La commande <command>CREATE TABLE</command> est conforme au standard
   <acronym>SQL</acronym>, aux exceptions indiquées ci-dessous.
  </para>

  <refsect2>
   <title>Tables temporaires</title>

   <para>
    Bien que la syntaxe de <literal>CREATE TEMPORARY TABLE</literal> ressemble
    à celle du SQL standard, l'effet n'est pas le même. Dans le standard, les
    tables temporaires sont définies une seule fois et existent
    automatiquement (vide de tout contenu au démarrage) dans toute session les
    utilisant. <productname>PostgreSQL</productname>, au contraire, impose
    à chaque session de lancer une commande <literal>CREATE TEMPORARY
    TABLE</literal> pour chaque table temporaire utilisée. Cela permet à
    des sessions différentes d'utiliser le même nom de table temporaire dans des
    buts différents (le standard contraint toutes les
    instances d'une table temporaire donnée à pointer sur la même structure de
    table).
   </para>

   <para>
    Le comportement des tables temporaires tel que défini par le standard est
    largement ignorée. Le comportement de <productname>PostgreSQL</productname>
    sur ce point est similaire à celui de nombreuses autres bases de données
    SQL.
   </para>

   <para>
    <productname>PostgreSQL</productname> ne respecte pas la distinction
    imposée par le standard entre tables temporaires globales et locales.
    En effet, cette distinction repose sur le concept de modules que
    <productname>PostgreSQL</productname> ne gère pas. Pour des raisons
    de compatibilité, <productname>PostgreSQL</productname> accepte 
    néanmoins les mots-clés <literal>GLOBAL</literal> et <literal>LOCAL</literal>
    dans la définition d'une table temporaire, mais ils n'ont aucun effet.
   </para>

   <para>
    La clause <literal>ON COMMIT</literal> sur les tables temporaires
    diffère quelque peu du standard SQL. Si la clause
    <literal>ON COMMIT</literal> est omise, SQL spécifie <literal>ON COMMIT DELETE ROWS</literal>
    comme comportemant par défaut. <productname>PostgreSQL</productname> utilise
    <literal>ON COMMIT PRESERVE ROWS</literal> par défaut. De plus, l'option
    <literal>ON COMMIT DROP</literal> n'existe pas en SQL.
   </para>
  </refsect2>

  <refsect2>
   <title>Non-deferred Uniqueness Constraints</title>

   <para>
    When a <literal>UNIQUE</literal> or <literal>PRIMARY KEY</literal> constraint is
    not deferrable, <productname>PostgreSQL</productname> checks for
    uniqueness immediately whenever a row is inserted or modified.
    The SQL standard says that uniqueness should be enforced only at
    the end of the statement; this makes a difference when, for example,
    a single command updates multiple key values.  To obtain
    standard-compliant behavior, declare the constraint as
    <literal>DEFERRABLE</literal> but not deferred (i.e., <literal>INITIALLY
    IMMEDIATE</literal>).  Be aware that this can be significantly slower than
    immediate uniqueness checking.
   </para>
  </refsect2>

  <refsect2>
   <title>Contraintes de vérification de colonnes</title>

   <para>
    Dans le standard, les contraintes de vérification <literal>CHECK</literal>
    de colonne ne peuvent faire référence qu'à la colonne à laquelle elles
    s'appliquent&nbsp;; seules les contraintes <literal>CHECK</literal> de table
    peuvent faire référence à plusieurs colonnes.
    <productname>PostgreSQL</productname> n'impose pas cette restriction&nbsp;;
    les contraintes de vérifications de colonnes et de table ont un traitement
    identique.
   </para>
  </refsect2>

  <refsect2>
   <title><literal>EXCLUDE</literal> Constraint</title>

   <para>
    The <literal>EXCLUDE</literal> constraint type is a
    <productname>PostgreSQL</productname> extension.
   </para>
  </refsect2>

  <refsect2>
   <title>Contrainte <literal>NULL</literal></title>

   <para>
    La <quote>contrainte</quote> <literal>NULL</literal> (en fait, une
    non-contrainte) est une extension <productname>PostgreSQL</productname> au
    standard SQL, incluse pour des raisons de compatibilité avec d'autres
    systèmes de bases de données (et par symétrie avec la contrainte
    <literal>NOT NULL</literal>). Comme c'est la valeur par défaut de toute
    colonne, sa présence est un simple bruit.
   </para>
  </refsect2>
   
  <refsect2>
   <title>Héritage</title>

   <para>
    L'héritage multiple via la clause <literal>INHERITS</literal> est une
    extension du langage <productname>PostgreSQL</productname>. SQL:1999 et
    les versions ultérieures définissent un héritage simple en utilisant une
    syntaxe et des sémantiques différentes. L'héritage style SQL:1999 n'est pas
    encore supporté par <productname>PostgreSQL</productname>.
   </para>
  </refsect2>

  <refsect2>
   <title>Tables sans colonne</title>

   <para>
    <productname>PostgreSQL</productname> autorise la création de tables sans
    colonne (par exemple, <literal>CREATE TABLE foo();</literal>). C'est une
    extension du standard SQL, qui ne le permet pas. Les tables sans colonne ne
    sont pas très utiles mais les interdire conduit à un comportement étrange de
    <command>ALTER TABLE DROP COLUMN</command>. Il est donc plus sage
    d'ignorer simplement cette restriction.
   </para>
  </refsect2>

  <refsect2>
   <title><literal>WITH</literal> clause</title>

   <para>
    La clause <literal>WITH</literal> est une extension
    <productname>PostgreSQL</productname>&nbsp;; ni les paramètres de stockage
    ni les OID ne sont dans le standard.
   </para>
  </refsect2>

  <refsect2>
    <title>Tablespaces</title>

    <para>
      Le concept <productname>PostgreSQL</productname> de tablespace n'est
      pas celui du standard. De ce fait, les clauses <literal>TABLESPACE</literal>
      et <literal>USING INDEX TABLESPACE</literal> sont des extensions.
    </para>
  </refsect2>

  <refsect2>
   <title>Typed Tables</title>

   <para>
    Typed tables implement a subset of the SQL standard.  According to
    the standard, a typed table has columns corresponding to the
    underlying composite type as well as one other column that is
    the <quote>self-referencing column</quote>.  PostgreSQL does not
    support these self-referencing columns explicitly, but the same
    effect can be had using the OID feature.
   </para>
  </refsect2>
 </refsect1>


 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-altertable"/></member>
   <member><xref linkend="sql-droptable"/></member>
   <member><xref linkend="sql-createtablespace"/></member>
  </simplelist>
 </refsect1>
</refentry>
