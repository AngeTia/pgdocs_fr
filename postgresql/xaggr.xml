<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

 <sect1 id="xaggr">
  <title>Agrégats utilisateur</title>

  <indexterm zone="xaggr">
   <primary>fonctions agrégat</primary>
   <secondary>extension</secondary>
  </indexterm>

  <para>
   Dans <productname>PostgreSQL</productname>, les fonctions d'agrégat  
   sont exprimées comme des <firstterm>valeurs d'état</firstterm>
   et des <firstterm>fonctions de transition d'état</firstterm>.
   C'est-à-dire qu'un agrégat opère en utilisant une valeur d'état qui est mis
   à jour à chaque ligne traitée.
   Pour définir une nouvelle fonction d'agrégat, on choisit
   un type de donnée pour la valeur d'état, une valeur initiale pour l'état et
   une fonction de transition d'état. La fonction de transition d'état
   takes the previous state
   value and the aggregate's input value(s) for the current row, and
   returns a new state value.
   Une <firstterm>fonction finale</firstterm> peut
   également être spécifiée pour le cas où le résultat désiré comme agrégat est
   différent des données conservées comme valeur d'état courant. The final function takes the last state value
   and returns whatever is wanted as the aggregate result.
   In principle, the transition and final functions are just ordinary
   functions that could also be used outside the context of the
   aggregate.  (In practice, it's often helpful for performance reasons
   to create specialized transition functions that can only work when
   called as part of an aggregate.)
  </para>

  <para>
   Ainsi, en plus des types de données d'argument et de résultat vus par
   l'utilisateur, il existe un type de données pour la valeur d'état interne qui
   peut être différent des deux autres.</para>

  <para>
   Un agrégat qui n'utilise pas de fonction finale est un agrégat qui utilise
   pour chaque ligne une fonction dépendante des valeurs de colonnes.
   <function>sum</function> en est un exemple.
   <function>sum</function> débute à zéro et ajoute la valeur de la ligne
   courante à son total en cours. Par exemple, pour obtenir un agrégat
   <function>sum</function> qui opère sur un type de données nombres
   complexes, il suffira décrire la fonction d'addition pour ce type de donnée.
   La définition de l'agrégat sera&nbsp;:
<programlisting>CREATE AGGREGATE somme (complex)
(
    sfunc = ajout_complexe,
    stype = complexe,
    initcond = '(0,0)'
);
</programlisting>

   which we might use like this:
 
<programlisting>
SELECT somme(a) FROM test_complexe;

   somme
-----------
 (34,53.9)
</programlisting>

   (Notez que nous nous reposons sur une surcharge de fonction&nbsp;: il existe
   plus d'un agrégat nommé <function>sum</function> mais
   <productname>PostgreSQL</productname> trouve le type de somme s'appliquant à
   une colonne de type <type>complex</type>.)
 </para> 
  <para>
   La définition précédente de <function>sum</function> retournera zéro (la
   condition d'état initial) s'il n'y a que des valeurs d'entrée NULL.
   Dans ce cas, on peut souhaiter qu' elle retourne NULL &mdash; le
   standard SQL prévoit que la fonction <function>sum</function> se comporte
   ainsi. Cela peut être obtenu par l'omission de l'instruction
   <literal>initcond</literal>, de sorte que la condition d'état initial soit
   NULL.
   Dans ce cas, <literal>sfunc</literal> vérifie l'entrée d'une condition
   d'état NULL mais, pour <function>sum</function> et quelques
   autres agrégats simples comme <function>max</function> et <function>min</function>, il
   suffit d'insérer la première valeur d'entrée non NULL dans la variable d'état
   et d'appliquer la fonction de transition d'état à partir de la
   seconde valeur non NULL. 
   <productname>PostgreSQL</productname> fait cela automatiquement si la
   condition initiale est NULL et si la fonction de transition est marquée
   <quote>strict</quote> (elle n'est pas appelée pour les entrées NULL).
  </para> 
   <para>
    Par défaut également, pour les fonctions de transition <quote>strict</quote>, 
    la valeur d'état précédente reste inchangée pour une entrée NULL. 
    Les valeurs NULL sont ainsi ignorées. 
    Pour obtenir un autre comportement, il suffit de ne
    pas déclarer la fonction de transition <quote>strict</quote>. À la place,
    codez-la de façon à ce qu'elle vérifie et traite les entrées NULL.
 </para>
  
  <para>
   <function>avg</function> (average = moyenne) est un exemple plus complexe d'agrégat.
   Il demande deux états courants&nbsp;: la somme des entrées et le
   nombre d'entrées. Le résultat final est obtenu en divisant ces quantités. La
   moyenne est typiquement implantée en utilisant comme valeur d'état un
   tableau. Par exemple, l'implémentation intégrée de
   <function>avg(float8)</function> ressemble à&nbsp;:

<programlisting>CREATE AGGREGATE avg (float8)
(
    sfunc = float8_accum,
    stype = float8[],
    finalfunc = float8_avg,
    initcond = '{0,0,0}'
);
</programlisting>
  </para>
 
  <note>
   <para>
   <function>float8_accum</function> nécessite un tableau à trois éléments,
   et non pas seulement deux, car il accumule la somme des carrés, ainsi que
   la somme et le nombre des entrées. Cela permet son utilisation pour
   d'autres agrégats que <function>avg</function>.
   </para>
  </note>

  <para>
   Aggregate function calls in SQL allow <literal>DISTINCT</literal>
   and <literal>ORDER BY</literal> options that control which rows are fed
   to the aggregate's transition function and in what order.  These
   options are implemented behind the scenes and are not the concern
   of the aggregate's support functions.
  </para>

  <para>
   For further details see the
   <xref linkend="sql-createaggregate"/>
   command.
  </para>

 <sect2 id="xaggr-moving-aggregates">
  <title>Moving-Aggregate Mode</title>

  <indexterm>
   <primary>moving-aggregate mode</primary>
  </indexterm>

  <indexterm>
   <primary>aggregate function</primary>
   <secondary>moving aggregate</secondary>
  </indexterm>

  <para>
   Aggregate functions can optionally support <firstterm>moving-aggregate
   mode</firstterm>, which allows substantially faster execution of aggregate
   functions within windows with moving frame starting points.
   (See <xref linkend="tutorial-window"/>
   and <xref linkend="syntax-window-functions"/> for information about use of
   aggregate functions as window functions.)
   The basic idea is that in addition to a normal <quote>forward</quote>
   transition function, the aggregate provides an <firstterm>inverse
   transition function</firstterm>, which allows rows to be removed from the
   aggregate's running state value when they exit the window frame.
   For example a <function>sum</function> aggregate, which uses addition as the
   forward transition function, would use subtraction as the inverse
   transition function.  Without an inverse transition function, the window
   function mechanism must recalculate the aggregate from scratch each time
   the frame starting point moves, resulting in run time proportional to the
   number of input rows times the average frame length.  With an inverse
   transition function, the run time is only proportional to the number of
   input rows.
  </para>

  <para>
   The inverse transition function is passed the current state value and the
   aggregate input value(s) for the earliest row included in the current
   state.  It must reconstruct what the state value would have been if the
   given input row had never been aggregated, but only the rows following
   it.  This sometimes requires that the forward transition function keep
   more state than is needed for plain aggregation mode.  Therefore, the
   moving-aggregate mode uses a completely separate implementation from the
   plain mode: it has its own state data type, its own forward transition
   function, and its own final function if needed.  These can be the same as
   the plain mode's data type and functions, if there is no need for extra
   state.
  </para>

  <para>
   As an example, we could extend the <function>sum</function> aggregate given above
   to support moving-aggregate mode like this:

<programlisting>
CREATE AGGREGATE sum (complex)
(
    sfunc = complex_add,
    stype = complex,
    initcond = '(0,0)',
    msfunc = complex_add,
    minvfunc = complex_sub,
    mstype = complex,
    minitcond = '(0,0)'
);
</programlisting>

   The parameters whose names begin with <literal>m</literal> define the
   moving-aggregate implementation.  Except for the inverse transition
   function <literal>minvfunc</literal>, they correspond to the plain-aggregate
   parameters without <literal>m</literal>.
  </para>

  <para>
   The forward transition function for moving-aggregate mode is not allowed
   to return null as the new state value.  If the inverse transition
   function returns null, this is taken as an indication that the inverse
   function cannot reverse the state calculation for this particular input,
   and so the aggregate calculation will be redone from scratch for the
   current frame starting position.  This convention allows moving-aggregate
   mode to be used in situations where there are some infrequent cases that
   are impractical to reverse out of the running state value.  The inverse
   transition function can <quote>punt</quote> on these cases, and yet still come
   out ahead so long as it can work for most cases.  As an example, an
   aggregate working with floating-point numbers might choose to punt when
   a <literal>NaN</literal> (not a number) input has to be removed from the running
   state value.
  </para>

  <para>
   When writing moving-aggregate support functions, it is important to be
   sure that the inverse transition function can reconstruct the correct
   state value exactly.  Otherwise there might be user-visible differences
   in results depending on whether the moving-aggregate mode is used.
   An example of an aggregate for which adding an inverse transition
   function seems easy at first, yet where this requirement cannot be met
   is <function>sum</function> over <type>float4</type> or <type>float8</type> inputs.  A
   naive declaration of <function>sum(<type>float8</type>)</function> could be

<programlisting>
CREATE AGGREGATE unsafe_sum (float8)
(
    stype = float8,
    sfunc = float8pl,
    mstype = float8,
    msfunc = float8pl,
    minvfunc = float8mi
);
</programlisting>

   This aggregate, however, can give wildly different results than it would
   have without the inverse transition function. For example, consider

<programlisting>
SELECT
  unsafe_sum(x) OVER (ORDER BY n ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)
FROM (VALUES (1, 1.0e20::float8),
             (2, 1.0::float8)) AS v (n,x);
</programlisting>

   This query returns <literal>0</literal> as its second result, rather than the
   expected answer of <literal>1</literal>.  The cause is the limited precision of
   floating-point values: adding <literal>1</literal> to <literal>1e20</literal> results
   in <literal>1e20</literal> again, and so subtracting <literal>1e20</literal> from that
   yields <literal>0</literal>, not <literal>1</literal>.  Note that this is a limitation
   of floating-point arithmetic in general, not a limitation
   of <productname>PostgreSQL</productname>.
  </para>

 </sect2>

 <sect2 id="xaggr-polymorphic-aggregates">
  <title>Polymorphic and Variadic Aggregates</title>

  <indexterm>
   <primary>aggregate function</primary>
   <secondary>polymorphic</secondary>
  </indexterm>

  <indexterm>
   <primary>aggregate function</primary>
   <secondary>variadic</secondary>
  </indexterm>

  <para>
   Les fonctions d'agrégat peuvent utiliser des fonctions d'état transitionnelles
   ou des fonctions finales polymorphes. De cette façon, les mêmes fonctions
   peuvent être utilisées pour de multiples agrégats. Voir la <xref
   linkend="extend-types-polymorphic"/> pour une explication des fonctions polymorphes.
   La fonction d'agrégat elle-même peut être
   spécifiée avec un type de base et des types d'état polymorphes, ce qui permet
   ainsi à une unique définition de fonction de servir pour de multiples types
   de données en entrée. Voici un exemple d'agrégat polymorphe&nbsp;:

<programlisting>CREATE AGGREGATE array_accum (anyelement)
(
    sfunc = array_append,
    stype = anyarray,
    initcond = '{}'
);
</programlisting>

   Dans ce cas, le type d'état effectif pour tout appel d'agrégat est le type
   tableau avec comme éléments le type effectif d'entrée. Le comportement de
   l'agrégat est de concaténer toutes les entrées dans un tableau de ce type.
   (Note&nbsp;: l'agrégat <function>array_agg</function> fournit une
   fonctionnalité similaire, avec de meilleures performances que ne pourrait
   avoir cette définition.)
</para>

  <para>
   Voici le résultat pour deux types de données différents en arguments&nbsp;:
<programlisting>SELECT attrelid::regclass, array_accum(attname)
FROM pg_attribute WHERE attnum &gt; 0
AND attrelid = 'pg_tablespace'::regclass GROUP BY attrelid;
   attrelid    |              array_accum              
---------------+---------------------------------------
 pg_tablespace | {spcname,spcowner,spcacl,spcoptions}
(1 row)

SELECT attrelid::regclass, array_accum(atttypid::regtype)
    FROM pg_attribute
    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
    GROUP BY attrelid;

   attrelid    |        array_accum        
---------------+---------------------------
 pg_tablespace | {name,oid,aclitem[],text[]}
(1 row)
</programlisting>
  </para>

  <para>
   Ordinarily, an aggregate function with a polymorphic result type has a
   polymorphic state type, as in the above example.  This is necessary
   because otherwise the final function cannot be declared sensibly: it
   would need to have a polymorphic result type but no polymorphic argument
   type, which <command>CREATE FUNCTION</command> will reject on the grounds that
   the result type cannot be deduced from a call.  But sometimes it is
   inconvenient to use a polymorphic state type.  The most common case is
   where the aggregate support functions are to be written in C and the
   state type should be declared as <type>internal</type> because there is
   no SQL-level equivalent for it.  To address this case, it is possible to
   declare the final function as taking extra <quote>dummy</quote> arguments
   that match the input arguments of the aggregate.  Such dummy arguments
   are always passed as null values since no specific value is available when the
   final function is called.  Their only use is to allow a polymorphic
   final function's result type to be connected to the aggregate's input
   type(s).  For example, the definition of the built-in
   aggregate <function>array_agg</function> is equivalent to

<programlisting>
CREATE FUNCTION array_agg_transfn(internal, anyelement)
  RETURNS internal ...;
CREATE FUNCTION array_agg_finalfn(internal, anyelement)
  RETURNS anyarray ...;

CREATE AGGREGATE array_agg (anyelement)
(
    sfunc = array_agg_transfn,
    stype = internal,
    finalfunc = array_agg_finalfn,
    finalfunc_extra
);
</programlisting>

   Here, the <literal>finalfunc_extra</literal> option specifies that the final
   function receives, in addition to the state value, extra dummy
   argument(s) corresponding to the aggregate's input argument(s).
   The extra <type>anyelement</type> argument allows the declaration
   of <function>array_agg_finalfn</function> to be valid.
  </para>

  <para>
   An aggregate function can be made to accept a varying number of arguments
   by declaring its last argument as a <literal>VARIADIC</literal> array, in much
   the same fashion as for regular functions; see
   <xref linkend="xfunc-sql-variadic-functions"/>.  The aggregate's transition
   function(s) must have the same array type as their last argument.  The
   transition function(s) typically would also be marked <literal>VARIADIC</literal>,
   but this is not strictly required.
  </para>

  <note>
   <para>
    Variadic aggregates are easily misused in connection with
    the <literal>ORDER BY</literal> option (see <xref linkend="syntax-aggregates"/>),
    since the parser cannot tell whether the wrong number of actual arguments
    have been given in such a combination.  Keep in mind that everything to
    the right of <literal>ORDER BY</literal> is a sort key, not an argument to the
    aggregate.  For example, in
<programlisting>
SELECT myaggregate(a ORDER BY a, b, c) FROM ...
</programlisting>
    the parser will see this as a single aggregate function argument and
    three sort keys.  However, the user might have intended
<programlisting>
SELECT myaggregate(a, b, c ORDER BY a) FROM ...
</programlisting>
    If <literal>myaggregate</literal> is variadic, both these calls could be
    perfectly valid.
   </para>

   <para>
    For the same reason, it's wise to think twice before creating aggregate
    functions with the same names and different numbers of regular arguments.
   </para>
  </note>

 </sect2>

 <sect2 id="xaggr-ordered-set-aggregates">
  <title>Ordered-Set Aggregates</title>

  <indexterm>
   <primary>aggregate function</primary>
   <secondary>ordered set</secondary>
  </indexterm>

  <para>
   The aggregates we have been describing so far are <quote>normal</quote>
   aggregates.  <productname>PostgreSQL</productname> also
   supports <firstterm>ordered-set aggregates</firstterm>, which differ from
   normal aggregates in two key ways.  First, in addition to ordinary
   aggregated arguments that are evaluated once per input row, an
   ordered-set aggregate can have <quote>direct</quote> arguments that are
   evaluated only once per aggregation operation.  Second, the syntax
   for the ordinary aggregated arguments specifies a sort ordering
   for them explicitly.  An ordered-set aggregate is usually
   used to implement a computation that depends on a specific row
   ordering, for instance rank or percentile, so that the sort ordering
   is a required aspect of any call.  For example, the built-in
   definition of <function>percentile_disc</function> is equivalent to:

<programlisting>
CREATE FUNCTION ordered_set_transition(internal, anyelement)
  RETURNS internal ...;
CREATE FUNCTION percentile_disc_final(internal, float8, anyelement)
  RETURNS anyelement ...;

CREATE AGGREGATE percentile_disc (float8 ORDER BY anyelement)
(
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_disc_final,
    finalfunc_extra
);
</programlisting>

   This aggregate takes a <type>float8</type> direct argument (the percentile
   fraction) and an aggregated input that can be of any sortable data type.
   It could be used to obtain a median household income like this:

<programlisting>
SELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_disc
-----------------
           50489
</programlisting>

   Here, <literal>0.5</literal> is a direct argument; it would make no sense
   for the percentile fraction to be a value varying across rows.
  </para>

  <para>
   Unlike the case for normal aggregates, the sorting of input rows for
   an ordered-set aggregate is <emphasis>not</emphasis> done behind the scenes,
   but is the responsibility of the aggregate's support functions.
   The typical implementation approach is to keep a reference to
   a <quote>tuplesort</quote> object in the aggregate's state value, feed the
   incoming rows into that object, and then complete the sorting and
   read out the data in the final function.  This design allows the
   final function to perform special operations such as injecting
   additional <quote>hypothetical</quote> rows into the data to be sorted.
   While normal aggregates can often be implemented with support
   functions written in <application>PL/pgSQL</application> or another
   PL language, ordered-set aggregates generally have to be written in
   C, since their state values aren't definable as any SQL data type.
   (In the above example, notice that the state value is declared as
   type <type>internal</type> &mdash; this is typical.)
  </para>

  <para>
   The state transition function for an ordered-set aggregate receives
   the current state value plus the aggregated input values for
   each row, and returns the updated state value.  This is the
   same definition as for normal aggregates, but note that the direct
   arguments (if any) are not provided.  The final function receives
   the last state value, the values of the direct arguments if any,
   and (if <literal>finalfunc_extra</literal> is specified) null values
   corresponding to the aggregated input(s).  As with normal
   aggregates, <literal>finalfunc_extra</literal> is only really useful if the
   aggregate is polymorphic; then the extra dummy argument(s) are needed
   to connect the final function's result type to the aggregate's input
   type(s).
  </para>

  <para>
   Currently, ordered-set aggregates cannot be used as window functions,
   and therefore there is no need for them to support moving-aggregate mode.
  </para>

 </sect2>

 <sect2 id="xaggr-support-functions">
  <title>Support Functions for Aggregates</title>

  <indexterm>
   <primary>aggregate function</primary>
   <secondary>support functions for</secondary>
  </indexterm>

  <para>
   Une fonction écrite en C peut détecter si elle est appelée en tant que
   fonction de transition ou en tant que fonction finale d'un agrégat en
   appelant <function>AggCheckCallContext</function>, par exemple&nbsp;:
<programlisting>
        if (AggCheckCallContext(fcinfo, NULL))
</programlisting>
   Une raison de surveiller ceci est que, si le retour de cette fonction
   vaut true pour une fonction de transition, la première valeur doit être
   une valeur de transition temporaire et peut du coup être modifiée en toute
   sûreté sans avoir à allouer une nouvelle copie. Voir
   <literal>int8inc()</literal> pour un exemple. (C'est le
   <emphasis>seul</emphasis> cas où une fonction peut modifier en toute
   sécurité un argument passé en référence. En particulier, les fonctions
   finales d'agrégat normal ne doivent pas modifier leur arguments dans tous les cas
   car, dans certains cas, elles seront ré-exécutées sur la même valeur de
   transition finale.)
  </para>

  <para>
   Another support routine available to aggregate functions written in C
   is <function>AggGetAggref</function>, which returns the <literal>Aggref</literal>
   parse node that defines the aggregate call.  This is mainly useful
   for ordered-set aggregates, which can inspect the substructure of
   the <literal>Aggref</literal> node to find out what sort ordering they are
   supposed to implement.  Examples can be found
   in <filename>orderedsetaggs.c</filename> in the <productname>PostgreSQL</productname>
   source code.
  </para>

 </sect2>

 </sect1>
