<?xml version="1.0" encoding="UTF-8"?>
<chapter id="logical-replication">
 <title>Réplication logique</title>

 <para>
  La réplication logique est une méthode permettant de répliquer des
  données au niveau objet ainsi que les modifications apportées à ces
  objets, ceci basé sur leur identité de réplication (habituellement
  la clé primaire).
  L'utilisation du terme <quote>réplication logique</quote> est faite en opposition
  à la réplication physique qui elle, utilise l'adresse exacte des blocs
  couplée avec une réplication octet par octet.
  PostgreSQL supporte ces deux méthodes, référez-vous à l'article
  <xref linkend="high-availability"/>.
  La réplication logique permet un contrôle fin des données au niveau
  de la réplication et de la sécurité.
 </para>

 <para>
  La réplication logique utilise un système de
  <firstterm>publication</firstterm>/<firstterm>abonnement</firstterm>
  avec un ou plusieurs <firstterm>abonnés</firstterm> qui s'abonnent à
  une ou plusieurs <firstterm>publications</firstterm> d'un nœud
  particulier.
  Les abonnés récupèrent les données des publications auxquelles ils sont
  abonnés et peuvent éventuellement renvoyer ces informations pour
  permettre un système de réplication en cascade dans le cas de
  configurations plus complexes.
 </para>

 <para>
  La réplication logique d'une table commence en générale en prenant un
  instantané des données sur la base publiée et le copiant vers la base
  abonnée.
  Une fois cette étape réalisée, les changements sur la base publiée
  sont envoyés à la base abonnée en temps réel.
  La base abonnée applique les modifications dans le même ordre qu'elles
  auront été réalisées de façon à ce que la cohérence transactionnelle
  soit garantie pour les publications d'un seul abonnement.
  Cette méthode de réplication porte parfois le nom de réplication
  transactionnelle.
 </para>

 <para>
  Les cas typiques d'utilisation de la réplication logique peuvent être
  les suivants&nbsp;:

  <itemizedlist>
   <listitem>
    <para>
     Envoyer immédiatement les changements réalisés sur une base de données,
     ou sur un sous-ensemble de ces données, de façon incrémentale à une
     base de données abonnée.
    </para>
   </listitem>

   <listitem>
    <para>
     Déclencher des triggers pour des changements spécifiques lorsqu'ils
     apparaissent sur la base de données abonnée.
    </para>
   </listitem>

   <listitem>
    <para>
     Réaliser la consolidation de plusieurs bases de données au sein d'une
     seule (par exemple pour répondre à des problématiques analytiques).
    </para>
   </listitem>

   <listitem>
    <para>
     Réplication entre des versions majeures différentes de PostgreSQL.
    </para>
   </listitem>

   <listitem>
    <para>
     Répliquer des instances PostgreSQL sur des plateformes différentes (par
     exemple de Linux à Windows)
    </para>
   </listitem>

   <listitem>
    <para>
     Donner accès à des données répliquées à différents groupes
     d'utilisateurs.
    </para>
   </listitem>

   <listitem>
    <para>
     Partager un sous-ensemble de données entre plusieurs bases de données.
    </para>
   </listitem>
  </itemizedlist>
 </para>

 <para>
  Une base de données abonnée se comporte comme n'importe quelle autre
  base de données d'une instance PostgreSQL et peut être utilisée comme
  base de données de publication pour d'autres base de données en lui
  définissant ses propres publications.
  Lorsque la base abonnée est considérée comme une base en lecture seule
  par l'application, il ne va pas y avoir de problèmes de conflit.
  D'un autre côté, s'il y a des écritures provenant soit de l'application
  soit d'un autre abonnement sur le même ensemble de tables, des conflits
  peuvent survenir.
 </para>

 <sect1 id="logical-replication-publication">
  <title>Publication</title>

  <para>
   Une <firstterm>publication</firstterm> peut être définie sur n'importe
   quel serveur primaire de réplication physique.
   Le nœud sur laquelle la publication est définie est nommé
   <firstterm>éditeur</firstterm> .
   Une publication est un ensemble de modifications générées par une table
   ou un groupe de table et peut aussi être défini comme un ensemble de
   modifications ou un ensemble de réplication. Chaque publication existe au
   sein d'une seule base de données.
  </para>

  <para>
   Les publications sont différenciées du schéma et n'ont pas d'impact
   sur la manière dont la base est accédée.
   Chaque table peut être ajoutée à différentes publications si besoin.
   Actuellement, les publications ne contiennent que les tables et toutes
   les tables d'un schéma.
   Les objets doivent être ajoutés explicitement, sauf si la publication
   a été créée pour toutes les tables (<literal>ALL TABLES</literal>).
  </para>

  <para>
   Les publications peuvent choisir de limiter les changements qu'elles
   produisent avec n'importe quelle combinaison de
   <command>INSERT</command>, <command>UPDATE</command>,
   <command>DELETE</command> et <command>TRUNCATE</command>, ceci d'une façon
   similaire à l'activation de triggers en fonction d'un certain type
   d'événement. Par défaut, tous les types d'opération sont répliqués.
   (Row filters have no effect for <command>TRUNCATE</command>. See
   <xref linkend="logical-replication-row-filter"/>).
  </para>

  <para>
   Une table publiée doit avoir une <quote>identité de réplication</quote>
   configurée pour être capable de répliquer des opérations
   <command>UPDATE</command> et <command>DELETE</command>, pour que les lignes
   appropriées à modifier ou supprimer puissent être identifiées du côté de
   l'abonné. Par défaut, il s'agit de la clé primaire, si elle existe. Un
   autre index unique (avec quelques prérequis supplémentaires) peut aussi
   être configuré du côté de l'abonné. Si la table n'a pas de clé convenable,
   alors elle peut être configurée pour l'identité de réplicat
   <quote>full</quote>, ce qui signifie que la ligne entière devient la clé.
   Néanmoins, ceci est très inefficace et devrait seulement être utilisé si
   aucune autre solution n'est disponible. Si une identité de réplication est
   différente de <quote>full</quote> du côté du publieur, une identité de
   réplication comprenant les mêmes colonnes, ou moins de colonnes, peut aussi
   être configuré du côté de l'abonné. Voir <xref
   linkend="sql-altertable-replica-identity"/> pour les détails sur la
   configuration de l'identité de réplication. Si une table sans identité de
   réplication est ajoutée à une publication qui réplique les opérations
   <command>UPDATE</command> ou <command>DELETE</command>, alors les
   opérations <command>UPDATE</command> ou <command>DELETE</command> suivantes
   causera une erreur sur le publieur. Les opérations
   <command>INSERT</command> peuvent se réaliser quelque soit l'identité de
   réplication.
  </para>

  <para>
   Chaque publication peut avoir plusieurs abonnés.
  </para>

  <para>
   Une publication est créée en utilisant la commande
   <link linkend="sql-createpublication"><command>CREATE PUBLICATION</command></link>
   et peut ensuite être modifiée
   ou supprimée en utilisant la commande correspondante.
  </para>

  <para>
   Les tables individuelles peuvent être ajoutées ou supprimées
   dynamiquement en utilisant <link linkend="sql-alterpublication"><command>ALTER
   PUBLICATION</command></link>. Les opérations <literal>ADD TABLE</literal> et
   <literal>DROP TABLE</literal> sont toutes les deux transactionnelles&nbsp;;
   de ce fait, une table va commencer ou arrêter de répliquer dans le bon
   instantané seulement une fois que la transaction a été validée.
  </para>
 </sect1>

 <sect1 id="logical-replication-subscription">
  <title>Abonnement</title>

  <para>
   Un <firstterm>abonnement</firstterm> est le côté aval de la
   réplication logique.
   Le nœud où un abonnement a été défini est nommé
   <firstterm>abonné</firstterm>.
   Un abonnement définit la connexion à une autre base de données et
   un ensemble de publications (une ou plus) auxquelles l'abonné veut
   souscrire.
  </para>

  <para>
   La base de données abonnée se comporte comme n'importe quelle base
   de données d'une instance PostgreSQL et peut être utilisée comme
   éditeur pour d'autres bases de données en définissant ses propres
   publications.
  </para>

  <para>
   Un nœud abonné peut avoir plusieurs abonnements si besoin. Il est
   possible de définir plusieurs abonnements entre une même paire
   éditeur-abonné. Dans ce cas, il faut faire attention à ce que les objets
   des publications auquelles l'abonné a souscrit ne se chevauchent pas.
  </para>

  <para>
   Chaque abonnement recevra les changements par un slot de réplication
   (voir <xref linkend="streaming-replication-slots"/>). Des slots de
   réplications supplémentaires peuvent être nécessaires pour la
   synchronisation initiale des données d'une table contenant des données
   pré-existantes et ils seront supprimés à la fin de la synchronisation des
   données.
  </para>

  <para>
   Un abonnement de réplication logique peut être un serveur standby pour de
   la réplication synchrone (voir <xref linkend="synchronous-replication"/>).
   Le nom du serveur standby correspond par défaut au nom de l'abonnement. Un
   nom alternatif peut être indiqué avec le paramètre
   <literal>application_name</literal> dans les informations de connexion à
   l'abonnement.
  </para>

  <para>
   Les abonnements sont sauvegardés par <command>pg_dump</command> si
   l'utilisateur courant a des droits de super-utilisateur. Si ce n'est
   pas le cas, un message d'avertissement est renvoyé et les abonnements ne sont pas
   sauvegardés. En effet, les informations d'abonnements contenues dans
   <structname>pg_subscription</structname> ne sont pas consultables par
   des utilisateurs dotés de droits moins importants.
  </para>

  <para>
   Un abonnement est ajouté en utilisant <link
   linkend="sql-createsubscription"><command>CREATE
   SUBSCRIPTION</command></link>. Il peut être arrêté/repris à n'importe quel
   moment en utilisant la commande <link
   linkend="sql-altersubscription"><command>ALTER
   SUBSCRIPTION</command></link> et il peut être supprimé par la commande
   <link linkend="sql-dropsubscription"><command>DROP
   SUBSCRIPTION</command></link>.
  </para>

  <para>
   Quand un abonnement est supprimé puis recréé, les informations de
   synchronisation sont perdues. Cela signifie que les données doivent
   être resynchronisées ensuite.
  </para>

  <para>
   La définition d'un schéma n'est pas répliquée, et les tables publiées
   doivent exister sur la base abonnée. Seules des tables standards
   peuvent accueillir des données répliquées. Par exemple, il n'est pas
   pas possible de répliquer dans une vue.
  </para>

  <para>
   La correspondance entre les tables de l'éditeur et de l'abonné est
   réalisée en utilisant le nom entièrement qualifié de la table.
   La réplication entre des tables portant un nom différent sur la base
   abonnée n'est pas supportée.
  </para>

  <para>
   La correspondance sur les colonnes d'une table se fait aussi par nom.
   L'ordre des colonnes dans la table sur le serveur abonné ne correspond pas
   forcément à l'ordre sur le serveur publieur. Les types de données n'ont pas
   non plus besoin de correspondre, à partir du moment où la représentation
   textuelle de la donnée puisse être convertie vers le type de données cible.
   Par exemple, vous pouvez répliquer d'une colonne de type
   <type>integer</type> vers une colonne de type <type>bigint</type>. La table
   cible peut aussi avoir des colonnes supplémentaires non fournies par la
   table publiée. Ce type de colonne sera rempli avec la valeur par défaut
   fournie dans la définition de la table cible.
  </para>

  <sect2 id="logical-replication-subscription-slot">
   <title>Gestion des slots de réplication</title>

   <para>
    Comme présenté plus tôt, chaque abonnement (actif) reçoit les
    changements depuis un slot de réplication du serveur distant
    (publication).
   </para>

   <para>
    Des slots de synchronisation de tables supplémentaires sont normalement
    temporaires, créés en interne pour réaliser la synchronisation initiale
    des tables et supprimés automatiquement quand elles ne sont plus
    nécessaires. Ces slots de synchronisation de table ont des noms générés
    automatiquement&nbsp;:
    <quote><literal>pg_%u_sync_%u_%llu</literal></quote>
    (paramètres: <parameter>oid</parameter> de la souscription,
    <parameter>relid</parameter> de la table, <parameter>sysid</parameter>
    pour l'identifiant du système).
   </para>

   <para>
    Normalement, le slot de réplication distant est créé
    automatiquement en utilisant la commande
    <command>CREATE SUBSCRIPTION</command> et il est supprimé
    automatiquement en utilisant la commande
    <command>DROP SUBSCRIPTION</command>.
    Dans certaines situations, il peut être utile ou nécessaire de
    manipuler les abonnements ainsi que les slots de réplication
    sous-jacents de façon séparées. Voici quelques exemples&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Lorsqu'en créant un abonnement, le slot de réplication
       correspondant existe déjà. Dans ce cas, l'abonnement peut être
       créé en utilisant l'option <literal>create_slot = false</literal>
       pour réaliser l'association avec le slot existant.
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsqu'en créant un abonnement, le serveur distant n'est pas
       disponible ou dans un état indéfini. Dans ce cas, l'abonnement
       peut être créé en utilisant l'option  <literal>connect = false</literal>.
       Le serveur distant ne sera jamais contacté. C'est la méthode
       utilisée par  <application>pg_dump</application>.
       Le slot de réplication distant devra alors être créé manuellement
       avant que l'abonnement puisse être activé.
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsqu'on supprime un abonnement et que le slot de réplication doit
       être conservé, par exemple lorsqu'une base abonnée est
       déplacée vers un serveur différent et sera activée depuis cette
       nouvelle localisation.
       Dans ce cas, il faut dissocier le slot de réplication de
       l'abonnement correspondant en utilisant la commande
       <command>ALTER SUBSCRIPTION</command> avant de supprimer
       l'abonnement.
      </para>
     </listitem>

     <listitem>
      <para>
       Lorsque l'on supprime un abonnement et que le serveur distant n'est
       pas joignable. Dans ce cas, il faut aussi dissocier le slot de
       réplication de l'abonnement correspondant en utilisant
       <command>ALTER SUBSCRIPTION</command> avant de supprimer
       l'abonnement.
       Si l'instance distante n'existe plus, aucune action supplémentaire
       n'est nécessaire. Si, par contre, l'instance distante est
       simplement temporairement injoignable, le slot de réplication (et tout
       slot de synchronisation de table restant)
       devrait être supprimé manuellement, sinon l'instance va
       persévérer à conserver ses fichiers WAL jusqu'à saturation de
       l'espace disque disponible. Ces cas doivent être traités avec
       beaucoup de précautions.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-row-filter">
  <title>Row Filters</title>

  <para>
   By default, all data from all published tables will be replicated to the
   appropriate subscribers. The replicated data can be reduced by using a
   <firstterm>row filter</firstterm>. A user might choose to use row filters
   for behavioral, security or performance reasons. If a published table sets a
   row filter, a row is replicated only if its data satisfies the row filter
   expression. This allows a set of tables to be partially replicated. The row
   filter is defined per table. Use a <literal>WHERE</literal> clause after the
   table name for each published table that requires data to be filtered out.
   The <literal>WHERE</literal> clause must be enclosed by parentheses. See
   <xref linkend="sql-createpublication"/> for details.
  </para>

  <sect2 id="logical-replication-row-filter-rules">
   <title>Row Filter Rules</title>

   <para>
    Row filters are applied <emphasis>before</emphasis> publishing the changes.
    If the row filter evaluates to <literal>false</literal> or <literal>NULL</literal>
    then the row is not replicated. The <literal>WHERE</literal> clause expression
    is evaluated with the same role used for the replication connection (i.e.
    the role specified in the <literal>CONNECTION</literal> clause of the
    <xref linkend="sql-createsubscription"/>). Row filters have no effect for
    <command>TRUNCATE</command> command.
   </para>

  </sect2>

  <sect2 id="logical-replication-row-filter-restrictions">
   <title>Expression Restrictions</title>

   <para>
    The <literal>WHERE</literal> clause allows only simple expressions. It
    cannot contain user-defined functions, operators, types, and collations,
    system column references or non-immutable built-in functions.
   </para>

   <para>
    If a publication publishes <command>UPDATE</command> or
    <command>DELETE</command> operations, the row filter <literal>WHERE</literal>
    clause must contain only columns that are covered by the replica identity
    (see <xref linkend="sql-altertable-replica-identity"/>). If a publication
    publishes only <command>INSERT</command> operations, the row filter
    <literal>WHERE</literal> clause can use any column.
   </para>

  </sect2>

  <sect2 id="logical-replication-row-filter-transformations">
   <title>UPDATE Transformations</title>

   <para>
    Whenever an <command>UPDATE</command> is processed, the row filter
    expression is evaluated for both the old and new row (i.e. using the data
    before and after the update). If both evaluations are <literal>true</literal>,
    it replicates the <command>UPDATE</command> change. If both evaluations are
    <literal>false</literal>, it doesn't replicate the change. If only one of
    the old/new rows matches the row filter expression, the <command>UPDATE</command>
    is transformed to <command>INSERT</command> or <command>DELETE</command>, to
    avoid any data inconsistency. The row on the subscriber should reflect what
    is defined by the row filter expression on the publisher.
   </para>

   <para>
    If the old row satisfies the row filter expression (it was sent to the
    subscriber) but the new row doesn't, then, from a data consistency
    perspective the old row should be removed from the subscriber.
    So the <command>UPDATE</command> is transformed into a <command>DELETE</command>.
   </para>

   <para>
    If the old row doesn't satisfy the row filter expression (it wasn't sent
    to the subscriber) but the new row does, then, from a data consistency
    perspective the new row should be added to the subscriber.
    So the <command>UPDATE</command> is transformed into an <command>INSERT</command>.
   </para>

   <para>
    <xref linkend="logical-replication-row-filter-transformations-summary"/>
    summarizes the applied transformations.
   </para>

   <table id="logical-replication-row-filter-transformations-summary">
    <title><command>UPDATE</command> Transformation Summary</title>
    <tgroup cols="3">
    <thead>
     <row>
      <entry>Old row</entry><entry>New row</entry><entry>Transformation</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>no match</entry><entry>no match</entry><entry>don't replicate</entry>
     </row>
     <row>
      <entry>no match</entry><entry>match</entry><entry><literal>INSERT</literal></entry>
     </row>
     <row>
      <entry>match</entry><entry>no match</entry><entry><literal>DELETE</literal></entry>
     </row>
     <row>
      <entry>match</entry><entry>match</entry><entry><literal>UPDATE</literal></entry>
     </row>
    </tbody>
   </tgroup>
   </table>

  </sect2>

  <sect2 id="logical-replication-row-filter-partitioned-table">
   <title>Partitioned Tables</title>

   <para>
    If the publication contains a partitioned table, the publication parameter
    <literal>publish_via_partition_root</literal> determines which row filter
    is used. If <literal>publish_via_partition_root</literal> is <literal>true</literal>,
    the <emphasis>root partitioned table's</emphasis> row filter is used. Otherwise,
    if <literal>publish_via_partition_root</literal> is <literal>false</literal>
    (default), each <emphasis>partition's</emphasis> row filter is used.
   </para>

  </sect2>

  <sect2 id="logical-replication-row-filter-initial-data-sync">
   <title>Initial Data Synchronization</title>

   <para>
    If the subscription requires copying pre-existing table data
    and a publication contains <literal>WHERE</literal> clauses, only data that
    satisfies the row filter expressions is copied to the subscriber.
   </para>

   <para>
    If the subscription has several publications in which a table has been
    published with different <literal>WHERE</literal> clauses, rows that satisfy
    <emphasis>any</emphasis> of the expressions will be copied. See
    <xref linkend="logical-replication-row-filter-combining"/> for details.
   </para>

   <note>
    <para>
     If the subscriber is in a release prior to 15, copy pre-existing data
     doesn't use row filters even if they are defined in the publication.
     This is because old releases can only copy the entire table data.
    </para>
   </note>

  </sect2>

  <sect2 id="logical-replication-row-filter-combining">
   <title>Combining Multiple Row Filters</title>

   <para>
    If the subscription has several publications in which the same table has
    been published with different row filters (for the same <literal>publish</literal>
    operation), those expressions get ORed together, so that rows satisfying
    <emphasis>any</emphasis> of the expressions will be replicated. This means all
    the other row filters for the same table become redundant if:
    <itemizedlist>
     <listitem>
      <para>
       one of the publications has no row filter.
      </para>
     </listitem>
     <listitem>
      <para>
       one of the publications was created using <literal>FOR ALL TABLES</literal>.
       This clause does not allow row filters.
      </para>
     </listitem>
     <listitem>
      <para>
       one of the publications was created using
       <literal>FOR ALL TABLES IN SCHEMA</literal> and the table belongs to
       the referred schema. This clause does not allow row filters.
      </para>
     </listitem>
    </itemizedlist></para>

  </sect2>

  <sect2 id="logical-replication-row-filter-examples">
   <title>Examples</title>

   <para>
    Create some tables to be used in the following examples.
<programlisting>
test_pub=# CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
CREATE TABLE
test_pub=# CREATE TABLE t2(d int, e int, f int, PRIMARY KEY(d));
CREATE TABLE
test_pub=# CREATE TABLE t3(g int, h int, i int, PRIMARY KEY(g));
CREATE TABLE
</programlisting></para>

   <para>
    Create some publications. Publication <literal>p1</literal> has one table
    (<literal>t1</literal>) and that table has a row filter. Publication
    <literal>p2</literal> has two tables. Table <literal>t1</literal> has no row
    filter, and table <literal>t2</literal> has a row filter. Publication
    <literal>p3</literal> has two tables, and both of them have a row filter.
<programlisting>
test_pub=# CREATE PUBLICATION p1 FOR TABLE t1 WHERE (a > 5 AND c = 'NSW');
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION p2 FOR TABLE t1, t2 WHERE (e = 99);
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION p3 FOR TABLE t2 WHERE (d = 10), t3 WHERE (g = 10);
CREATE PUBLICATION
</programlisting></para>

   <para>
    <command>psql</command> can be used to show the row filter expressions (if
    defined) for each publication.
<programlisting>
test_pub=# \dRp+
                               Publication p1
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t1" WHERE ((a > 5) AND (c = 'NSW'::text))

                               Publication p2
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t1"
    "public.t2" WHERE (e = 99)

                               Publication p3
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t2" WHERE (d = 10)
    "public.t3" WHERE (g = 10)
</programlisting></para>

   <para>
    <command>psql</command> can be used to show the row filter expressions (if
    defined) for each table. See that table <literal>t1</literal> is a member
    of two publications, but has a row filter only in <literal>p1</literal>.
    See that table <literal>t2</literal> is a member of two publications, and
    has a different row filter in each of them.
<programlisting>
test_pub=# \d t1
                 Table "public.t1"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           | not null |
 b      | integer |           |          |
 c      | text    |           | not null |
Indexes:
    "t1_pkey" PRIMARY KEY, btree (a, c)
Publications:
    "p1" WHERE ((a > 5) AND (c = 'NSW'::text))
    "p2"

test_pub=# \d t2
                 Table "public.t2"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 d      | integer |           | not null |
 e      | integer |           |          |
 f      | integer |           |          |
Indexes:
    "t2_pkey" PRIMARY KEY, btree (d)
Publications:
    "p2" WHERE (e = 99)
    "p3" WHERE (d = 10)

test_pub=# \d t3
                 Table "public.t3"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 g      | integer |           | not null |
 h      | integer |           |          |
 i      | integer |           |          |
Indexes:
    "t3_pkey" PRIMARY KEY, btree (g)
Publications:
    "p3" WHERE (g = 10)
</programlisting></para>

   <para>
    On the subscriber node, create a table <literal>t1</literal> with the same
    definition as the one on the publisher, and also create the subscription
    <literal>s1</literal> that subscribes to the publication <literal>p1</literal>.
<programlisting>
test_sub=# CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
CREATE TABLE
test_sub=# CREATE SUBSCRIPTION s1
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=s1'
test_sub-# PUBLICATION p1;
CREATE SUBSCRIPTION
</programlisting></para>

   <para>
    Insert some rows. Only the rows satisfying the <literal>t1 WHERE</literal>
    clause of publication <literal>p1</literal> are replicated.
<programlisting>
test_pub=# INSERT INTO t1 VALUES (2, 102, 'NSW');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (3, 103, 'QLD');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (4, 104, 'VIC');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (5, 105, 'ACT');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (6, 106, 'NSW');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (7, 107, 'NT');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (8, 108, 'QLD');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (9, 109, 'NSW');
INSERT 0 1

test_pub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 6 | 106 | NSW
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 6 | 106 | NSW
 9 | 109 | NSW
(2 rows)
</programlisting></para>

   <para>
    Update some data, where the old and new row values both
    satisfy the <literal>t1 WHERE</literal> clause of publication
    <literal>p1</literal>. The <command>UPDATE</command> replicates
    the change as normal.
<programlisting>
test_pub=# UPDATE t1 SET b = 999 WHERE a = 6;
UPDATE 1

test_pub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
 6 | 999 | NSW
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 9 | 109 | NSW
 6 | 999 | NSW
(2 rows)
</programlisting></para>

   <para>
    Update some data, where the old row values did not satisfy
    the <literal>t1 WHERE</literal> clause of publication <literal>p1</literal>,
    but the new row values do satisfy it. The <command>UPDATE</command> is
    transformed into an <command>INSERT</command> and the change is replicated.
    See the new row on the subscriber.
<programlisting>
test_pub=# UPDATE t1 SET a = 555 WHERE a = 2;
UPDATE 1

test_pub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(3 rows)
</programlisting></para>

   <para>
    Update some data, where the old row values satisfied
    the <literal>t1 WHERE</literal> clause of publication <literal>p1</literal>,
    but the new row values do not satisfy it. The <command>UPDATE</command> is
    transformed into a <command>DELETE</command> and the change is replicated.
    See that the row is removed from the subscriber.
<programlisting>
test_pub=# UPDATE t1 SET c = 'VIC' WHERE a = 9;
UPDATE 1

test_pub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   6 | 999 | NSW
 555 | 102 | NSW
   9 | 109 | VIC
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   6 | 999 | NSW
 555 | 102 | NSW
(2 rows)
</programlisting></para>

   <para>
    The following examples show how the publication parameter
    <literal>publish_via_partition_root</literal> determines whether the row
    filter of the parent or child table will be used in the case of partitioned
    tables.
   </para>

   <para>
    Create a partitioned table on the publisher.
<programlisting>
test_pub=# CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
CREATE TABLE
test_pub=# CREATE TABLE child PARTITION OF parent DEFAULT;
CREATE TABLE
</programlisting>
   Create the same tables on the subscriber.
<programlisting>
test_sub=# CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
CREATE TABLE
test_sub=# CREATE TABLE child PARTITION OF parent DEFAULT;
CREATE TABLE
</programlisting></para>

   <para>
    Create a publication <literal>p4</literal>, and then subscribe to it. The
    publication parameter <literal>publish_via_partition_root</literal> is set
    as true. There are row filters defined on both the partitioned table
    (<literal>parent</literal>), and on the partition (<literal>child</literal>).
<programlisting>
test_pub=# CREATE PUBLICATION p4 FOR TABLE parent WHERE (a &lt; 5), child WHERE (a >= 5)
test_pub-# WITH (publish_via_partition_root=true);
CREATE PUBLICATION
</programlisting>
<programlisting>
test_sub=# CREATE SUBSCRIPTION s4
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=s4'
test_sub-# PUBLICATION p4;
CREATE SUBSCRIPTION
</programlisting></para>

   <para>
    Insert some values directly into the <literal>parent</literal> and
    <literal>child</literal> tables. They replicate using the row filter of
    <literal>parent</literal> (because <literal>publish_via_partition_root</literal>
    is true).
<programlisting>
test_pub=# INSERT INTO parent VALUES (2), (4), (6);
INSERT 0 3
test_pub=# INSERT INTO child VALUES (3), (5), (7);
INSERT 0 3

test_pub=# SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
 5
 6
 7
(6 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
(3 rows)
</programlisting></para>

   <para>
    Repeat the same test, but with a different value for <literal>publish_via_partition_root</literal>.
    The publication parameter <literal>publish_via_partition_root</literal> is
    set as false. A row filter is defined on the partition (<literal>child</literal>).
<programlisting>
test_pub=# DROP PUBLICATION p4;
DROP PUBLICATION
test_pub=# CREATE PUBLICATION p4 FOR TABLE parent, child WHERE (a >= 5)
test_pub-# WITH (publish_via_partition_root=false);
CREATE PUBLICATION
</programlisting>
<programlisting>
test_sub=# ALTER SUBSCRIPTION s4 REFRESH PUBLICATION;
ALTER SUBSCRIPTION
</programlisting></para>

   <para>
    Do the inserts on the publisher same as before. They replicate using the
    row filter of <literal>child</literal> (because
    <literal>publish_via_partition_root</literal> is false).
<programlisting>
test_pub=# TRUNCATE parent;
TRUNCATE TABLE
test_pub=# INSERT INTO parent VALUES (2), (4), (6);
INSERT 0 3
test_pub=# INSERT INTO child VALUES (3), (5), (7);
INSERT 0 3

test_pub=# SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
 5
 6
 7
(6 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM child ORDER BY a;
 a
---
 5
 6
 7
(3 rows)
</programlisting></para>

  </sect2>

 </sect1>

 <sect1 id="logical-replication-conflicts">
  <title>Conflits</title>

  <para>
   La réplication logique se comporte de la même manière pour les
   opérations DML dans le sens où les données seront mises à jour même si
   la modification a été faite en local sur la base abonnée. Si les
   données entrantes entrainent des violations de contrainte d'intégrité,
   la réplication s'arrête. Cela sera référencé comme un
   <firstterm>conflit</firstterm>.
   Lorsque l'on réplique des opérations <command>UPDATE</command> ou
   <command>DELETE</command>, les données manquantes ne produiront pas
   de conflit et des opérations de la sorte seront simplement évitées.
  </para>

  <para>
   Logical replication operations are performed with the privileges of the role
   which owns the subscription.  Permissions failures on target tables will
   cause replication conflicts, as will enabled
   <link linkend="ddl-rowsecurity">row-level security</link> on target tables
   that the subscription owner is subject to, without regard to whether any
   policy would ordinarily reject the <command>INSERT</command>,
   <command>UPDATE</command>, <command>DELETE</command> or
   <command>TRUNCATE</command> which is being replicated.  This restriction on
   row-level security may be lifted in a future version of
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   Lorsqu'un conflit entraine une erreur, cela stoppe la réplication&nbsp;;
   Le conflit devra être résolu manuellement par un utilisateur. Des
   informations détaillées concernant le conflit seront disponibles dans
   les journaux d'erreurs de l'instance abonnée.
  </para>

  <para>
   La résolution peut être réalisée, soit en changeant les données ou les
   droits sur
   la base abonnée pour qu'elles ne soient plus en conflit avec les
   données entrantes ou en évitant les transactions qui sont en conflit
   avec les données existantes.
   When a conflict produces
   an error, the replication won't proceed, and the logical replication worker will
   emit the following kind of message to the subscriber's server log:
<screen>
ERROR:  duplicate key value violates unique constraint "test_pkey"
DETAIL:  Key (c)=(1) already exists.
CONTEXT:  processing remote data for replication origin "pg_16395" during "INSERT" for replication target relation "public.test" in transaction 725 finished at 0/14C0378
</screen>
   The LSN of the transaction that contains the change violating the constraint and
   the replication origin name can be found from the server log (LSN 0/14C0378 and
   replication origin <literal>pg_16395</literal> in the above case).  The
   transaction that produced the conflict can be skipped by using
   <command>ALTER SUBSCRIPTION ... SKIP</command> with the finish LSN
   (i.e., LSN 0/14C0378).  The finish LSN could be an LSN at which the transaction
   is committed or prepared on the publisher.  Alternatively, the transaction can
   also be skipped by calling the <link linkend="pg-replication-origin-advance">
   <function>pg_replication_origin_advance()</function></link> function.
   Before using this function, the subscription needs to be disabled temporarily
   either by <command>ALTER SUBSCRIPTION ... DISABLE</command> or, the
   subscription can be used with the <literal>disable_on_error</literal> option.
   Then, you can use <function>pg_replication_origin_advance()</function> function
   with the <parameter>node_name</parameter> (i.e., <literal>pg_16395</literal>)
   and the next LSN of the finish LSN (i.e., 0/14C0379).  The current position of
   origins can be seen in the <link linkend="view-pg-replication-origin-status">
   <structname>pg_replication_origin_status</structname></link> system view.
   Please note that skipping the whole transaction includes skipping changes that
   might not violate any constraint.  This can easily make the subscriber
   inconsistent.
  </para>
 </sect1>

 <sect1 id="logical-replication-restrictions">
  <title>Restrictions</title>

  <para>
   La réplication logique souffre actuellement des restrictions suivantes ou
   des fonctionnalités manquantes. Elles pourraient être adressées dans les
   prochaines versions.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     La structure de la base de données et les commandes DDL ne sont pas
     répliquées. Le schéma initial peut être copié à la main en utilisant la
     commande <literal>pg_dump --schema-only</literal>. Les modifications de
     schéma suivantes auront besoin d'être synchronisées manuellement. (Notez,
     néanmoins, qu'il n'est pas nécessaire que les schémas soient strictement
     identiques des deux côtés.) La réplication logique est robuste quand il y
     a des modifications de schéma dans une base de données. Quand le schéma
     est changé sur le publieur et les données répliquées commencent à arriver
     sur l'abonné mais ne correspondent pas à la structure de la table, la
     réplication renverra une erreur jusqu'à ce que le schéma soit mis à jour.
     Dans de nombreux cas, les erreurs intermittentes peuvent être évitées en
     appliquant des modifcations de schéma à l'abonné en premier.
    </para>
   </listitem>

   <listitem>
    <para>
     Les données des séquences ne sont pas répliquées. Les données des
     colonnes de type serial et des colonnes identité, gérées par des
     séquences, seront bien sûr répliquées comme faisant partie de la table,
     mais la séquence elle-même affichera toujours la valeur de démarrage sur
     l'abonné. Si l'abonné est utilisé comme une base de données en lecture
     seule, alors cela ne devrait pas être un problème. Néanmoins, s'il est
     nécessaire de faire un switchover ou un failover sur la base de données
     abonnée, alors les séquences auront besoin d'être mises à jour à leur
     dernières valeurs, soit en copiant les données courantes du publieur
     (peut-être en utilisant <command>pg_dump</command>), soit en déterminant
     une valeur suffisante haute à partir des données de la table.
    </para>
   </listitem>

   <listitem>
    <para>
     La réplication des commandes <command>TRUNCATE</command> est supportée
     mais il est nécessaire de prêter attention lors de l'utilisation de cette
     commande sur des groupes de tables connectés par des clés étrangères.
     Lors de la réplication d'une action truncate, l'abonné tronquera le même
     groupe de tables tronquées sur le publieur, qu'elles soient spécifiées
     explicitement ou implicitement (grâce à la clause
     <literal>CASCADE</literal>), moins les tables qui ne font pas partie de
     la souscription. Ceci fonctionnera correctement si toutes les tables
     affectées font partie de la même souscription. Cependant, si certaines
     tables à tronquer ont des clés étrangères vers des tables qui ne font pas
     partie de la même souscription, alors l'application de l'action truncate
     échouera sur le serveur abonné.
    </para>
   </listitem>

   <listitem>
    <para>
     Les Large Objects (voir <xref linkend="largeobjects"/>) ne sont pas
     répliqués. Il n'y a pas de contournement pour ça, en dehors d'enregistrer
     les données dans des tables normales.
    </para>
   </listitem>

   <listitem>
    <para>
     La réplication est seulement supportée par les tables, y compris les
     tables partitionnées. Toute tentative de répliquer d'autres types de
     relation, comme les vues, les vues matérialisées ou les tables externes,
     résultera en une erreur.
    </para>
   </listitem>

   <listitem>
    <para>
     Lors de la réplication entre tables partitionnées, la réplication
     actuelle a pour origine, par défaut, les partitions filles sur le
     publieur, donc les partitions sur le publieur doivent exister aussi sur
     l'abonné en tant que tables cibles valides. (Elles peuvent être soit des
     partitions filles elles-mêmes, soit de nouveau sous-partitionnées, soit
     des tables indépendantes.). Les publications peuvent aussi spécifier les
     changements à répliquer en utilisant l'identité et le schéma de la table
     racine partitionnée au lieu de chaque partition individuelle à l'origine
     des changements (voir <link linkend="sql-createpublication"><command>CREATE
     PUBLICATION</command></link>).
    </para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="logical-replication-architecture">
  <title>Architecture</title>

  <para>
   La réplication logique démarre en copiant un instantané des données
   sur la base de publication. Une fois cette étape réalisée, les
   modifications sur la base de publication sont envoyées à la base de
   données abonnée au fil de l'eau. La base abonnée applique les
   modifications sur les données dans l'ordre dans lequel les validations
   ont été effectuées sur la base éditeur de manière à ce que la
   cohérence transactionnelle soit respectée pour les publications vis à
   vis de tous les abonnements.
  </para>

  <para>
   La réplication se construit de façon similaire à la réplication
   physique continue (Streaming Replication)
   (voir <xref linkend="streaming-replication"/>).
   Ceci est implémenté par les processus <quote>walsender</quote> et
   <quote>apply</quote>.
   Le processus walsender démarre le décodage logique (décrit dans la
   section <xref linkend="protocol-logical-replication"/>) des fichiers
   WAL et charge le plugin de décodage logique standard (pgoutput).
   Ce plugin transforme les changements lus depuis les fichiers WAL vers
   le protocole de réplication logique
   (voir <xref linkend="protocol-logical-replication"/>)
   et filtre les données en fonction des spécificités des publications.
   Les données sont envoyées au fil de l'eau au processus apply, qui
   met en relation les données vers les tables locales et applique les
   changements individuels au moment où ils sont reçus, dans le bon ordre
   transactionnel.
  </para>

  <para>
   Le processus apply sur l'instance de la base abonnée fonctionne toujours
   avec le paramètre <varname>session_replication_role</varname> défini
   à la valeur <literal>replica</literal>, qui produit les effets habituels
   sur les triggers et les contraintes.
  </para>

  <para>
   Le processus apply de la réplication logique déclenche actuellement des
   triggers de ligne, et non pas des triggers de requêtes. Néanmoins, la
   synchronisation initiale des tables est implémentée comme une commande
   <command>COPY</command> ce qui peut déclencher les triggers
   <command>INSERT</command> en mode lignes et requêtes.
  </para>

  <sect2 id="logical-replication-snapshot">
   <title>Instantané initial</title>
   <para>
    Les données initiales présentes dans des tables abonnées sont
    photographiées et copiées dans une instance parallèle qui utilise un type
    particulier de processus apply. Ce processus va créer son propre slot de
    réplication et copier les données existantes. Dès que la copie est
    terminée, le contenu de la table deviendra visible aux autres processus.
    Une fois les données existantes copiées, le processus passe en mode de
    synchronisation, qui assure que la table est amenée vers un état
    synchronisé avec le processus apply principal, ceci en transférant toutes
    les modifications survenues pendant la copie initiale des données,
    réalisée avec le système de réplication logique standard. Lors de cette
    phase de synchronisation, les changements sont appliqués et validés dans
    le même ordre que sur le publieur. Une fois la synchronisation terminée,
    le contrôle de la réplication de la table est rendu au processus apply
    principal et la réplication continue telle quelle.
   </para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-monitoring">
  <title>Supervision</title>

  <para>
   Puisque la réplication logique est basée sur une architecture
   similaire à la
   <link linkend="streaming-replication">réplication physique en flux</link>,
   la supervision d'une instance publication est similaire à la
   supervision d'une instance primaire dans la réplication physique
   (voir <xref linkend="streaming-replication-monitoring"/>).
  </para>

  <para>
   Les informations des abonnements sont consultables dans la vue
   <link linkend="monitoring-pg-stat-subscription">
    <structname>pg_stat_subscription</structname></link>.
   Cette vue contient une ligne pour chaque processus d'abonnement. Un
   abonnement peut avoir zéro ou plusieurs processus abonnés selon son
   état.
  </para>

  <para>
   Normalement il y a un seul processus apply démarré pour
   un abonnement actif.
   Un abonnement désactivé ou une publication effondrée n'aura pas de
   ligne dans cette vue.
   Si la synchronisation initiale d'une table est en cours, il y aura des
   processus supplémentaires pour les tables en cours de synchronisation.
  </para>
 </sect1>

 <sect1 id="logical-replication-security">
  <title>Sécurité</title>

  <para>
   Un utilisateur capable de modifier le schéma des tables côté souscription
   peut exécuter un code arbitraire
   as the role which owns any subscription which modifies those tables.  Limit ownership
   and <literal>TRIGGER</literal> privilege on such tables to trusted roles.
   Moreover, if untrusted users can create tables, use only
   publications that list tables explicitly.  That is to say, create a
   subscription <literal>FOR ALL TABLES</literal> or
   <literal>FOR ALL TABLES IN SCHEMA</literal> only when superusers trust
   every user permitted to create a non-temp table on the publisher or the
   subscriber.
  </para>

  <para>
   Le rôle utilisée pour la réplication doit avoir l'attribut
   <literal>REPLICATION</literal> (ou être un super-utilisateur). Si le rôle ne
   dispose pas des attributs <literal>SUPERUSER</literal> et
   <literal>BYPASSRLS</literal>, les politiques de sécurité niveau ligne du
   publieur peuvent s'exécuter. Si le rôle n'a pas confiance en tous les
   propriétaires de tables, incluez
   <literal>options=-crow_security=off</literal> dans la chaîne de
   connexion&nbsp;;: si un propriétaire de table ajoute ensuite une politique
   de sécurité ligne, cette configuration imposera un arrêt de la réplication
   plutôt qu'une exécution de la politique. L'accès de ce rôle à l'instance
   doit avoir été déclaré dans <filename>pg_hba.conf</filename> et ce rôle
   doit avoir l'attribut <literal>LOGIN</literal>.
  </para>

  <para>
   Pour être capable de copier les données originales de la table, le rôle
   utilisé pour la connexion de réplication doit avoir le droit
   <literal>SELECT</literal> sur une table publiée (ou être un
   super-utilisateur).
  </para>

  <para>
   Pour créer une publication, l'utilisateur doit avoir le droit
   <literal>CREATE</literal> pour la base de données.
  </para>

  <para>
   Pour ajouter des tables à une publication, l'utilisateur doit être
   propriétaire de ces tables.  Pour ajouter toutes les tables d'un schéma dans
   une publication, l'utilisateur doit avoir l'attribut
   <literal>SUPERUSER</literal>.  Pour créer une publication qui publie toutes
   les tables ou toutes les tables d'un schéma automatiquement, l'utilisateur
   doit avoir l'attribut <literal>SUPERUSER</literal>.
  </para>

  <para>
   Pour créer un abonnement, l'utilisateur doit avoir les droits de super-utilisateur.
  </para>

  <para>
   Le processus apply lié à un abonnement tournera sur la base de données
   locale avec les droits d'un propriétaire de l'abonnement.
  </para>

  <para>
   On the publisher, privileges are only checked once at the start of a
   replication connection and are not re-checked as each change record is read.
  </para>

  <para>
   On the subscriber, the subscription owner's privileges are re-checked for
   each transaction when applied. If a worker is in the process of applying a
   transaction when the ownership of the subscription is changed by a
   concurrent transaction, the application of the current transaction will
   continue under the old owner's privileges.
  </para>
 </sect1>

 <sect1 id="logical-replication-config">
  <title>Paramètres de configuration</title>

  <para>
   La réplication logique requiert de nombreuses configurations pour
   fonctionner.
  </para>

  <para>
   Du côté de l'éditeur, <varname>wal_level</varname> doit être
   positionné à <literal>logical</literal>, et
   <varname>max_replication_slots</varname> doit être positionné au
   minimum au nombre d'abonnements que l'on va connecter, plus
   quelques-uns que l'on réservera pour les synchronisations des tables.
   Le paramètre <varname>max_wal_senders</varname> devrait être
   positionné au minimum à la même valeur que
   <varname>max_replication_slots</varname> en plus du nombre de réplicats
   physiques qui pourraient être connectés au même moment.
  </para>

  <para>
   <varname>max_replication_slots</varname> doit aussi être configuré sur
   l'abonné. Il doit être configuré à au moins la valeur du nombre de
   souscriptions qui seront ajoutés par le souscripteur, plus une réserve
   pour la synchronisation des tables.
   <varname>max_logical_replication_workers</varname> doit être configuré à
   au moins la valeur du nombre de souscriptions, plus, là-aussi, une réserve
   pour la synchronisation des tables. En supplément, le paramètre
   <varname>max_worker_processes</varname> peut devoir être ajusté pour
   s'accorder au nombre de processus de réplication,
   (<varname>max_logical_replication_workers</varname>
   + <literal>1</literal>). Notez que certaines extensions et les requêtes
   parallélisées prennent elles aussi des unités de la réserve de
   <varname>max_worker_processes</varname>.
  </para>
 </sect1>

 <sect1 id="logical-replication-quick-setup">
  <title>Démarrage rapide</title>

  <para>
   En premier, définissez les options de configurations dans le fichier
   <filename>postgresql.conf</filename>&nbsp;:
   <programlisting>
wal_level = logical
   </programlisting>
   La valeur par défaut des autres paramètres est suffisante pour une
   mise en place de base.
  </para>

  <para>
   Le fichier <filename>pg_hba.conf</filename> doit être mis à jour pour
   autoriser la réplication (les valeurs dépendent de la configuration
   réelle de votre réseau et de l'utilisateur dont vous disposerez pour
   vous connecter)&nbsp;:
   <programlisting>
host     all     repuser     0.0.0.0/0     md5
   </programlisting>
  </para>

  <para>
   Ensuite sur la base de l'éditeur&nbsp;:
   <programlisting>
CREATE PUBLICATION mypub FOR TABLE users, departments;
   </programlisting>
  </para>

  <para>
   Et sur la base abonnée&nbsp;:
   <programlisting>
CREATE SUBSCRIPTION mysub CONNECTION 'dbname=foo host=bar user=repuser' PUBLICATION mypub;
   </programlisting>
  </para>

  <para>
   Les instructions précédentes vont démarrer le processus de réplication,
   qui va réaliser la synchronisation initiale du contenu des tables
   <literal>users</literal> et <literal>departments</literal> et
   qui commencera ensuite à répliquer les changements de manière incrémentale
   sur ces tables.
  </para>
 </sect1>
</chapter>
