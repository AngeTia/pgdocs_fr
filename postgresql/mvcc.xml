<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

 <chapter id="mvcc">
  <title>Contrôle d'accès simultané</title>

  <indexterm>
   <primary>concurrence</primary>
  </indexterm>

  <para>
   Ce chapitre décrit le comportement de <productname>PostgreSQL</productname>
   lorsque deux sessions, ou plus, essaient d'accéder aux mêmes données au
   même moment. Le but dans cette situation est de permettre un accès
   efficace pour toutes les sessions tout en maintenant une intégrité stricte
   des données. Chaque développeur d'applications utilisant des bases de
   données doit avoir une bonne compréhension des thèmes couverts dans ce
   chapitre.
  </para>

  <sect1 id="mvcc-intro">
   <title>Introduction</title>

   <indexterm>
    <primary>Multiversion Concurrency Control</primary>
   </indexterm>

   <indexterm>
    <primary>MVCC</primary>
   </indexterm>

   <indexterm>
    <primary>Serializable Snapshot Isolation</primary>
   </indexterm>

   <indexterm>
    <primary>SSI</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> fournit un ensemble d'outils
    pour les développeurs qui souhaitent gérer des accès simulatnés aux données.
    En interne, la cohérence des données est obtenue avec l'utilisation d'un
    modèle multiversion (Multiversion Concurrency Control, <acronym>MVCC</acronym>).
    Ceci signifie que, lors de l'envoi d'une requête à la
    base de données, chaque transaction voit une image des données (une
    <firstterm>version de la base de données</firstterm>) telle qu'elles
    étaient quelque temps auparavant, quel que soit l'état actuel des données
    sous-jacentes. Ceci protège la transaction de données incohérentes,
    causées par des mises à jour effectuées par une (autre) transaction
    simultanée sur les mêmes lignes de données, fournissant ainsi une
    <firstterm>isolation des transactions</firstterm> pour chaque session de la
    base de données. <acronym>MVCC</acronym>, en évitant les méthodes des verrous
    des systèmes de bases de données traditionnels, minimise la
    durée des verrous pour permettre des performances raisonnables dans
    des environnements multiutilisateurs.
   </para>

   <para>
    Le principal avantage de l'utilisation du modèle <acronym>MVCC</acronym> 
    pour le contrôle des accès simultanés, contrairement au verrouillage, est que, dans
    les verrous acquis par <acronym>MVCC</acronym> pour récupérer (en lecture)
    des données, aucun conflit n'intervient avec les verrous acquis pour écrire
    des données. Du coup, lire ne bloque jamais l'écriture et écrire ne bloque
    jamais la lecture.
    <productname>PostgreSQL</productname> maintains this guarantee
    even when providing the strictest level of transaction
    isolation through the use of an innovative <firstterm>Serializable
    Snapshot Isolation</firstterm> (<acronym>SSI</acronym>) level.
   </para>

   <para>
    Des possibilités de verrouillage des tables ou des lignes sont aussi disponibles
    dans <productname>PostgreSQL</productname> pour les applications which don't
    generally need full transaction isolation and prefer to explicitly
    manage particular points of conflict. Néanmoins,
    un bon usage de <acronym>MVCC</acronym> fournira généralement de
    meilleures performances que les verrous. De plus, les verrous informatifs
    définis par l'utilisateur fournissent un mécanisme d'acquisition de verrous
    qui n'est pas lié à une transaction.
   </para>
  </sect1>

  <sect1 id="transaction-iso">
   <title>Isolation des transactions</title>

   <indexterm>
    <primary>isolation des transactions</primary>
   </indexterm>

   <para>
    Le standard <acronym>SQL</acronym> définit quatre niveaux d'isolation de
    transaction.  The most strict is Serializable,
    which is defined by the standard in a paragraph which says that any
    concurrent execution of a set of Serializable transactions is guaranteed
    to produce the same effect as running them one at a time in some order.
    The other three levels are defined in terms of phenomena, resulting from
    interaction between concurrent transactions, which must not occur at
    each level.  The standard notes that due to the definition of
    Serializable, none of these phenomena are possible at that level.  (This
    is hardly surprising -- if the effect of the transactions must be
    consistent with having been run one at a time, how could you see any
    phenomena caused by interactions?)
   </para>

   <para>
    The phenomena which are prohibited are various levels are:

    <variablelist>
     <varlistentry>
      <term>
       lecture sale
       <indexterm><primary>lecture sale</primary></indexterm>
      </term>
     <listitem>
      <para>
	Une transaction lit des données écrites par une transaction concurrente
	non validée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       lecture non reproductible
       <indexterm><primary>lecture non reproductible</primary></indexterm>
      </term>
     <listitem>
      <para>
	Une transaction relit des données qu'elle a lu
	précédemment et trouve que les données ont été modifiées par une autre
	transaction (validée depuis la lecture initiale).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       lecture fantôme
       <indexterm><primary>lecture fantôme</primary></indexterm>
      </term>
     <listitem>
      <para>
	Une transaction ré-exécute une requête renvoyant un ensemble de lignes
	satisfaisant une condition de recherche et trouve que l'ensemble des
	lignes satisfaisant la condition a changé du fait d'une autre transaction
	récemment validée.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    <indexterm>
     <primary>niveau d'isolation de transaction</primary>
    </indexterm>
    Les quatre niveaux d'isolation de transaction et les comportements
    correspondants sont décrits dans le <xref linkend="mvcc-isolevel-table"/>.
   </para>

    <table tocentry="1" id="mvcc-isolevel-table">
     <title>Niveaux d'isolation des transactions <acronym>SQL</acronym></title>
     <tgroup cols="4">
     <colspec colnum="1" colwidth="2.2*"/>
     <colspec colnum="2" colwidth="0.6*"/>
     <colspec colnum="3" colwidth="0.6*"/>
     <colspec colnum="4" colwidth="0.6*"/>
      <thead>
       <row>
	<entry>
         Niveau d'isolation
	</entry>
	<entry>
	 Lecture sale
	</entry>
	<entry>
	 Lecture non reproductible
	</entry>
	<entry>
	 Lecture fantôme
	</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>
	 Uncommited Read (en français, <quote>Lecture de données non validées</quote>)
	</entry>
	<entry>
	 Possible
	</entry>
	<entry>
	 Possible
	</entry>
	<entry>
	 Possible
	</entry>
       </row>

       <row>
	<entry>
	 Commited Read (en français, <quote>Lecture de données validées</quote>)
	</entry>
	<entry>
	 Impossible
	</entry>
	<entry>
	 Possible
	</entry>
	<entry>
	 Possible
	</entry>
       </row>

       <row>
	<entry>
	 Repeatable Read (en français, <quote>Lecture répétée</quote>)
	</entry>
	<entry>
	 Impossible
	</entry>
	<entry>
	 Impossible
	</entry>
	<entry>
	 Possible
	</entry>
       </row>

       <row>
	<entry>
	 Serializable (en français, <quote>Sérialisable</quote>)
	</entry>
	<entry>
	 Impossible
	</entry>
	<entry>
	 Impossible
	</entry>
	<entry>
	 Impossible
	</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
    Dans <productname>PostgreSQL</productname>, vous pouvez demander un des
    quatre niveaux standards d'isolation de transaction. Mais, en interne,
    il existe seulement trois niveaux distincts d'isolation, qui correspondent
    aux niveaux Read Committed et Repeatable Read, and Serializable. Lorsque vous sélectionnez le
    niveau Read Uncommitted, vous obtenez réellement Read Committe, and phantom reads are not possible
    in the <productname>PostgreSQL</productname> implementation of Repeatable
    Read
    donc le niveau d'isolation actuel pourrait être plus strict que ce que vous
    sélectionnez. Ceci est permis par le standard SQL. Les quatre niveaux
    d'isolation définissent seulement quel phénomène ne doit pas survenir, ils
    ne définissent pas ce qui doit arriver. La raison pour laquelle
    <productname>PostgreSQL</productname> fournit seulement trois niveaux d'isolation est
    qu'il s'agit de la seule façon raisonnable de faire correspondre les niveaux
    d'isolation standards avec l'architecture de contrôle des accès simultanés
    multiversion. Le comportement des niveaux standards d'isolation est détaillé
    dans les sous-sections suivantes.
    </para>

    <para>
    Pour initialiser le niveau d'isolation d'une transaction, utilisez la
    commande <xref linkend="sql-set-transaction"/>.
    </para>

  <sect2 id="xact-read-committed">
   <title>Niveau d'isolation Read committed (lecture uniquement des données validées)</title>

   <indexterm>
    <primary>niveau d'isolation de transaction</primary>
    <secondary>lecture validée</secondary>
   </indexterm>

   <indexterm>
    <primary>read committed</primary>
   </indexterm>

   <para>
    <firstterm>Read Committed</firstterm> est le niveau d'isolation par défaut
    dans <productname>PostgreSQL</productname>. Quand une transaction utilise
    ce niveau d'isolation, une requête <command>SELECT</command> (sans clause
    <literal>FOR UPDATE/SHARE</literal>) voit seulement les données validées
    avant le début de la requête&nbsp;; il ne voit jamais les données non
    validées et les modifications validées pendant l'exécution de la requête
    par des transactions exécutées en parallèle. En effet, une requête
    <command>SELECT</command> voit une image de la base de données datant du
    moment où l'exécution de la requête commence. Néanmoins,
    <command>SELECT</command> voit les effets de mises à jour précédentes
    exécutées dans sa propre transaction, même si celles-ci n'ont pas encore
    été validées. De plus, notez que deux commandes <command>SELECT</command>
    successives peuvent voir des données différentes, même si elles sont
    exécutées dans la même transaction si d'autres transactions valident des
    modifications pendant l'exécution du premier <command>SELECT</command>.
   </para>

   <para>
    Les commandes <command>UPDATE</command>, <command>DELETE</command>,
    <command>SELECT FOR UPDATE</command> et <command>SELECT FOR SHARE</command>
    se comportent de la même façon que
    <command>SELECT</command> en ce qui concerne la recherche des lignes
    cibles&nbsp;: elles ne trouveront que les lignes cibles qui ont été validées
    avant le début de la commande. Néanmoins, une telle ligne cible pourrait
    avoir déjà été mise à jour (ou supprimée ou verrouillée) par
    une autre transaction concurrente au moment où elle est découverte. Dans ce
    cas, le processus de mise à jour attendra que la première transaction 
    soit validée ou annulée (si elle est toujours en cours). Si la
    première mise à jour est annulée, alors ses effets sont niés et le
    deuxième processus peut exécuter la mise à jour des lignes originellement
    trouvées. Si la première mise à jour est validée, la deuxième mise à jour
    ignorera la ligne si la première mise à jour l'a supprimée, sinon elle
    essaiera d'appliquer son opération à la version mise à jour de la ligne. La
    condition de la recherche de la commande (la clause <literal>WHERE</literal>) est
    ré-évaluée pour savoir si la version mise à jour de la ligne correspond
    toujours à la condition de recherche. Dans ce cas, la deuxième mise à jour
    continue son opération en utilisant la version mise à jour de la
    ligne. Dans le cas des commandes <command>SELECT FOR UPDATE</command> et
    <command>SELECT FOR SHARE</command>, cela signifie que la version mise à
    jour de la ligne est verrouillée et renvoyée au client.
   </para>

   <para>
    À cause de la règle ci-dessus, une commande de mise à jour a la
    possibilité de voir une image non cohérente&nbsp;: elle peut voir les effets
    de commandes de mises à jour concurrentes sur les mêmes lignes que
    celles qu'elle essaie de mettre à jour mais elle ne voit pas les effets de
    ces commandes sur les autres lignes de la base de données. Ce comportement
    rend le mode de lecture validée non convenable pour les commandes qui
    impliquent des conditions de recherche complexes&nbsp;; néanmoins, il est
    intéressant pour
    les cas simples. Par exemple, considérons la mise à jour de balances de
    banque avec des transactions comme&nbsp;:

<screen>BEGIN;
UPDATE comptes SET balance = balance + 100.00 WHERE no_compte = 12345;
UPDATE comptes SET balance = balance - 100.00 WHERE no_compte = 7534;
COMMIT;</screen>

    Si deux transactions comme celle-ci essaient de modifier en même temps la balance du
    compte 12345, nous voulons clairement que la deuxième transaction commence à
    partir de la version mise à jour de la ligne du compte. Comme chaque commande 
    n'affecte qu'une ligne prédéterminée, la laisser voir la
    version mise à jour de la ligne ne crée pas de soucis de cohérence.
   </para>

   <para>
    Des utilisations plus complexes peuvent produire des résultats non désirés
    dans le mode Read Committed. Par exemple, considérez une commande
    <command>DELETE</command> opérant sur des données qui sont à la fois ajoutées
    et supprimées du critère de restriction par une autre commande. Supposons que
    <literal>website</literal> est une table sur deux lignes avec
    <literal>website.hits</literal> valant <literal>9</literal> et
    <literal>10</literal>&nbsp;:

<screen>
BEGIN;
UPDATE website SET hits = hits + 1;
-- exécuté par une autre session :  DELETE FROM website WHERE hits = 10;
COMMIT;
</screen>

    La commande <command>DELETE</command> n'aura pas d'effet même s'il existe
    une ligne <literal>website.hits = 10</literal> avant et après la commande
    <command>UPDATE</command>. Cela survient parce que la valeur
    <literal>9</literal> de la ligne avant mise à jour est ignorée et que
    lorsque l'<command>UPDATE</command> termine et que <command>DELETE</command>
    obtient un verrou, la nouvelle valeur de la ligne n'est plus
    <literal>10</literal>, mais <literal>11</literal>, ce qui ne correspond
    plus au critère.
   </para>

   <para>
    Comme le mode Read Committed commence chaque commande avec une nouvelle
    image qui inclut toutes les transactions validées jusqu'à cet instant,
    les commandes suivantes dans la même transaction verront les effets de
    la transaction validée en parallèle dans tous les cas. Le problème en
    question est de savoir si une <emphasis>seule</emphasis> commande voit
    une vue absolument cohérente ou non de la base de données.
   </para>

   <para>
    L'isolation partielle des transactions fournie par le mode Read Committed
    est adéquate pour de nombreuses applications, et ce mode est rapide et
    simple à utiliser. Néanmoins, il n'est pas suffisant dans tous les cas.
    Les applications qui exécutent des requêtes et des mises à jour complexes
    pourraient avoir besoin d'une vue plus rigouresement cohérente de la base
    de données, une vue que le mode Read Committed ne fournit pas.
   </para>
  </sect2>

  <sect2 id="xact-repeatable-read">
   <title>Repeatable Read Isolation Level</title>

   <indexterm>
    <primary>niveau d'isolation de transaction</primary>
    <secondary>repeatable read</secondary>
   </indexterm>

   <indexterm>
    <primary>repeatable read</primary>
   </indexterm>

   <para>
    The <firstterm>Repeatable Read</firstterm> isolation level only sees
    data committed before the transaction began; it never sees either
    uncommitted data or changes committed during transaction execution
    by concurrent transactions.  (However, the query does see the
    effects of previous updates executed within its own transaction,
    even though they are not yet committed.)  This is a stronger
    guarantee than is required by the <acronym>SQL</acronym> standard
    for this isolation level, and prevents all of the phenomena described
    in <xref linkend="mvcc-isolevel-table">.  As mentioned above, this is
    specifically allowed by the standard, which only describes the
    <emphasis>minimum</emphasis> protections each isolation level must
    provide.
   </para>

   <para>
    This level is different from Read Committed in that a query in a
    repeatable read transaction sees a snapshot as of the start of the
    <emphasis>transaction</>,
    et non pas du début de la requête en cours à l'intérieur de la transaction.
    Du coup, les commandes <command>SELECT</command> successives à l'intérieur
    d'une <emphasis>seule</emphasis> transaction voient toujours les mêmes données,
    c'est-à-dire qu'elles ne voient jamais les modifications faites par les autres
    transactions qui ont validé après le début de leur propre transaction.
   </para>

   <para>
    Applications using this level must be prepared to retry transactions
    due to serialization failures.
   </para>

   <para>
    Les commandes <command>UPDATE</command>, <command>DELETE</command>,
    <command>SELECT FOR UPDATE</command> et <command>SELECT FOR SHARE</command>
    se comportent de la même façon que
    <command>SELECT</command> en ce qui concerne la recherche de lignes
    cibles&nbsp;: elles trouveront seulement les lignes cibles qui ont été
    validées avant le début de la transaction. Néanmoins, une telle ligne cible
    pourrait avoir été mise à jour (ou supprimée ou verrouillée)
    par une autre transaction concurrente au moment où elle est utilisée. Dans
    ce cas, la transaction repeatable read attendra que la première transaction de
    mise à jour soit validée ou annulée (si celle-ci est toujours en
    cours). Si la première mise à jour est annulée, les effets sont inversés et
    la transaction repeatable read peut continuer avec la mise à jour de la ligne
    trouvée à l'origine. Mais si la mise à jour est validée (et que
    la ligne est mise à jour ou supprimée, pas simplement verrouillée),
    alors la transaction repeatable read sera annulée avec le message

<screen>ERROR:  could not serialize access due to concurrent update</screen>

    parce qu'une transaction sérialisable ne peut pas modifier ou verrouiller
    les lignes changées par d'autres transactions après que la transaction
    sérialisable ait commencé.
   </para>

   <para>
    Quand une application reçoit ce message d'erreurs, elle devrait annuler la
    transaction actuelle et ré-essayer la transaction complète. La seconde fois,
    la transaction voit les modifications déjà validées comme faisant partie de
    sa vue initiale de la base de données, donc il n'y a pas de conflit logique
    en utilisant la nouvelle version de la ligne comme point de départ pour la
    mise à jour de la nouvelle transaction.
   </para>

   <para>
    Notez que seules les transactions de modifications ont besoin d'être
    tentées de nouveau&nbsp;; les transactions en lecture seule n'auront jamais
    de conflits de sérialisation.
   </para>

   <para>
    The Repeatable Read mode provides a rigorous guarantee that each
    transaction sees a completely stable view of the database.  However,
    this view will not necessarily always be consistent with some serial
    (one at a time) execution of concurrent transactions of the same level.
    For example, even a read only transaction at this level may see a
    control record updated to show that a batch has been completed but
    <emphasis>not</emphasis> see one of the detail records which is logically
    part of the batch because it read an earlier revision of the control
    record.  Attempts to enforce business rules by transactions running at
    this isolation level are not likely to work correctly without careful use
    of explicit locks to block conflicting transactions.
   </para>

   <note>
    <para>
     Prior to <productname>PostgreSQL</productname> version 9.1, a request
     for the Serializable transaction isolation level provided exactly the
     same behavior described here.  To retain the legacy Serializable
     behavior, Repeatable Read should now be requested.
    </para>
   </note>
  </sect2>

  <sect2 id="xact-serializable">
   <title>Serializable Isolation Level</title>

   <indexterm>
    <primary>transaction isolation level</primary>
    <secondary>serializable</secondary>
   </indexterm>
 
    <indexterm>
    <primary>serializable</primary>
    </indexterm>
 
    <indexterm>
     <primary>predicate locking</primary>
    </indexterm>
 
   <indexterm>
    <primary>serialization anomaly</primary>
   </indexterm>

     <para>
    The <firstterm>Serializable</firstterm> isolation level provides the strictest transaction
    isolation.  This level emulates serial transaction execution,
    as if transactions had been executed one after another, serially,
    rather than concurrently.  However, like the Repeatable Read level,
    applications using this level must
    be prepared to retry transactions due to serialization failures.
    In fact, this isolation level works exactly the same as Repeatable
    Read except that it monitors for conditions which could make
    execution of a concurrent set of serializable transactions behave
    in a manner inconsistent with all possible serial (one at a time)
    executions of those transactions.  This monitoring does not
    introduce any blocking beyond that present in repeatable read, but
    there is some overhead to the monitoring, and detection of the
    conditions which could cause a
    <firstterm>serialization anomaly</firstterm> will trigger a
    <firstterm>serialization failure</firstterm>.
   </para>

   <para>
      Comme exemple, considérez
      la table <structname>ma_table</structname>, contenant initialement
   <screen> classe | valeur
--------+-------
     1  |    10
     1  |    20
     2  |   100
     2  |   200</screen>
      Supposons que la transaction sérialisable A traite
   <screen>SELECT SUM(valeur) FROM ma_table WHERE classe = 1;</screen>
      puis insère le résultat (30) comme <structfield>valeur</structfield> dans une
      nouvelle ligne avec <structfield>classe</structfield> <literal>= 2</literal>. Simultanément, la
      transaction serialisable B traite
<screen>SELECT SUM(valeur) FROM ma_table WHERE classe = 2;</screen>
      et obtient le résultat 300, qu'il insère dans une nouvelle ligne avec
      <structfield>classe</structfield> <literal>= 1</literal>.  Then both transactions try to commit.
    If either transaction were running at the Repeatable Read isolation level,
    both would be allowed to commit; but since there is no serial order of execution
    consistent with the result, using Serializable transactions will allow one
    transaction to commit and and will roll the other back with this message:

<screen>
ERROR:  could not serialize access due to read/write dependencies among transactions
</screen>

    This is because si A a été exécuté avant B, B aurait trouvé la somme 330, et non pas 300.
      De façon similaire, l'autre ordre aurait eu comme résultat une somme
      différente pour le calcul par A.
     </para>

     <para>
    To guarantee true serializability <productname>PostgreSQL</productname>
    uses <firstterm>predicate locking</>, which means that it keeps locks
    which allow it to determine when a write would have had an impact on
    the result of a previous read from a concurrent transaction, had it run
    first.  In <productname>PostgreSQL</productname> these locks do not
    cause any blocking and therefore can <emphasis>not</> play any part in
    causing a deadlock.  They are used to identify and flag dependencies
    among concurrent serializable transactions which in certain combinations
    can lead to serialization anomalies.  In contrast, a Read Committed or
    Repeatable Read transaction which wants to ensure data consistency may
    need to take out a lock on an entire table, which could block other
    users attempting to use that table, or it may use <literal>SELECT FOR
    UPDATE</literal> or <literal>SELECT FOR SHARE</literal> which not only
    can block other transactions but cause disk access.
   </para>

   <para>
    Predicate locks in <productname>PostgreSQL</productname>, like in most
    other database systems, are based on data actually accessed by a
    transaction.  These will show up in the
    <link linkend="view-pg-locks"><structname>pg_locks</structname></link>
    system view with a <literal>mode</> of <literal>SIReadLock</>.  The
    particular locks
    acquired during execution of a query will depend on the plan used by
    the query, and multiple finer-grained locks (e.g., tuple locks) may be
    combined into fewer coarser-grained locks (e.g., page locks) during the
    course of the transaction to prevent exhaustion of the memory used to
    track the locks.  A <literal>READ ONLY</> transaction may be able to
    release its SIRead locks before completion, if it detects that no
    conflicts can still occur which could lead to a serialization anomaly.
    In fact, <literal>READ ONLY</> transactions will often be able to
    establish that fact at startup and avoid taking any predicate locks.
    If you explicitly request a <literal>SERIALIZABLE READ ONLY DEFERRABLE</>
    transaction, it will block until it can establish this fact.  (This is
    the <emphasis>only</> case where Serializable transactions block but
    Repeatable Read transactions don't.)  On the other hand, SIRead locks
    often need to be kept past transaction commit, until overlapping read
    write transactions complete.
    </para>
 
    <para>
    Consistent use of Serializable transactions can simplify development.
    The guarantee that any set of concurrent serializable transactions will
    have the same effect as if they were run one at a time means that if
    you can demonstrate that a single transaction, as written, will do the
    right thing when run by itself, you can have confidence that it will
    do the right thing in any mix of serializable transactions, even without
    any information about what those other transactions might do.  It is
    important that an environment which uses this technique have a
    generalized way of handling serialization failures (which always return
    with a SQLSTATE value of '40001'), because it will be very hard to
    predict exactly which transactions might contribute to the read/write
    dependencies and need to be rolled back to prevent serialization
    anomalies.  The monitoring of read/write dependences has a cost, as does
    the restart of transactions which are terminated with a serialization
    failure, but balanced against the cost and blocking involved in use of
    explicit locks and <literal>SELECT FOR UPDATE</> or <literal>SELECT FOR
    SHARE</>, Serializable transactions are the best performance choice
    for some environments.
    </para>

   <para>
    For optimal performance when relying on Serializable transactions for
    concurrency control, these issues should be considered:

    <itemizedlist>
     <listitem>
      <para>
       Declare transactions as <literal>READ ONLY</> when possible.
      </para>
     </listitem>
     <listitem>
      <para>
       Control the number of active connections, using a connection pool if
       needed.  This is always an important performance consideration, but
       it can be particularly important in a busy system using Serializable
       transactions.
      </para>
     </listitem>
     <listitem>
      <para>
       Don't put more into a single transaction than needed for integrity
       purposes.
      </para>
     </listitem>
     <listitem>
      <para>
       Don't leave connections dangling <quote>idle in transaction</quote>
       longer than necessary.
      </para>
     </listitem>
     <listitem>
      <para>
       Eliminate explicit locks, <literal>SELECT FOR UPDATE</>, and
       <literal>SELECT FOR SHARE</> where no longer needed due to the
       protections automatically provided by Serializable transactions.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <warning>
    <para>
     Support for the Serializable transaction isolation level has not yet
     been added to Hot Standby replication targets (described in
     <xref linkend="hot-standby">).  The strictest isolation level currently
     supported in hot standby mode is Repeatable Read.  While performing all
     permanent database writes within Serializable transactions on the
     master will ensure that all standbys will eventually reach a consistent
     state, a Repeatable Read transaction run on the standby can sometimes
     see a transient state which is inconsistent with any serial execution
     of serializable transactions on the master.
    </para>
   </warning>
  </sect2>
 </sect1>

  <sect1 id="explicit-locking">
   <title>Verrouillage explicite</title>

   <indexterm>
    <primary>verrou</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> fournit de nombreux modes de verrous
    pour contrôler les accès simultanés aux données des tables. Ces modes
    peuvent être utilisés pour contrôler le verrouillage par l'application dans
    des situations où <acronym>MVCC</acronym> n'a pas le comportement désiré. De
    plus, la plupart des commandes <productname>PostgreSQL</productname>
    acquièrent automatiquement des verrous avec les modes appropriés pour
    s'assurer que les tables référencées ne sont pas supprimées ou modifiées de
    façon incompatible lorsque la commande s'exécute (par exemple,
    <command>TRUNCATE</command> ne peut pas être exécuté de façon sûr en
    même temps que d'autres opérations sur la même table, donc il obtient un
    verrou exclusif sur la table pour s'assurer d'une bonne exécution).
   </para>

   <para>
    Pour examiner une liste des verrous en cours, utilisez la vue système <link
    linkend="view-pg-locks"><structname>pg_locks</structname></link>. Pour plus
    d'informations sur la surveillance du statut du sous-système de gestion des
    verrous, référez-vous au <xref linkend="monitoring"/>.
   </para>

  <sect2 id="locking-tables">
   <title>Verrous de niveau table</title>

   <indexterm zone="locking-tables">
    <primary>LOCK</primary>
   </indexterm>

   <para>
    La liste ci-dessous affiche les modes de verrous disponibles et les
    contextes dans lesquels ils sont automatiquement utilisés par
    <productname>PostgreSQL</productname>. Vous pouvez aussi acquérir
    explicitement n'importe lequel de ces verrous avec la commande <xref
    linkend="sql-lock"/>. Rappelez-vous que tous ces modes de
    verrous sont des verrous au niveau table, même si le nom contient le mot
    <quote>row</quote> (NdT&nbsp;: ligne)&nbsp;; les noms des modes de verrous
    sont historiques. Dans une certaine mesure, les noms reflètent l'utilisation
    typique de chaque mode de verrou &mdash; mais la sémantique est identique. La
    seule vraie différence entre un mode verrou et un autre est l'ensemble des
    modes verrous avec lesquels ils rentrent en conflit
    (voir <xref linkend="table-lock-compatibility"/>). Deux transactions ne
    peuvent pas conserver des verrous de modes en conflit sur la même table au
    même moment (néanmoins, une transaction n'entre jamais en conflit avec
    elle-même. Par exemple, elle pourrait acquérir un verrou <literal>ACCESS
    EXCLUSIVE</literal> et acquérir plus tard un verrou <literal>ACCESS
    SHARE</literal> sur la même table). Des modes de verrou sans conflit
    peuvent être détenus en même temps par plusieurs transactions. Notez, en
    particulier, que certains modes de verrous sont en conflit avec eux-même (par
    exemple, un verrou <literal>ACCESS EXCLUSIVE</literal> ne peut pas être
    détenu par plus d'une transaction à la fois) alors que d'autres n'entrent
    pas en conflit avec eux-même (par exemple, un verrou <literal>ACCESS
    SHARE</literal> peut être détenu par plusieurs transactions).
   </para>

     <variablelist>
      <title>Modes de verrous au niveau table</title>
      <varlistentry>
       <term>
	<literal>ACCESS SHARE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec le mode verrou <literal>ACCESS EXCLUSIVE</literal>.
	</para>

	<para>
	 Les commandes <command>SELECT</command> acquièrent un verrou de ce
	 mode avec les tables référencées. En général, tout requête <emphasis>lisant</emphasis>
	 seulement une table et ne la modifiant pas obtient ce mode de verrou.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>ROW SHARE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>EXCLUSIVE</literal> et
	 <literal>ACCESS EXCLUSIVE</literal>.
	</para>

	<para>
	 La commande <command>SELECT FOR UPDATE</command> et <command>SELECT
	 FOR SHARE</command> acquièrent un verrou de ce mode
	 avec la table cible (en plus des verrous <literal>ACCESS
	 SHARE</literal> des autres tables référencées mais pas
	 sélectionnées <option>FOR UPDATE/FOR SHARE</option>).
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>ROW EXCLUSIVE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>SHARE</literal>,
	 <literal>SHARE ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>
	 et <literal>ACCESS EXCLUSIVE</literal>.
	</para>

	<para>
	 Les commandes <command>UPDATE</command>,
	 <command>DELETE</command> et <command>INSERT</command> acquièrent ce
	 mode de verrou sur la table cible (en plus des verrous <literal>ACCESS
	 SHARE</literal> sur toutes les autres tables référencées). En général,
	 ce mode de verrouillage sera acquis par toute commande <emphasis>modifiant</emphasis> des
	 données de la table.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>SHARE UPDATE EXCLUSIVE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>SHARE UPDATE
	 EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE ROW
	 EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
	 <literal>ACCESS EXCLUSIVE</literal>. Ce mode protège une table contre
	 les modifications simultanées de schéma et l'exécution d'un
	 <command>VACUUM</command>.
	</para>

	<para>
	 Acquis par <command>VACUUM</command> (sans <option>FULL</option>),
	 <command>ANALYZE</command>, <command>CREATE INDEX CONCURRENTLY</command>, and
     some forms of <command>ALTER TABLE</command>.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>SHARE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>ROW EXCLUSIVE</literal>,
         <literal>SHARE UPDATE EXCLUSIVE</literal>, <literal>SHARE ROW
         EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
         <literal>ACCESS EXCLUSIVE</literal>. Ce mode protège une table
	 contre les modifications simultanées des données.
	</para>

	<para>
	 Acquis par <command>CREATE INDEX</command> (sans <option>CONCURRENTLY</option>).
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>SHARE ROW EXCLUSIVE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>ROW EXCLUSIVE</literal>,
         <literal>SHARE UPDATE EXCLUSIVE</literal>,
         <literal>SHARE</literal>, <literal>SHARE ROW
         EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
         <literal>ACCESS EXCLUSIVE</literal>.
         This mode protects a table against concurrent data changes, and
         is self-exclusive so that only one session can hold it at a time.
	</para>

	<para>
         Acquired by <command>CREATE TRIGGER</command>,
         <command>CREATE RULE</command> (except for <literal>ON SELECT</>
         rules) and some forms of <command>ALTER TABLE</command>.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>EXCLUSIVE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>ROW SHARE</literal>,
	 <literal>ROW EXCLUSIVE</literal>, <literal>SHARE UPDATE
         EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE
         ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
         <literal>ACCESS EXCLUSIVE</literal>. Ce mode autorise uniquement les
	 verrous <literal>ACCESS SHARE</literal> concurrents, c'est-à-dire que
	 seules les lectures à partir de la table peuvent être effectuées en
	 parallèle avec une transaction contenant ce mode de verrouillage.
	</para>

	<para>
         This lock mode is not automatically acquired on tables by any
         <productname>PostgreSQL</productname> command.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>ACCESS EXCLUSIVE</literal>
       </term>
       <listitem>
	<para>
	 Entre en conflit avec tous les modes (<literal>ACCESS
         SHARE</literal>, <literal>ROW SHARE</literal>, <literal>ROW
         EXCLUSIVE</literal>, <literal>SHARE UPDATE
         EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE
         ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
         <literal>ACCESS EXCLUSIVE</literal>).
	 Ce mode garantit que le détenteur est la seule transaction à accéder à
	 la table de quelque façon que ce soit.
	</para>

	<para>
	 Acquis par les commandes <command>DROP
	 TABLE</command>, <command>TRUNCATE</command>, <command>REINDEX</command>,
	 <command>CLUSTER</command> et <command>VACUUM FULL</command>, and some forms of <command>ALTER TABLE</>.. C'est
	 aussi le mode de verrou par défaut des instructions <command>LOCK
	 TABLE</command> qui ne spécifient pas explicitement de mode de verrouillage.
	</para>
       </listitem>
      </varlistentry>
     </variablelist>

     <tip>
      <para>
       Seul un verrou <literal>ACCESS EXCLUSIVE</literal> bloque une instruction
       <command>SELECT</command> (sans <option>FOR UPDATE/SHARE</option>).
      </para>
     </tip>

   <para>
    Une fois acquis, un verrou est normalement détenu jusqu'à la fin de la
    transaction. Mais si un verrou est acquis après l'établissement d'un point
    de sauvegarde, le verrou est relâché immédiatement si le point de sauvegarde
    est annulé. Ceci est cohérent avec le principe du <command>ROLLBACK</command>
    annulant tous les effets des commandes depuis le dernier point de sauvegarde.
    Il se passe la même chose pour les verrous acquis à l'intérieur d'un bloc
    d'exception <application>PL/pgSQL</application>&nbsp;: un échappement
    d'erreur à partir du bloc lâche les verrous acquis dans le bloc.
   </para>

    <table tocentry="1" id="table-lock-compatibility">
     <title>Modes de verrou conflictuels</title>
     <tgroup cols="9">
      <colspec colnum="2" colname="lockst" />
      <colspec colnum="9" colname="lockend" />
      <spanspec namest="lockst" nameend="lockend" spanname="lockreq"/>
      <thead>
       <row>
        <entry morerows="1">Verrou demandé</entry>
        <entry spanname="lockreq">Verrou déjà détenu</entry>
       </row>
       <row>
        <entry>ACCESS SHARE</entry>
        <entry>ROW SHARE</entry>
        <entry>ROW EXCLUSIVE</entry>
        <entry>SHARE UPDATE EXCLUSIVE</entry>
        <entry>SHARE</entry>
        <entry>SHARE ROW EXCLUSIVE</entry>
        <entry>EXCLUSIVE</entry>
        <entry>ACCESS EXCLUSIVE</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>ACCESS SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>ROW SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>ROW EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>SHARE UPDATE EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>SHARE ROW EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>EXCLUSIVE</entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
       <row>
        <entry>ACCESS EXCLUSIVE</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="locking-rows">
    <title>Verrous au niveau ligne</title>

    <para>
     En plus des verrous au niveau table, il existe des verrous au niveau
     ligne, qui peuvent être des verrous exclusifs ou partagés. Un verrou
     exclusif sur une ligne spécifique est automatiquement acquis
     lorsque la ligne est mise à jour ou supprimée. Le verrou est détenu jusqu'à
     la fin de la transaction, que ce soit une validation ou une annulation, de
     la même façon que les verrous de niveau table. Les verrous au niveau ligne
     n'affectent pas les requêtes sur les données&nbsp;; ils bloquent seulement
     les <emphasis>modifieurs d'une même ligne</emphasis>.
    </para>

    <para>
     Pour acquérir un verrou exclusif
     au niveau ligne sans modifier réellement la ligne, sélectionnez la ligne
     avec <command>SELECT FOR UPDATE</command>. Notez qu'une fois le verrou au
     niveau ligne acquis, la transaction pourrait mettre à jour la ligne
     plusieurs fois sans peur des conflits.
    </para>

    <para>
     Pour acquérir un verrou partagé niveau ligne sur une ligne spécifique,
     sélectionnez la ligne avec <command>SELECT FOR SHARE</command>.  Un verrou
     partagé n'empêche pas les autres transactions d'obtenir le même verrou
     partagé. Néanmoins, aucune transaction n'est autorisée à mettre à jour,
     supprimer ou verrouiller exclusivement une ligne dont une autre
     transaction a obtenu un verrou partagé. Toute tentative de le faire
     bloque tant que les verrous partagés n'ont pas été enlevés.
    </para>

    <para>
     <productname>PostgreSQL</productname> ne garde en mémoire aucune information
     sur les lignes modifiées, il n'y a donc aucune limite sur le
     nombre de lignes verrouillées à un moment donné. Néanmoins, verrouiller une
     ligne peut causer une écriture disque&nbsp;; ainsi, par exemple,
     <command>SELECT FOR UPDATE</command> modifie les lignes sélectionnées
     pour les marquer verrouillées et cela aboutit à des écritures disques.
    </para>

    <para>
     En plus des verrous tables et lignes, les verrous partagés/exclusifs sur
     les pages sont utilisés pour contrôler la lecture et l'écriture des pages
     de table dans l'ensemble des tampons partagées. Ces verrous sont
     immédiatement relâchés une fois la ligne récupérée ou mise à jour. Les
     développeurs d'applications ne sont normalement pas concernés par les
     verrous au niveau page mais nous les mentionnons dans un souci d'exhaustivité.
    </para>

   </sect2>

   <sect2 id="locking-deadlocks">
    <title>Verrous morts (blocage)</title>

    <indexterm zone="locking-deadlocks">
     <primary>verrou mort</primary>
    </indexterm>

    <indexterm zone="locking-deadlocks">
     <primary>blocage de verrous</primary>
    </indexterm>

    <para>
     L'utilisation de verrous explicites accroît le risque de
     <firstterm>verrous morts</firstterm> lorsque deux transactions (voire plus) détiennent
     chacune un verrou que l'autre convoite. Par exemple, si la transaction 1 a
     acquis un verrou exclusif sur la table A puis essaie d'acquérir un verrou
     exclusif sur la table B alors que la transaction 2 possède déjà un verrou
     exclusif sur la table B et souhaite maintenant un verrou exclusif sur la
     table A, alors aucun des deux ne peut continuer.
     <productname>PostgreSQL</productname> détecte automatiquement ces
     situations de blocage et les résout en annulant une des transactions
     impliquées, permettant ainsi à l'autre (aux autres) de se terminer
     (quelle est exactement la transaction annulée est difficile à prévoir mais
     vous ne devriez pas vous en préoccuper).
    </para>

    <para>
     Notez que les verrous morts peuvent aussi se produire en conséquence à
     des verrous de niveau ligne (et du coup, ils peuvent se produire même si
     le verrouillage explicite n'est pas utilisé). Considérons le cas où il
     existe deux transactions concurrentes modifiant une table. La première
     transaction exécute&nbsp;:

<screen>UPDATE comptes SET balance = balance + 100.00 WHERE no_compte = 11111;</screen>

     Elle acquiert un verrou au niveau ligne sur la ligne spécifiée par 
     le numéro de compte (no_compte). Ensuite, la deuxième transaction
     exécute&nbsp;:

<screen>UPDATE comptes SET balance = balance + 100.00 WHERE no_compte = 22222;
UPDATE comptes SET balance = balance - 100.00 WHERE no_compte = 11111;</screen>

     La première instruction <command>UPDATE</command> acquiert avec succès un
verrou au niveau ligne sur la ligne spécifiée, donc elle réussit à mettre à jour
la ligne. Néanmoins, la deuxième instruction <command>UPDATE</command> trouve
que la ligne qu'elle essaie de mettre à jour a déjà été verrouillée, alors elle
attend la fin de la transaction ayant acquis le verrou. Maintenant, la première
transaction exécute&nbsp;:

<screen>UPDATE comptes SET balance = balance - 100.00 WHERE no_compte = 22222;</screen>

     La première transaction essaie d'acquérir un verrou au niveau ligne sur 
     la ligne spécifiée mais ne le peut pas&nbsp;: la deuxième transaction
     détient déjà un verrou. Donc, elle attend la fin de la transaction deux. Du
     coup, la première transaction est bloquée par la deuxième et la deuxième
     est bloquée par la première&nbsp;: une condition de blocage, un verrou
     mort. <productname>PostgreSQL</productname> détectera cette situation et
     annulera une des transactions.
    </para>

    <para>
     La meilleure défense contre les verrous morts est généralement de les
     éviter en s'assurant que toutes les applications utilisant une base de
     données acquièrent des verrous sur des objets multiples dans un ordre
     cohérent. Dans l'exemple ci-dessus, si les deux transactions avaient mis
     à jour les lignes dans le même ordre, aucun blocage n'aurait eu lieu.
     Vous devez vous assurer que le premier verrou acquis sur un objet dans
     une transaction est dans le mode le plus restrictif pour cet objet. S'il
     n'est pas possible de vérifier ceci à l'avance, alors les blocages doivent
     être gérés à l'exécution en ré-essayant les transactions annulées à cause
     de blocage.
    </para>

    <para>
     Tant qu'aucune situation de blocage n'est détectée, une transaction
     cherchant soit un verrou de niveau table soit un verrou de niveau ligne
     attend indéfiniment que les verrous en conflit soient relâchés. Ceci
     signifie que maintenir des transactions ouvertes sur une longue période
     de temps (par exemple en attendant une saisie de l'utilisateur) est
     parfois une mauvaise idée.
    </para>
   </sect2>

   <sect2 id="advisory-locks">
    <title>Verrous informatifs</title>

    <indexterm zone="advisory-locks">
     <primary>lock</primary>
     <secondary>advisory</secondary>
    </indexterm>

    <indexterm zone="advisory-locks">
     <primary>verrou</primary>
     <secondary>informatif</secondary>
    </indexterm>

    <para>
     <productname>PostgreSQL</productname> fournit un moyen pour créer des
     verrous qui ont une signification définie par l'application. Ils sont
     qualifiés d'<firstterm>informatifs</firstterm> car le système ne force
     pas leur utilisation &mdash; c'est à l'application de les utiliser
     correctement. Les verrous informatifs peuvent être utiles pour
     des manières d'utiliser le verrouillage qui ne sont pas en phase avec le modèle MVCC. </para>

    <para>
     There are two different types of advisory locks in
     <productname>PostgreSQL</productname>: session level and transaction level.
     Once acquired, a session level advisory lock is held until explicitly
     released or the session ends.  Unlike standard locks, session level
     advisory locks do not honor transaction semantics: a lock acquired during
     a transaction that is later rolled back will still be held following the
      rollback, and likewise an unlock is effective even if the calling
     transaction fails later.  The same session level lock can be acquired
     multiple times by its owning process: for each lock request there must be
     a corresponding unlock request before the lock is actually released.  (If a
     session already holds a given lock, additional requests will always succeed,
     even if other sessions are awaiting the lock.)  Transaction level locks on
     the other hand behave more like regular locks; they are automatically
     released at the end of the transaction, and can not be explicitly unlocked.
     Session and transaction level locks share the same lock space, which means
     that a transaction level lock will prevent another session from obtaining
     a session level lock on that same resource and vice versa.
     Like all locks in <productname>PostgreSQL</productname>, a complete list of
     advisory locks currently held by any session can be found in the
      <link linkend="view-pg-locks"><structname>pg_locks</structname></link>
      system view.
     </para>

    <para>
     Les verrous informatifs sont alloués à partir d'une portion de mémoire
     partagée dont la taille est définie par les variables de configuration
     <xref linkend="guc-max-locks-per-transaction"/> et
     <xref linkend="guc-max-connections"/>. Attention à ne pas vider cette
     mémoire, sinon le serveur ne serait plus capable d'accorder des verrous.
     Ceci impose une limite supérieure au nombre de verrous informatifs que le
     serveur peut accorder, typiquement entre des dizaines et des centaines de
     milliers suivant la façon dont le serveur est configuré.
    </para>

    <para>
     Une utilisation commune des verrous informatifs est d'émuler des stratégies
     de verrou pessimiste, typiques des systèmes de gestion de données sur
     <quote>fichier plat</quote>. Alors qu'une option stockée dans une table
     pourrait être utilisée dans le même but, les verrous informatifs sont plus
     rapides, évitent le grossissement de MVCC et peuvent être automatiquement nettoyés
     par le serveur à la fin d'une session. Dans certains cas qui utilisent
     cette méthode, tout spécialement les requêtes impliquant un tri explicite
     et des clauses <literal>LIMIT</literal>, une grande attention doit être
     portée au contrôle des verrous acquis, à cause de l'ordre dans lequel les
     expressions SQL sont évaluées. Par exemple&nbsp;:
<screen>SELECT pg_advisory_lock(id) FROM foo WHERE id = 12345; -- ok
SELECT pg_advisory_lock(id) FROM foo WHERE id &gt; 12345 LIMIT 100; -- danger !
SELECT pg_advisory_lock(q.id) FROM
(
  SELECT id FROM foo WHERE id &gt; 12345 LIMIT 100
) q; -- ok
</screen>
     Dans les requêtes ci-dessus, la deuxième forme est dangereuse parce qu'il 
     n'est pas garanti que l'application de <literal>LIMIT</literal> ait lieu avant que la
     fonction du verrou soit exécutée. Ceci pourrait entraîner l'acquisition 
     de certains verrous que l'application n'attendait pas, donc qu'elle
     ne pourrait, du coup, pas relâcher (sauf à la fin de la session). Du point de vue de
     l'application, de tels verrous sont en attente, bien qu'ils soient visibles dans
     <structname>pg_locks</structname>.
    </para>

    <para>
     Les fonctions fournies pour manipuler les verrous informatifs sont décrites dans
     <xref linkend="functions-advisory-locks"/>.
    </para>
   </sect2>

  </sect1>

  <sect1 id="applevel-consistency">
   <title>Vérification de cohérence des données au niveau de l'application</title>

   <para>
    It is very difficult to enforce business rules regarding data integrity
    using Read Committed transactions because the view of the data is
    shifting with each statement, and even a single statement may not
    restrict itself to the statement's snapshot if a write conflict occurs.
    </para>
 
    <para>
    While a Repeatable Read transaction has a stable view of the data
    throughout its execution, there is a subtle issue with using
    <acronym>MVCC</acronym> snapshots for data consistency checks, involving
    something known as <firstterm>read/write conflicts</firstterm>.
    If one transaction writes data and a concurrent transaction attempts
    to read the same data (whether before or after the write), it cannot
    see the work of the other transaction.  The reader then appears to have
    executed first regardless of which started first or which committed
    first.  If that is as far as it goes, there is no problem, but
    if the reader also writes data which is read by a concurrent transaction
    there is now a transaction which appears to have run before either of
    the previously mentioned transactions.  If the transaction which appears
    to have executed last actually commits first, it is very easy for a
    cycle to appear in a graph of the order of execution of the transactions.
    When such a cycle appears, integrity checks will not work correctly
    without some help.
    </para>
 
    <para>
    As mentioned in <xref linkend="xact-serializable">, Serializable
    transactions are just Repeatable Read transactions which add
    non-blocking monitoring for dangerous patterns of read/write conflicts.
    When a pattern is detected which could cause a cycle in the apparent
    order of execution, one of the transactions involved is rolled back to
    break the cycle.
    </para>
 
   <sect2 id="serializable-consistency">
    <title>Enforcing Consistency With Serializable Transactions</title>
 
    <para>
     If the Serializable transaction isolation level is used for all writes
     and for all reads which need a consistent view of the data, no other
     effort is required to ensure consistency.  Software from other
     environments which is written to use serializable transactions to
     ensure consistency should <quote>just work</quote> in this regard in
     <productname>PostgreSQL</productname>.
    </para>

    <para>
     When using this technique, it will avoid creating an unnecessary burden
     for application programmers if the application software goes through a
     framework which automatically retries transactions which are rolled
     back with a serialization failure.  It may be a good idea to set
     <literal>default_transaction_isolation</> to <literal>serializable</>.
     It would also be wise to take some action to ensure that no other
     transaction isolation level is used, either inadvertently or to
     subvert integrity checks, through checks of the transaction isolation
     level in triggers.
    </para>

    <para>
     See <xref linkend="xact-serializable"> for performance suggestions.
    </para>

    <warning>
     <para>
      This level of integrity protection using Serializable transactions
      does not yet extend to hot standby mode (<xref linkend="hot-standby">).
      Because of that, those using hot standby may want to use Repeatable
      Read and explicit locking.on the master.
     </para>
    </warning>
   </sect2>

   <sect2 id="non-serializable-consistency">
    <title>Enforcing Consistency With Explicit Blocking Locks</title>

    <para>
     When non-serializable writes are possible,
     to ensure the current validity of a row and protect it against
     concurrent updates one must use <command>SELECT FOR UPDATE</command>,
     <command>SELECT FOR SHARE</command>, or an appropriate <command>LOCK
     TABLE</command> statement.  (<command>SELECT FOR UPDATE</command>
     and <command>SELECT FOR SHARE</command> lock just the
     returned rows against concurrent updates, while <command>LOCK
     TABLE</command> locks the whole table.)  This should be taken into
     account when porting applications to
     <productname>PostgreSQL</productname> from other environments.
    </para>

    <para>
     Also of note to those converting from other environments is the fact
     that <command>SELECT FOR UPDATE</command> does not ensure that a
     concurrent transaction will not update or delete a selected row.
     To do that in <productname>PostgreSQL</productname> you must actually
     update the row, even if no values need to be changed.
     <command>SELECT FOR UPDATE</command> <emphasis>temporarily blocks</emphasis>
     other transactions from acquiring the same lock or executing an
     <command>UPDATE</command> or <command>DELETE</command> which would
     affect the locked row, but once the transaction holding this lock
     commits or rolls back, a blocked transaction will proceed with the
     conflicting operation unless an actual <command>UPDATE</command> of
     the row was performed while the lock was held.
    </para>

    <para>
     Global validity checks require extra thought under
     non-serializable <acronym>MVCC</acronym>.
     For example, a banking application might wish to check that the sum of
     all credits in one table equals the sum of debits in another table,
     when both tables are being actively updated.  Comparing the results of two
     successive <literal>SELECT sum(...)</literal> commands will not work reliably in
     Read Committed mode, since the second query will likely include the results
     of transactions not counted by the first.  Doing the two sums in a
     single repeatable read transaction will give an accurate picture of only the
     effects of transactions that committed before the repeatable read transaction
     started &mdash; but one might legitimately wonder whether the answer is still
     relevant by the time it is delivered.  If the repeatable read transaction
     itself applied some changes before trying to make the consistency check,
     the usefulness of the check becomes even more debatable, since now it
     includes some but not all post-transaction-start changes.  In such cases
     a careful person might wish to lock all tables needed for the check,
     in order to get an indisputable picture of current reality.  A
     <literal>SHARE</> mode (or higher) lock guarantees that there are no
     uncommitted changes in the locked table, other than those of the current
     transaction.
    </para>

    <para>
     Note also that if one is relying on explicit locking to prevent concurrent
     changes, one should either use Read Committed mode, or in Repeatable Read
     mode be careful to obtain
     locks before performing queries.  A lock obtained by a
     repeatable read transaction guarantees that no other transactions modifying
     the table are still running, but if the snapshot seen by the
     transaction predates obtaining the lock, it might predate some now-committed
     changes in the table.  A repeatable read transaction's snapshot is actually
     frozen at the start of its first query or data-modification command
     (<literal>SELECT</>, <literal>INSERT</>,
     <literal>UPDATE</>, or <literal>DELETE</>), so
     it is possible to obtain locks explicitly before the snapshot is
     frozen.
    </para>
   </sect2>
  </sect1>
 </chapter>
